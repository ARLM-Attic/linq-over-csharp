using System.Text;
using System.Collections;
using CSharpFactory.ProjectModel;
using CSharpFactory.Syntax;

COMPILER CS2

// ================================================================================
// Scanner description
// ================================================================================

CHARACTERS

  tab                = '\u0009'. /*  9 = tabulator */
  eol                = '\u000a'. /* 10 = line feed */
  cr                 = '\u000d'. /* 13 = carriage return */
  newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */

  startLetter        = 'A' .. 'Z' + 'a' .. 'z' + '_' + '\u00aa' + '\u00b5' + '\u00ba' + '\u00c0' .. '\u00d6' + '\u00d8' .. '\u00f6' + '\u00f8' .. '\u00ff'.
  partLetter         = '0' .. '9' + 'A' .. 'Z' + 'a' .. 'z' + '_' + '\u00a0' + '\u00aa' + '\u00b5' + '\u00ba' + '\u00c0' .. '\u00d6' + '\u00d8' .. '\u00f6' + '\u00f8' .. '\u00ff'.

  digit              = "0123456789".  
  hexDigit           = digit + "ABCDEFabcdef".
  notDigit           = ANY - digit.

  char               = ANY - "'" - '\\' - newLine.
  verbatimStringChar = ANY - '"'.
  regularStringChar  = ANY - '"' - '\\' - newLine.
  notNewLine         = ANY - newLine .
  ws                 = " " + tab + '\u000b' + '\u000c'. /* Any character with Unicode class Zs */
  blockComCh         = ANY - '*' - '/'.

TOKENS

  ident =
    ['@']
    ( startLetter
    | '\\'
      ( 'u' hexDigit hexDigit hexDigit hexDigit
      | 'U' hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
      )
    )
    { partLetter
    | '\\'
      ( 'u' hexDigit hexDigit hexDigit hexDigit
      | 'U' hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
      )
    }.
  /*--------------------------------------------------------------------------------*/
  intCon =
    ( digit {digit} | digit {digit} CONTEXT ("." notDigit)
    | ("0x" | "0X") hexDigit {hexDigit}
    )
    ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"].
  /*--------------------------------------------------------------------------------*/
  realCon =
    "." digit {digit} 
    [("e" | "E") ["+" | "-"] digit {digit}] 
    ["F" | "f" | "D" | "d" | "M" | "m"]
  | digit {digit} 
    ( "." digit {digit} 
      [("e" | "E" ) ["+" | "-"] digit {digit} ] 
      ["F" | "f" | "D" | "d" | "M" | "m"]
    | ("e" | "E") ["+" | "-"] digit {digit}
      ["F" | "f" | "D" | "d" | "M" | "m"]
    | "F" | "f" | "D" | "d" | "M" | "m"
    ).
  /*--------------------------------------------------------------------------------*/
  charCon =
    "'" ( char
        | "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v"
        | "\\x" hexDigit [hexDigit] [hexDigit] [hexDigit]
        | "\\u" hexDigit hexDigit hexDigit hexDigit
        | "\\U" hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
        ) 
    "'".
  /*--------------------------------------------------------------------------------*/
  stringCon =
    "\""  { regularStringChar
          | "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v"
          | "\\x" hexDigit [hexDigit] [hexDigit] [hexDigit]
          | "\\u" hexDigit hexDigit hexDigit hexDigit
          | "\\U" hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
          } 
    "\""
  | "@\"" {verbatimStringChar | "\"\""} "\"".


  /*----- keyword names needed in LL(1) resolvers -----*/
  
  abstract   = "abstract".
  as         = "as".
  base       = "base".
  bool       = "bool".
  break      = "break".
  byte       = "byte".
  case       = "case".
  catch      = "catch".
  char       = "char".
  checked    = "checked".
  class      = "class".
  const      = "const".
  continue   = "continue".
  decimal    = "decimal".
  default    = "default".
  delegate   = "delegate".
  do         = "do".
  double     = "double".
  else       = "else".
  enum       = "enum".
  event      = "event".
  explicit   = "explicit".
  extern     = "extern".
  false      = "false".
  finally    = "finally".
  fixed      = "fixed".
  float      = "float".
  for        = "for".
  foreach    = "foreach".
  goto       = "goto".
  if         = "if".
  implicit   = "implicit".
  in         = "in".
  int        = "int".
  interface  = "interface".
  internal   = "internal".
  is         = "is".
  lock       = "lock".
  long       = "long".
  namespace  = "namespace".
  new        = "new".
  null       = "null".
  object     = "object".
  operator   = "operator".
  out        = "out".
  override   = "override".
  params     = "params".
  private    = "private".
  protected  = "protected".
  public     = "public".
  readonly   = "readonly".
  ref        = "ref".
  return     = "return".
  sbyte      = "sbyte".
  sealed     = "sealed".
  short      = "short".
  sizeof     = "sizeof".
  stackalloc = "stackalloc".
  static     = "static".
  string     = "string".
  struct     = "struct".
  switch     = "switch".
  this       = "this".
  throw      = "throw".
  true       = "true".
  try        = "try".
  typeof     = "typeof".
  uint       = "uint".
  ulong      = "ulong".
  unchecked  = "unchecked".
  unsafe     = "unsafe".
  ushort     = "ushort".
  usingKW    = "using".
  var        = "var".
  virtual    = "virtual".
  void       = "void".
  volatile   = "volatile".
  while      = "while".
  

  /*----- operators and special characters needed in LL(1) resolvers --------------*/
  and        = "&".
  andassgn   = "&=".
  assgn      = "=".
  colon      = ":".
  comma      = ",".
  dec        = "--".
  divassgn   = "/=".
  dot        = ".".
  dblcolon   = "::".
  eq         = "==".
  gt         = ">".
  gteq       = ">=".
  inc        = "++".
  lbrace     = "{".
  lbrack     = "[".
  lpar       = "(".
  lshassgn   = "<<=".
  lt         = "<".
  ltlt       = "<<".
  minus      = "-".
  minusassgn = "-=".
  modassgn   = "%=".
  neq        = "!=".
  not        = "!".
  orassgn    = "|=".
  plus       = "+".
  plusassgn  = "+=".
  question   = "?".
  rbrace     = "}".
  rbrack     = "]".
  rpar       = ")".
  scolon     = ";".
  tilde      = "~".
  times      = "*".
  timesassgn = "*=".
  xorassgn   = "^=".
  larrow     = "=>".

PRAGMAS

// Preprocessor directives.                                               
// The exact parsing of their syntax is left for later processing        

  ppDefine  = "#" {ws} "define" {notNewLine} newLine.     (. PragmaHandler.AddConditionalDirective(la); .)
  ppUndef   = "#" {ws} "undef" {notNewLine} newLine.      (. PragmaHandler.RemoveConditionalDirective(la); .)
  ppIf      = "#" {ws} "if" {notNewLine} newLine.         (. PragmaHandler.IfPragma(la); .)
  ppElif    = "#" {ws} "elif" {notNewLine} newLine.       (. PragmaHandler.ElifPragma(la); .) 
  ppElse    = "#" {ws} "else" {notNewLine} newLine.       (. PragmaHandler.ElsePragma(la); .) 
  ppEndif   = "#" {ws} "endif" {notNewLine} newLine.      (. PragmaHandler.EndifPragma(la); .) 
  ppLine    = "#" {ws} "line" {notNewLine} newLine.       (. PragmaHandler.LinePragma(la); .) 
  ppError   = "#" {ws} "error" {notNewLine} newLine.      (. PragmaHandler.ErrorPragma(la); .) 
  ppWarning = "#" {ws} "warning" {notNewLine} newLine.    (. PragmaHandler.WarningPragma(la); .) 
  ppPragma  = "#" {ws} "pragma" {notNewLine} newLine.     (. PragmaHandler.PragmaPragma(la); .) 
  ppRegion  = "#" {ws} "region" {notNewLine} newLine.     (. PragmaHandler.RegionPragma(la); .) 
  ppEndReg  = "#" {ws} "endregion" {notNewLine} newLine.  (. PragmaHandler.EndregionPragma(la); .) 

// Pragma for comments
  
  cBlockCom = "/*" { "/" | blockComCh | "*"{"*"} blockComCh } "*"{"*"}"/".  (. CommentHandler.HandleBlockComment(la); .)
  cLineCom  = "//" { notNewLine } newLine.                                  (. CommentHandler.HandleLineComment(la); .)

IGNORE eol + cr + tab

PRODUCTIONS

// ================================================================================================
// This is the definition of C# 3.0 grammar. The definition contains the grammar syntax definition 
// with the corresponding semantic actions. This is main entry point of the grammar parser.
// ================================================================================================
CS2
=                                                               
  { 
    IF (IsExternAliasDirective()) ExternAliasDirective<null, SourceFileNode>
  }
  {
    UsingDirective<null, SourceFileNode>
  }
  {
    IF (IsGlobalAttrTarget()) GlobalAttributes
  }
  {
    NamespaceMemberDeclaration<null, File, SourceFileNode>
  }
.

// ------------------------------------------------------------------------------------------------
// "extern alias" directive that is used in conjunction with a file or with a namespace
//   parent: Parent namespace of the "extern alias" directive. If this parameter is null, the 
//     directive belongs to the file and not to the specified namespace.
//   parentNode: Parent namespace scope (either a source file or a namespace) of the "extern alias" 
//     directive.
// ------------------------------------------------------------------------------------------------
ExternAliasDirective<NamespaceFragment parent, NamespaceScopeNode parentNode>
(.
   Token start;
   Token alias;
   Token identifier;
.)
=
  "extern"   
  (. 
     // --- We sign that the first real (not pragma) token arrived.
     PragmaHandler.SignRealToken(); 
     Token token = t; 
     // :::
     start = t;
  .)
  ident
  (. 
     if (t.val != "alias") Error1003(t, "alias"); 
     alias = t;
  .)
  ident      
  (. 
     ExternalAlias externAlias = new ExternalAlias(token, this);
     externAlias.Name = t.val;
     CurrentElement = externAlias;
     if (parent == null) File.ExternAliases.Add(externAlias); 
     else parent.ExternAliases.Add(externAlias); 
     // :::
     identifier = t;
  .)
  ";"
  (. 
     externAlias.Terminate(t); 
     // ::: 
     parentNode.AddExternAlias(start, alias, identifier, t);
  .)
.

// ------------------------------------------------------------------------------------------------
// "using" directive that is used in conjunction with a source file or a namespace.
//   parent: Parent namespace of the "using" directive. If this parameter is null, the directive 
//     belongs to the file and not to the specified namespace.
//   parentNode: Parent namespace scope (either a source file or a namespace) of the "using" 
//     directive.
// ------------------------------------------------------------------------------------------------
UsingDirective<NamespaceFragment parent, NamespaceScopeNode parentNode>
(.
   // :::
   Token alias = null;
   Token eq = null;
   TypeOrNamespaceNode nsNode = null;
.)                                     
=                           
  "using"
  (. 
     Token start = t;
     string name = String.Empty; 
     TypeReference typeUsed = null;
     PragmaHandler.SignRealToken();
  .)
  [ IF (IsAssignment()) 
    ident                 
    (. 
       name = t.val; 
       // :::
       alias = t;
    .)
    "="
    (. eq = t; .)
  ]
  TypeName<out typeUsed, out nsNode> 
  ";"
  (. 
     UsingClause uc = new UsingClause(start, this, name, typeUsed);
     CurrentElement = uc;
     if (parent == null) File.Usings.Add(uc);
     else parent.Usings.Add(uc); 
     uc.Terminate(t);
     // :::
     if (alias == null)
       parentNode.AddUsing(start, nsNode, t);
     else
       parentNode.AddUsingWithAlias(start, alias, eq, nsNode, t);
  .)
.

// ------------------------------------------------------------------------------------------------
// Global attributes belonging to a file. This element accepts only attributes with "assembly" or 
// "module" scope. All global attributes are assigned to the current source file node, so this
// production does not have any input parameter.
// ------------------------------------------------------------------------------------------------
GlobalAttributes
(.
   AttributeNode attrNode;
   // :::
   AttributeDecorationNode globAttrNode = null;
.)
=
  "["
  (. 
     // --- We sign that the first real (not pragma) token arrived.
     PragmaHandler.SignRealToken();
     // :::
     globAttrNode = new AttributeDecorationNode(t);
  .)
  ident                        
  (.
     // --- We accept "module" because csc does (even if it is against the specification).
     if (!"assembly".Equals(t.val) && !"module".Equals(t.val)) 
       Error("UNDEF", la, "Global attribute target specifier \"assembly\" or \"module\" expected");
     string scope = t.val;
     AttributeDeclaration attr;
     // :::
     globAttrNode.IdentifierToken = t;
  .) 
  ":"
  (.  globAttrNode.ColonToken = t; .)
  Attribute<out attr, out attrNode>
  (. 
     attr.Scope = scope; 
     File.GlobalAttributes.Add(attr);
     CurrentElement = attr;
     // :::
     globAttrNode.Attributes.Add(attrNode);
  .)
  { 
    IF (NotFinalComma()) ","   
    (. var separator = t; .)
    Attribute<out attr, out attrNode> 
    (. 
       attr.Scope = scope; 
       File.GlobalAttributes.Add(attr);
       CurrentElement = attr;
       // :::
       globAttrNode.Attributes.Add(new AttributeContinuationNode(separator, attrNode));
    .)
  } 
  [ 
    ","
    (. globAttrNode.ClosingSeparator = t; .) 
  ]
  "]"                          
  (. 
     attr.Terminate(t); 
     // :::
     globAttrNode.Terminate(t);
     SourceFileNode.GlobalAttributes.Add(globAttrNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a namespace member (type or nested namespace).
//   parent: Parent namespace of the type declaration. If this parameter is null, the type belongs 
//     to the file and not to the specified namespace.
//   file: file that defines the namespace.
//   parentNode: Parent namespace scope (either a source file or a namespace) of the namespace 
//     member declaration.
// ------------------------------------------------------------------------------------------------
NamespaceMemberDeclaration<NamespaceFragment parent, SourceFile file, 
  NamespaceScopeNode parentNode>  
=
  "namespace"    
  (. 
     // --- We sign that the first real (not pragma) token arrived.
     PragmaHandler.SignRealToken();
     Token startToken = t; 
     // ::: 
     var nsDecl = new NamespaceDeclarationNode(parentNode, t);
  .)
  ident
  (. 
     StringBuilder sb = new StringBuilder(t.val); 
     // :::
     nsDecl.NameTags.Add(t);
  .)
  {              
    "."
    (.
       // :::
       var sepToken = t;
    .)
    ident
    (. 
       sb.Append("."); sb.Append(t.val); 
       // :::
       nsDecl.NameTags.Add(sepToken, t);
    .)
  } 
  (. 
     NamespaceFragment ns = new NamespaceFragment(startToken, this, sb.ToString(), parent, file); 
     CurrentElement = ns;
     // :::
     parentNode.NamespaceDeclarations.Add(nsDecl);
  .)
  "{"
  (.
     // :::
     nsDecl.OpenBracket = t;
  .)
  { IF (IsExternAliasDirective()) ExternAliasDirective<ns, nsDecl> } 
  { UsingDirective<ns, nsDecl> } 
  { NamespaceMemberDeclaration<ns, File, nsDecl> } 
  "}"
  (. 
     ns.Terminate(t); 
     // :::
     nsDecl.CloseBracket = t;
     nsDecl.Terminate(t);
  .)
  [ 
    ";"
    (. 
       ns.Terminate(t); 
       // :::
       nsDecl.Terminate(t);
    .)
  ]
  | 
    (. 
       Modifiers m = new Modifiers(this); 
       TypeDeclaration td;
       AttributeCollection attrs = new AttributeCollection();
       // :::
       var mod = new ModifierNodeCollection();
       var attrNodes = new AttributeDecorationNodeCollection();
    .)  
    AttributeDecorations<attrs, attrNodes>
    ModifierList<m, mod> 
    (. TypeDeclarationNode typeDecl; .)
    TypeDeclaration<attrs, null, m, out td, parentNode, null, out typeDecl>
    (.
       if (td != null)
       {
         if (parent == null) File.AddTypeDeclaration(td);
         else parent.AddTypeDeclaration(td);
       }
       // :::
       if (typeDecl != null)
       {
         typeDecl.AttributeDecorations = attrNodes;
         typeDecl.Modifiers = mod;
         typeDecl.DeclaringNamespace = parentNode;
         parentNode.TypeDeclarations.Add(typeDecl);
       }
    .)
.

// ------------------------------------------------------------------------------------------------
// Type declaration within a file or a namespace.
//   attrs: Attributes belonging to the type declaration.
//   modifiers: Set of modifiers belongign to the type declaration.
//   td: Resulting type declaration.
//   parentNs: parent namespace scope (file or namespace)
//   declaringType: parent declaring type (null if this is not a nested type declaration)
//   typeDecl: Resulting type declaration syntax node.
// ------------------------------------------------------------------------------------------------
TypeDeclaration<AttributeCollection attrs, TypeDeclaration parentType, Modifiers m, 
  out TypeDeclaration td, NamespaceScopeNode parentNs, TypeDeclarationNode declaringType,
  out TypeDeclarationNode typeDecl>            
  (. 
     td = null;
     bool isPartial = false;
     // :::
     typeDecl = null; 
  .)
= 
  (                                                             
    [ 
      "partial"                                      
      (. isPartial = true; .)
    ]
    ( 
      ClassDeclaration<m, parentType, isPartial, out td, out typeDecl> |                                                           
      StructDeclaration<m, parentType, isPartial, out td, out typeDecl> |                                                           
      InterfaceDeclaration<m, parentType, isPartial, out td, out typeDecl>                                                           
    )                                                          
    | EnumDeclaration<m, parentType, out td, out typeDecl> 
    | DelegateDeclaration<m, parentType, out td, out typeDecl>
  )
  (. 
     if (td != null)
     {
        td.SetModifiers(m.Value); 
        td.AssignAttributes(attrs);
        td.Terminate(t);
     }
     // :::
     if (typeDecl != null)
     {
       typeDecl.IsPartial = isPartial;
       typeDecl.DeclaringNamespace = parentNs;
       typeDecl.DeclaringType = declaringType;
       typeDecl.Terminate(t);
     }
  .)                               
.

// ------------------------------------------------------------------------------------------------
// Class declaration.
//   modifiers: Set of modifiers belonging to the type.
//   parentType: Parent type declaration
//   partial: Flag indicating if this is a partial type definition or not.
//   td: Resulting type declaration.
//   typeDecl: Resulting type declaration syntax node.
// ------------------------------------------------------------------------------------------------
ClassDeclaration<Modifiers m, TypeDeclaration parentType, bool isPartial, 
  out TypeDeclaration td, out TypeDeclarationNode typeDecl>
=
  "class"                                            
  (. 
     ClassDeclaration cd = new ClassDeclaration(t, this, parentType);
     cd.IsPartial = isPartial;
     td = cd;
     CurrentElement = cd;
     // :::
     var start = t;
  .)
  ident    
  (. 
     cd.Name = t.val; 
     // :::
     var classDecl = new ClassDeclarationNode(start, t);
     typeDecl = classDecl;
  .)
  [ TypeParameterList<cd, typeDecl> ] 
  [ BaseTypeList<cd, typeDecl> ]
  {                                                  
    (. 
       TypeParameterConstraint constraint; 
       // :::
       TypeParameterConstraintNode constrNode; 
    .)
    TypeParameterConstraintsClause<out constraint, out constrNode>   
    (. 
       td.AddTypeParameterConstraint(constraint); 
       // :::
       typeDecl.TypeParameterConstraints.Add(constrNode);
    .)
  } ClassBody<td, classDecl>
  (. typeDecl.Terminate(t); .)
  [ 
    ";" 
    (. typeDecl.Terminate(t); .)
  ]                                                       
.

// ------------------------------------------------------------------------------------------------
// Base type and interface declaration of a class, struct or interface.
//   td: Type declaration that has the base types defined here.
//   typeDecl: Type declaration node inheriting from base types defined here.
// ------------------------------------------------------------------------------------------------
BaseTypeList<TypeDeclaration td, TypeDeclarationNode typeDecl>
  (. 
     TypeReference typeRef; 
     // :::
     TypeOrNamespaceNode typeNode;
  .)
=
  ":"                        
  ClassType<out typeRef, out typeNode>     
  (. 
     td.InterfaceList.Add(typeRef); 
     // ::: 
     typeDecl.BaseTypes.Add(typeNode);
  .)
  { 
    ","  
    (. var separator = t; .)
    ClassType<out typeRef, out typeNode>    
    (. 
       td.InterfaceList.Add(typeRef); 
       // :::
       typeDecl.BaseTypes.Add(new TypeOrNamespaceContinuationNode(separator, typeNode));
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Body declaration of a class.
//   td: Class declaration that has the body defined here.
//   typeDecl: Class declaration node for the body defined here.
// ------------------------------------------------------------------------------------------------
ClassBody<TypeDeclaration td, ClassDeclarationNode typeDecl>
  (. AttributeCollection attrs = new AttributeCollection(); .)
=
  "{" 
  (. typeDecl.OpenBrace = t; .)
  {
    (. 
       attrs = new AttributeCollection(); 
       var attrNodes = new AttributeDecorationNodeCollection();
    .)
    AttributeDecorations<attrs, attrNodes>
    (. 
       Modifiers m = new Modifiers(this); 
       var mod = new ModifierNodeCollection();
    .)                          
    ModifierList<m, mod>
    (. MemberDeclarationNode memNode; .)
    ClassMemberDeclaration<attrs, m, td, out memNode>
    (. 
       if (memNode != null) 
       {
         memNode.AttributeDecorations = attrNodes;
         
         typeDecl.MemberDeclarations.Add(memNode); 
       }
    .)
  }
  "}"
  (. typeDecl.CloseBrace = t; .)
.

// ------------------------------------------------------------------------------------------------
// Structure declaration within a file a namespace.
//   modifiers: Set of modifiers belonging to the type.
//   parentType: Parent type declaration
//   partial: Flag indicating if this is a partial type definition or not.
//   td: Resulting type declaration.
//   typeDecl: Resulting type declaration syntax node.
// ------------------------------------------------------------------------------------------------
StructDeclaration<Modifiers m, TypeDeclaration parentType, bool isPartial, 
  out TypeDeclaration td, out TypeDeclarationNode typeDecl>
  (. TypeOrNamespaceNode typeNode; .)      
=
  "struct"
  (. 
     StructDeclaration sd = new StructDeclaration(t, this, parentType);
     td = sd;
     CurrentElement = sd;
     sd.IsPartial = isPartial;
     TypeReference typeRef;
     // :::
     var start = t;
  .)
  ident
  (. 
     sd.Name = t.val; 
     // :::
     var structDecl = new StructDeclarationNode(start, t);
     typeDecl = structDecl;
  .)
  [ TypeParameterList<sd, typeDecl> ]
  [ BaseTypeList<sd, typeDecl> ]
  {                                                
    (. 
       TypeParameterConstraint constraint; 
       TypeParameterConstraintNode constrNode; 
    .)
    TypeParameterConstraintsClause<out constraint, out constrNode> 
    (. 
       td.AddTypeParameterConstraint(constraint); 
       // :::
       typeDecl.TypeParameterConstraints.Add(constrNode);
    .)
  } 
  StructBody<td, structDecl>
  (. typeDecl.Terminate(t); .)
  [ 
    ";" 
    (. typeDecl.Terminate(t); .)
  ]                                                       
.

// ------------------------------------------------------------------------------------------------
// Body declaration of a structure.
//   td: Structure declaration that has the body defined here.
//   typeDecl: Structure declaration node of the body defined here.
// ------------------------------------------------------------------------------------------------
StructBody<TypeDeclaration td, StructDeclarationNode typeDecl>
  (.  AttributeCollection attrs = new AttributeCollection(); .)
=
  "{" 
  (. typeDecl.OpenBrace = t; .)
  {
    (. 
       attrs = new AttributeCollection(); 
       var attrNodes = new AttributeDecorationNodeCollection();
    .)
    AttributeDecorations<attrs, attrNodes>
    (. 
       Modifiers m = new Modifiers(this); 
       // :::
       var mod = new ModifierNodeCollection();
    .)                             
    ModifierList<m, mod>
    (. MemberDeclarationNode memNode; .)
    StructMemberDeclaration<attrs, m, td, out memNode>
  }
  "}"   
  (. typeDecl.CloseBrace = t; .)
.

// ------------------------------------------------------------------------------------------------
// Enumerated type declaration within a file or a namespace
//   modifiers: Set of modifiers belonging to the type.
//   parentType: Parent type declaration
//   td: Resulting type declaration.
//   typeDecl: Resulting type declaration syntax node.
// ------------------------------------------------------------------------------------------------
EnumDeclaration<Modifiers m, TypeDeclaration parentType, out TypeDeclaration td,
  out TypeDeclarationNode typeDecl>
  (. TypeOrNamespaceNode typeNode; .)      
=
  "enum"                         
  (. 
     EnumDeclaration ed = new EnumDeclaration(t, this, parentType);
     td = ed;
     CurrentElement = ed;
     // :::
     var start = t;
  .)
  ident                          
  (. 
     ed.Name = t.val;
     var enumDecl = new EnumDeclarationNode(start, t);
     typeDecl = enumDecl;
  .)
  [ 
    ":"                          
    (. TypeReference typeRef; .)
    ( 
      ClassType<out typeRef, out typeNode>     
      (. ed.InterfaceList.Add(typeRef); .)
      |
      (. TypeOrNamespaceNode itypeNode; .)
      IntegralType<out typeRef, out itypeNode>  
      (. ed.InterfaceList.Add(typeRef); .)
    )
  ] 
  EnumBody<ed, enumDecl>                   
  (. 
     ed.Terminate(t); 
     // :::
     typeDecl.Terminate(t);
  .)
  [ 
    ";"                          
    (. 
       ed.Terminate(t); 
       // :::
       typeDecl.Terminate(t);
    .)
  ]                                                       
.

// ------------------------------------------------------------------------------------------------
// Body declaration of an enumerated type.
//   ed: Enumeration declaration that has the body defined here.
//   typeDecl: Enumeration declaration for the body defined here.
// ------------------------------------------------------------------------------------------------
EnumBody<EnumDeclaration ed, EnumDeclarationNode typeDecl>
=
  "{" 
  (. typeDecl.OpenBrace = t; .)
  [ 
    EnumMemberDeclaration<ed> 
    {IF (NotFinalComma())  "," SYNC EnumMemberDeclaration<ed>} 
    [ "," ] 
  ] 
  SYNC "}"
  (. typeDecl.CloseBrace = t; .)
.

// ------------------------------------------------------------------------------------------------
// Enumeration value declaration.
//   ed: Enumeration declaration that has the member values defined here.
// ------------------------------------------------------------------------------------------------
EnumMemberDeclaration<EnumDeclaration ed>  
=                            (. 
                                 AttributeCollection attrs = new AttributeCollection(); 
                                 // :::
                                 ExpressionNode exprNode;
                                 var attrNodes = new AttributeDecorationNodeCollection();
                             .)
  AttributeDecorations<attrs, attrNodes>
  ident                      (. 
                                 EnumValueDeclaration ev = new EnumValueDeclaration(t, this); 
                                 CurrentElement = ev;
                                 Expression expr;
                             .)
  [ 
    "=" Expression<out expr, out exprNode> (. ev.ValueExpression = expr; .)
  ]     
                             (.
                                ev.AssignAttributes(attrs);
                                ed.Values.Add(ev);
                                ev.Terminate(t);
                             .)
.

// ------------------------------------------------------------------------------------------------
// Delegate type declaration within a file a namespace.
//   modifiers: Set of modifiers belonging to the type.
//   parentType: Parent type declaration
//   td: Resulting type declaration.
//   typeDecl: Resulting type declaration syntax node.
// ------------------------------------------------------------------------------------------------
DelegateDeclaration<Modifiers m, TypeDeclaration parentType, out TypeDeclaration td,
  out TypeDeclarationNode typeDecl>
=
  "delegate"                                       
  (. 
     DelegateDeclaration dd = new DelegateDeclaration(t, this, parentType);
     td = dd;
     CurrentElement = dd;
     TypeReference returnType;
     // :::
     var start = t;
     TypeOrNamespaceNode typeNode;
  .)
  Type<out returnType, true, out typeNode>
  (. dd.ReturnType = returnType; .)
  ident
  (. 
     dd.Name = t.val; 
     typeDecl = new DelegateDeclarationNode(start, t);
  .)
  [ TypeParameterList<dd, typeDecl> ]
  "(" 
  [ FormalParameterList<dd.FormalParameters> ] 
  ")"
  {                                                
    (. 
       TypeParameterConstraint constraint; 
       TypeParameterConstraintNode constrNode; 
    .)
    TypeParameterConstraintsClause<out constraint, out constrNode> 
    (. 
       td.AddTypeParameterConstraint(constraint); 
       // :::
       typeDecl.TypeParameterConstraints.Add(constrNode);
    .)
  } 
  ";"                                                         
  (. typeDecl.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Declaration of a class member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
ClassMemberDeclaration<AttributeCollection attrs, Modifiers m, TypeDeclaration td,
  out MemberDeclarationNode memNode>
  (. memNode = null; .)
=
  StructMemberDeclaration<attrs, m, td, out memNode>
  | 
    "~" 
    (. 
       var finNode = new FinalizerDeclarationNode(t);
       memNode = finNode;
    .)
    ident   
    (. 
       FinalizerDeclaration dd = new FinalizerDeclaration(t, td);
       CurrentElement = dd;
       dd.Name = t.val;
       dd.SetModifiers(m.Value);
       dd.AssignAttributes(attrs);
       // :::
       finNode.IdentifierToken = t;
    .)
    "(" 
    (. finNode.OpenParenthesis = t; .)
    ")" 
    (. finNode.CloseParenthesis = t; .)
    ( 
      Block<dd> | ";" 
    )
    (. 
       dd.Terminate(t);
       td.AddMember(dd); 
       // :::
       memNode.Terminate(t);
    .)
.

// ------------------------------------------------------------------------------------
// Declaration of a structure member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
StructMemberDeclaration<AttributeCollection attrs, Modifiers m, TypeDeclaration td,
  out MemberDeclarationNode memNode>        
  (. 
     TypeReference typeRef;
     TypeReference memberRef; 
     // :::
     memNode = null;
  .)
=                                             
  (                                                                          
    ConstMemberDeclaration<attrs, m, td, out memNode> 
  | EventDeclaration<attrs, m, td, out memNode> 
  | IF (la.kind == _ident && Peek(1).kind == _lpar)                         
      ConstructorDeclaration<attrs, m, td, out memNode> 
    | IF (IsPartialMethod())
      "partial"
      (. TypeOrNamespaceNode typeNode; .)
      Type<out typeRef, true, out typeNode>
      MemberName<out memberRef>
      MethodDeclaration<attrs, m, typeRef, memberRef, td, true>
    | 
      (. TypeOrNamespaceNode typeNode; .)
      Type<out typeRef, true, out typeNode>
    ( 
      OperatorDeclaration<attrs, m, typeRef, td>
      | // --- Field declaration
        IF (IsFieldDecl()) FieldMemberDeclarators<attrs, m, td, typeRef, false, Modifier.fields> ";"
      |                                          
        MemberName<out memberRef>
        ( 
          PropertyDeclaration<attrs, m, typeRef, memberRef, td>
          | "." IndexerDeclaration<attrs, m, typeRef, memberRef, td>
          | MethodDeclaration<attrs, m, typeRef, memberRef, td, true>
        )
      | IndexerDeclaration<attrs, m, typeRef, null, td>
    )
    | CastOperatorDeclaration<attrs, m, td>
    |                                               (. 
                                                       TypeDeclaration nestedType; 
                                                       // :::
                                                       TypeDeclarationNode nestedTypeNode;
                                                    .)
      TypeDeclaration<attrs, td, m, out nestedType, null, null, out nestedTypeNode> 
      (. 
         td.AddTypeDeclaration(nestedType); 
         // :::
         if (nestedTypeNode != null)
         {
           // TODO: Handle attributes and modifiers
           //nestedTypeNode.AttributeDecorations = attrNodes;
           //nestedTypeNode.Modifiers = mod;
         }
      .)
  )
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "const" member.
//   attrs: attributes of the declaration
//   modifiers: Set of modifiers belonging to the member.
//   td: Type declaration the member belongs to.
//   memNode: Member declaration node.
// ------------------------------------------------------------------------------------------------
ConstMemberDeclaration<AttributeCollection attrs, Modifiers m, TypeDeclaration td,
  out MemberDeclarationNode memNode>
  (. memNode = null; .)
=                                    
  "const"
  (. 
     TypeReference typeRef; 
     // :::
     var constNode = new ConstMemberDeclarationNode(t);
     memNode = constNode;
     TypeOrNamespaceNode typeNode;
  .)
  Type<out typeRef, false, out typeNode>
  (. 
     memNode.TypeName = typeNode; 
     ConstMemberTagNode tagNode;
  .)
  SingleConstMember<attrs, m, td, typeRef, out tagNode>
  (. constNode.ConstTags.Add(tagNode); .)
  {
    "," 
    (. var separator = t; .)
    SingleConstMember<attrs, m, td, typeRef, out tagNode> 
    (. constNode.ConstTags.Add(new ConstMemberContinuationTagNode(separator, tagNode)); .)
  } 
  ";"
  (. memNode.Terminate(t); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a single "const" member.
//   attrs: attributes of the declaration
//   modifiers: Set of modifiers belonging to the member.
//   td: Type declaration the member belongs to.
//   typeRef: Type of the constant.
//   tagNode: const member tag declaration.
// ------------------------------------------------------------------------------------------------
SingleConstMember<AttributeCollection attrs, Modifiers m, TypeDeclaration td, 
  TypeReference typeRef, out ConstMemberTagNode tagNode>
=
  ident
  (. 
     ConstDeclaration cd = new ConstDeclaration(t, td); 
     CurrentElement = cd;
     cd.AssignAttributes(attrs);
     cd.SetModifiers(m.Value);
     cd.ResultingType = typeRef;
     cd.Name = t.val;
     // :::
     tagNode = new ConstMemberTagNode(t);
  .)
  "="
  (. 
     td.AddMember(cd);
     Expression expr;
     // :::
     tagNode.EqualToken = t;
     ExpressionNode exprNode;
  .)
  Expression<out expr, out exprNode>
  (. 
     cd.Expression = expr; 
     cd.Terminate(t);
     // :::
     tagNode.Expression = exprNode;
     tagNode.Terminate(t);
  .)
.

// ------------------------------------------------------------------------------------
// Declaration of a event member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
EventDeclaration<AttributeCollection attrs, Modifiers m, TypeDeclaration td, 
  out MemberDeclarationNode memNode>
  (. 
     TypeReference typeRef; 
     // :::
     TypeOrNamespaceNode nsNode = null;
     memNode = null;
  .)
=
  "event" 
  (. TypeOrNamespaceNode typeNode; .)
  Type<out typeRef, false, out typeNode>
  ( IF (IsFieldDecl()) 
    FieldMemberDeclarators<attrs, m, td, typeRef, true, Modifier.propEvntMeths> ";"
  |                              (. TypeReference memberRef; .)
    TypeName<out memberRef, out nsNode> 
    "{"                          (. EventPropertyDeclaration ep = new EventPropertyDeclaration(t, td);  .)   
                                 (. CurrentElement = ep; .)
                                 (. ep.ResultingType = typeRef; .) 
                                 (. ep.ExplicitName = memberRef; .)
                                 (. td.AddMember(ep); .)
    EventAccessorDeclarations<ep>
    "}"                          (. ep.Terminate(t); .)
  )
.

// ------------------------------------------------------------------------------------
// Declaration of a constructor member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
ConstructorDeclaration<AttributeCollection attrs, Modifiers m, TypeDeclaration td,
  out MemberDeclarationNode memNode>
  (. memNode = null; .)
= 
    ident                   (. 
                               ConstructorDeclaration cd = new ConstructorDeclaration(t, td);
                               CurrentElement = cd;
                               cd.SetModifiers(m.Value);
                               cd.AssignAttributes(attrs);
                            .)
    "(" 
    [                                    
      FormalParameterList<cd.FormalParameters>
    ] 
    ")" 
    [                                        
      ":" ( "base"          (. cd.HasBase = true; .)
      | "this"              (. cd.HasThis = true; .)
      ) "("
    [ Argument<cd.BaseArguments> { "," Argument<cd.BaseArguments> } ] ")"
    ] ( Block<cd> | ";" )   (. 
                               td.AddMember(cd); 
                               cd.Terminate(t);
                            .)
.

// ------------------------------------------------------------------------------------
// Declaration of a property member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +typeRef: type of the property
// +memberRef: member name reference.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
PropertyDeclaration<AttributeCollection attrs, Modifiers m, TypeReference typeRef, 
  TypeReference memberRef, TypeDeclaration td>
=                 (. 
                     PropertyDeclaration pd = new PropertyDeclaration(t, td);
                     CurrentElement = pd;
                     pd.SetModifiers(m.Value);
                     pd.AssignAttributes(attrs);
                     pd.ExplicitName = memberRef;
                     pd.ResultingType = typeRef;
                  .)
  "{" 
     AccessorDeclarations<pd> 
  "}"             (. 
                     td.AddMember(pd); 
                     pd.Terminate(t);
                  .)
.

// ------------------------------------------------------------------------------------
// Declaration of an indexer member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +typeRef: type of the property
// +memberRef: member name reference.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
IndexerDeclaration<AttributeCollection attrs, Modifiers m, TypeReference typeRef, 
  TypeReference memberRef, TypeDeclaration td>
=                 (. 
                     IndexerDeclaration ind = new IndexerDeclaration(t, td);
                     CurrentElement = ind;
                     ind.SetModifiers(m.Value);
                     ind.AssignAttributes(attrs);
                     if (memberRef != null) 
                     {
                       ind.ExplicitName = memberRef;
                       ind.Name = memberRef.FullName;
                     }
                     else
                     {
                       ind.Name = "this";
                     }
                     ind.ResultingType = typeRef;
                  .)
  "this" "[" [ FormalParameterList<ind.FormalParameters> ] "]" 
  "{" 
      AccessorDeclarations<ind> 
  "}"             (. 
                     td.AddMember(ind); 
                     ind.Terminate(t);
                  .)
.

// ------------------------------------------------------------------------------------
// Declaration of a method member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +typeRef: type of the property
// +memberRef: member name reference.
// +td: Type declaration the member belongs to.
// +allowBody: indicates if method body is allowd or not.
// ------------------------------------------------------------------------------------
MethodDeclaration<AttributeCollection attrs, Modifiers m, TypeReference typeRef, 
  TypeReference memberRef, TypeDeclaration td, bool allowBody>
=                                                   (. 
                                                       MethodDeclaration md = new MethodDeclaration(t, td);
                                                       CurrentElement = md;
                                                       md.SetModifiers(m.Value);
                                                       md.AssignAttributes(attrs);
                                                       md.ExplicitName = memberRef;
                                                       md.ResultingType = typeRef;
                                                    .)
  [ TypeParameterList<md, null> ]
  "(" [ 
    FormalParameterList<md.FormalParameters>
  ] ")"
  {                                                 
    (. 
       TypeParameterConstraint constraint; 
       TypeParameterConstraintNode constrNode; 
    .)
    TypeParameterConstraintsClause<out constraint, out constrNode>  
    (. md.AddTypeParameterConstraint(constraint); .)
  } 
  ( 
    Block<md>                                       (. 
                                                       if (!allowBody || m.Has(Modifier.@abstract)) { Error("UNDEF", la, "Body declaration is not allowed here!"); } 
                                                       md.HasBody = true;
                                                    .)
    | ";"                                           (. md.HasBody = false; .)
  )                                                 (. 
                                                       td.AddMember(md); 
                                                       md.Terminate(t);
                                                    .)
.

// ------------------------------------------------------------------------------------
// Declaration of a cast operator.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
CastOperatorDeclaration<AttributeCollection attrs, Modifiers m, TypeDeclaration td>
=                                       (. 
                                           CastOperatorDeclaration cod = new CastOperatorDeclaration(t, td);
                                           CurrentElement = cod;
                                           cod.SetModifiers(m.Value);
                                           cod.AssignAttributes(attrs);
                                           TypeReference typeRef;
                                        .)
    ( 
      "implicit"                        
      | "explicit"                      (. cod.IsExplicit = true; .)
    ) "operator"                        
    (. TypeOrNamespaceNode typeNode; .)
    Type<out typeRef, false, out typeNode>
                                        (. 
                                           cod.ResultingType = typeRef;
                                           cod.Name = typeRef.TailName;
                                        .)
    "("                                 
      [ FormalParameterList<cod.FormalParameters> ]   
    ")"                                 
    ( Block<cod> | ";" )                (. 
                                           td.AddMember(cod); 
                                           cod.Terminate(t);
                                        .)
.

// ------------------------------------------------------------------------------------
// Declaration of an operator overload member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +typeRef: resulting type reference.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
OperatorDeclaration<AttributeCollection attrs, Modifiers m, TypeReference typeRef, 
  TypeDeclaration td>
=                                  (. 
                                      OperatorDeclaration od = new OperatorDeclaration(t, td);
                                      CurrentElement = od;
                                      od.SetModifiers(m.Value);
                                      od.AssignAttributes(attrs);
                                      od.ResultingType = typeRef;
                                      Operator op;
                                   .)
  "operator" 
  OverloadableOp<out op>           (. od.Operator = op; .)
  "("                              (. od.Name = op.ToString(); .)
    [ FormalParameterList<od.FormalParameters> ]
  ")"
  ( Block<od> | ";" )              (. 
                                      td.AddMember(od); 
                                      od.Terminate(t);
                                   .)
.

// ------------------------------------------------------------------------------------
// Declaration of an interface.
//   modifiers: Set of modifiers belonging to the type.
//   parentType: Parent type declaration
//   isPartial: indicates partial modifier.
//   td: Resulting type declaration.
//   typeDecl: Resulting type declaration syntax node.
// ------------------------------------------------------------------------------------
InterfaceDeclaration<Modifiers m, TypeDeclaration parentType, bool isPartial, 
  out TypeDeclaration td, out TypeDeclarationNode typeDecl>
=
  "interface"       
  (. 
     InterfaceDeclaration ifd = new InterfaceDeclaration(t, this, parentType);
     CurrentElement = ifd;
     td = ifd;
     ifd.IsPartial = isPartial;
     var start = t;
  .)
  ident            
  (. 
     ifd.Name = t.val; 
     // :::
     var intfDecl = new InterfaceDeclarationNode(start, t);
     typeDecl = intfDecl;
  .)
  [ TypeParameterList<ifd, typeDecl> ]
  [ BaseTypeList<ifd, typeDecl> ]
  {                                                   
    (. 
       TypeParameterConstraint constraint; 
       TypeParameterConstraintNode constrNode; 
    .)
    TypeParameterConstraintsClause<out constraint, out constrNode>    
    (. 
       td.AddTypeParameterConstraint(constraint); 
       // :::
       typeDecl.TypeParameterConstraints.Add(constrNode);
    .)
  }
  "{" 
  (. intfDecl.OpenBrace = t; .)
  { InterfaceMemberDeclaration<ifd, intfDecl> } 
  "}" 
  (. 
     intfDecl.CloseBrace = t;
     typeDecl.Terminate(t);
  .)
  [ 
    ";" 
    (. typeDecl.Terminate(t); .)
  ]                                                       
.

// ------------------------------------------------------------------------------------------------
// Declaration of an interface member.
//   idf: Declaration representing the interface type.
//   typeDecl: Declaration node representing the interface type.
// ------------------------------------------------------------------------------------------------
InterfaceMemberDeclaration<InterfaceDeclaration ifd, InterfaceDeclarationNode typeDecl>
  (. 
     var m = new Modifiers(this);
     TypeReference typeRef;
     var attrs = new AttributeCollection();
     var pars = new FormalParameterCollection();
     // :::
     var mod = new ModifierNodeCollection();
     var attrNodes = new AttributeDecorationNodeCollection();
  .)
=                              
  AttributeDecorations<attrs, attrNodes>
  ModifierList<m, mod>
  ( 
    (. TypeOrNamespaceNode typeNode; .)
    Type<out typeRef, true, out typeNode>
    (                          
      ident                   (.
                                 TypeReference memberRef = new TypeReference(t, this); 
                                 memberRef.Name = t.val;
                              .)
      ( 
        MethodDeclaration<attrs, m, typeRef, memberRef, ifd, false>        
      | // --- Interface property
        (. PropertyDeclaration prop = new PropertyDeclaration(t, ifd); .)
        (. CurrentElement = prop; .)
        (. ifd.AddMember(prop); .)
        (. prop.ResultingType = typeRef; .)
        (. prop.ExplicitName = memberRef; .)
        (. prop.AssignAttributes(attrs); .)
        (. prop.SetModifiers(m.Value); .)
        "{" InterfaceAccessors<prop> "}" (. prop.Terminate(t); .)
      )
    | (. 
         IndexerDeclaration ind = new IndexerDeclaration(t, ifd);
         CurrentElement =ind;
         ind.SetModifiers(m.Value);
         ind.AssignAttributes(attrs);
         ind.Name = "";
         ind.ResultingType = typeRef;
      .)
      "this" "[" [ FormalParameterList<ind.FormalParameters> ] "]" 
      "{" InterfaceAccessors<ind> "}" (. ind.Terminate(t); .)
    )
  | InterfaceEventDeclaration<attrs, m, ifd>
  ) 
.

// ------------------------------------------------------------------------------------
// Declaration of an interface event member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +idf: declaration representing the interface type.
// ------------------------------------------------------------------------------------
InterfaceEventDeclaration<AttributeCollection attrs, Modifiers m, InterfaceDeclaration ifd>
          (. TypeReference typeRef; .)
=
  "event" 
  (. TypeOrNamespaceNode typeNode; .)
  Type<out typeRef, false, out typeNode> 
  ident (. 
           FieldDeclaration fd = new FieldDeclaration(t, ifd); 
           CurrentElement = fd;
           fd.SetModifiers(m.Value);
           fd.AssignAttributes(attrs);
           fd.ResultingType = typeRef;
           fd.Name = t.val;
           fd.IsEvent = true;
        .)
  ";"   (. 
           ifd.AddMember(fd); 
           fd.Terminate(t);
        .)
.

// ------------------------------------------------------------------------------------
// Declares a local variable within a block.
// +block: Block the variable is declared within.
// ------------------------------------------------------------------------------------
LocalVariableDeclaration<IBlockOwner block> (. 
                                               TypeReference typeRef = null; 
                                               bool isImplicit = false; 
                                            .)
=
  (
    (. TypeOrNamespaceNode typeNode; .)
    Type<out typeRef, false, out typeNode>
    | "var"                   (. isImplicit = true; .)
  )
  LocalVariableDeclarator<block, typeRef, isImplicit>
  { "," LocalVariableDeclarator<block, typeRef, isImplicit> }
.

// ------------------------------------------------------------------------------------
// Declares a local variable within a block with the specified type.
// +block: Block the variable is declared within.
// +typeRef: Type of the variable to declare.
// +isImplicit: Indicates if the local declaration is implicit or not.
// ------------------------------------------------------------------------------------
LocalVariableDeclarator<IBlockOwner block, TypeReference typeRef, bool isImplicit>
        (. ExpressionNode exprNode; .)
= 
  ident (. LocalVariableDeclaration loc = new LocalVariableDeclaration(t, this, block); .)
        (. CurrentElement = loc; .)
        (. loc.Name = t.val; .)
        (. loc.Variable.ResultingType = typeRef; .)
        (. loc.Variable.IsImplicit = isImplicit; .)
        (. if (block != null) block.Statements.Add(loc); .)       
  [
    "=" 
    (   (. Initializer init; .)
      VariableInitializer<out init> (. loc.Variable.Initializer = init; .)
      | "stackalloc" 
        (. StackAllocInitializer saIn = new StackAllocInitializer(t, this); .)
        (. loc.Variable.Initializer = saIn; .)
        (. TypeReference tr; .)
      (. TypeOrNamespaceNode typeNode; .)
      Type<out tr, false, out typeNode> 
        (. saIn.Type = tr; .)
        (. Expression expr; .)
      "[" 
        Expression<out expr, out exprNode> 
        (. saIn.Expression = expr; .)
      "]" (. saIn.Terminate(t); .)
    )
  ]
        (. 
           block.Add(loc.Variable); 
           loc.Terminate(t);
        .)
. 

// ------------------------------------------------------------------------------------
// Creates an initializer.
// +init: Initializer created.
// ------------------------------------------------------------------------------------
VariableInitializer<out Initializer init> 
                        (. 
                            Expression expr; init = null; 
                            // :::
                            ExpressionNode exprNode;
                        .)
= 
  Expression<out expr, out exprNode>  
                        (. ExpressionInitializer expIn = new ExpressionInitializer(t, this, expr); .)
                        (. init = expIn; expIn.Terminate(t); .)
  |                     (. ArrayInitializer arrInit; .)
    ArrayInitializer<out arrInit> (. init = arrInit; .)
.

// ------------------------------------------------------------------------------------
// Creates an array initializer.
// +init: Initializer created.
// ------------------------------------------------------------------------------------
ArrayInitializer<out ArrayInitializer init> (. init = new ArrayInitializer(t, this); .)
= (. Initializer arrayInit = null; .)
  "{" [ 
  VariableInitializer<out arrayInit> (. init.Initializers.Add(arrayInit); .)
  {IF (NotFinalComma()) ","
  VariableInitializer<out arrayInit> (. init.Initializers.Add(arrayInit); .)
  } [ "," ] ] "}" (. init.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Declaration of a formal parameter list
// +pars List holding the formal parameter declarations.
// ------------------------------------------------------------------------------------
FormalParameterList<FormalParameterCollection pars>                                                  
=                                      (. 
                                          TypeReference typeRef = null; 
                                          AttributeCollection attrs = new AttributeCollection();
                                          // :::
                                          ExpressionNode exprNode;
                                          var attrNodes = new AttributeDecorationNodeCollection();
                                       .)
  AttributeDecorations<attrs, attrNodes>                                       
                                       (. 
                                          FormalParameter fp = new FormalParameter(t, this); 
                                          fp.AssignAttributes(attrs);
                                       .)
  (                                    
    [ 
      "ref"                            (. fp.Kind = FormalParameterKind.Ref; .) 
      | "out"                          (. fp.Kind = FormalParameterKind.Out; .)
      | "this"                         (. fp.Kind = FormalParameterKind.This; .)
    ] 
    (. TypeOrNamespaceNode typeNode; .)
    Type<out typeRef, false, out typeNode>
                                       (. fp.Type = typeRef; .)
    ident                              (. 
                                          fp.Name = t.val; 
                                          fp.Type = typeRef;
                                          pars.Add(fp);
                                          fp.Terminate(t);
                                       .)
    [ "," FormalParameterList<pars> ]
  | "params" 
    (. fp.HasParams = true; .)
    (. TypeOrNamespaceNode typeNode; .)
    Type<out typeRef, false, out typeNode>
                                       (. if (!typeRef.IsArray) { Error("UNDEF", la, "params argument must be an array"); } .)
    ident                              (. fp.Name = t.val; .)
                                       (. fp.Type = typeRef; .)
                                       (. 
                                          pars.Add(fp); 
                                          fp.Terminate(t);
                                       .)
  )
.

Argument<ArgumentList argList> 
              (. 
                  Argument arg = new Argument(t, this); 
                  ExpressionNode exprNode;
              .)
= 
  [           
    "ref"     (. arg.Kind = FormalParameterKind.Ref; .)
    | "out"   (. arg.Kind = FormalParameterKind.Out; .)
  ]           (. Expression expr; .)
  Expression<out expr, out exprNode>
              (. arg.Expression = expr; .)
              (. 
                 if (argList != null) argList.Add(arg); 
                 arg.Terminate(t);
              .)
.

// ------------------------------------------------------------------------------------
// Declaration of a property accessors.
// +prop: property holding the accessor.
// ------------------------------------------------------------------------------------
AccessorDeclarations<PropertyDeclaration prop>                                    
                               (. 
                                   AttributeCollection attrs = new AttributeCollection();
                                   AccessorDeclaration accessor = null;
                                   // :::
                                   var attrNodes = new AttributeDecorationNodeCollection();
                               .)
= 
  AttributeDecorations<attrs, attrNodes>
                               (. 
                                   Modifiers am = new Modifiers(this); 
                                   // :::
                                   var mod = new ModifierNodeCollection();
                               .)
  ModifierList<am, mod>                    
  ( IF ("get".Equals(la.val)) ident   (. accessor = prop.Getter = new AccessorDeclaration(t, prop.DeclaringType, prop); .)
                                      (. CurrentElement = accessor; .)
  | IF ("set".Equals(la.val)) ident   (. accessor = prop.Getter = new AccessorDeclaration(t, prop.DeclaringType, prop); .)
                                      (. CurrentElement = accessor; .)
  | ident                             (. Error("UNDEF", la, "set or get expected"); .)
  ) 
  (
    Block<accessor>                   (. accessor.HasBody = true; .)
  | ";"                               (. accessor.HasBody = false; .)
  )                                   (. 
                                         accessor.Terminate(t);
                                         accessor.SetModifiers(am.Value); 
                                         accessor.AssignAttributes(attrs);
                                      .)
  [                                   (. 
                                          attrs = new AttributeCollection(); 
                                          attrNodes = new AttributeDecorationNodeCollection();
                                      .)
    AttributeDecorations<attrs, attrNodes>
                               (. 
                                   am = new Modifiers(this); 
                                   mod = new ModifierNodeCollection();
                               .)
    ModifierList<am, mod>                  
    ( IF ("get".Equals(la.val)) ident (. 
                                         if (prop.HasGetter) Error("UNDEF", la, "get already declared");  
                                         accessor = prop.Getter = new AccessorDeclaration(t, prop.DeclaringType, prop);
                                         CurrentElement = accessor;
                                      .)
    | IF ("set".Equals(la.val)) ident (. 
                                         if (prop.HasSetter) Error("UNDEF", la, "set already declared");  
                                         accessor = prop.Setter = new AccessorDeclaration(t, prop.DeclaringType, prop);
                                         CurrentElement = accessor;
                                      .)
    | ident                           (. Error("UNDEF", la, "set or get expected"); .)
    ) 
    (
      Block<accessor>                 (. accessor.HasBody = true; .)
    | ";"                             (. accessor.HasBody = false; .)
    )                                 (. 
                                         accessor.Terminate(t);
                                         accessor.SetModifiers(am.Value); 
                                         accessor.AssignAttributes(attrs);
                                      .)
  ]
.

// ------------------------------------------------------------------------------------
// Declaration of an event property accessors.
// +prop: event property holding the accessor.
// ------------------------------------------------------------------------------------
EventAccessorDeclarations<EventPropertyDeclaration prop>                                                 
                               (. 
                                   AttributeCollection attrs = new AttributeCollection();
                                   AccessorDeclaration accessor = null;
                                   // :::
                                   var attrNodes = new AttributeDecorationNodeCollection();
                               .)
= 
  AttributeDecorations<attrs, attrNodes>
                               (. 
                                   Modifiers am = new Modifiers(this); 
                                   // :::
                                   var mod = new ModifierNodeCollection();
                               .)
  ModifierList<am, mod>                    
  ( IF ("add".Equals(la.val)) ident       (. accessor = prop.Adder = new AccessorDeclaration(t, prop.DeclaringType, prop); .)
                                          (. CurrentElement = accessor; .)
  | IF ("remove".Equals(la.val)) ident    (. accessor = prop.Remover = new AccessorDeclaration(t, prop.DeclaringType, prop); .)
                                          (. CurrentElement = accessor; .)
  | ident                                 (. Error("UNDEF", la, "add or remove expected"); .)
  ) 
  Block<accessor>                         (. 
                                             accessor.Terminate(t);
                                             accessor.HasBody = true;
                                             accessor.SetModifiers(am.Value); 
                                             accessor.AssignAttributes(attrs); 
                                          .)
  [                                       (. 
                                              attrs = new AttributeCollection(); 
                                              attrNodes = new AttributeDecorationNodeCollection();
                                          .)
    AttributeDecorations<attrs, attrNodes>
                               (. 
                                   am = new Modifiers(this); 
                                   // :::
                                   mod = new ModifierNodeCollection();
                               .)
    ModifierList<am, mod>                      
    ( IF ("add".Equals(la.val)) ident     (. 
                                             if (prop.HasAdder) Error("UNDEF", la, "add already declared");  
                                             accessor = prop.Adder = new AccessorDeclaration(t, prop.DeclaringType, prop);
                                             CurrentElement = accessor;
                                          .)
    | IF ("remove".Equals(la.val)) ident  (. 
                                             if (prop.HasRemover) Error("UNDEF", la, "set already declared");  
                                             accessor = prop.Remover = new AccessorDeclaration(t, prop.DeclaringType, prop);
                                             CurrentElement = accessor;
                                          .)
    | ident                               (. Error("UNDEF", la, "add or remove expected"); .)
    ) 
    Block<accessor>                       (. 
                                             accessor.Terminate(t);
                                             accessor.HasBody = true;
                                             accessor.SetModifiers(am.Value); 
                                             accessor.AssignAttributes(attrs); 
                                          .)
  ]
.

// ------------------------------------------------------------------------------------
// Declaration of an interface accessors.
// +prop: event property holding the accessor.
// ------------------------------------------------------------------------------------
InterfaceAccessors<PropertyDeclaration prop>
                               (. 
                                   AttributeCollection attrs = new AttributeCollection();
                                   AccessorDeclaration accessor = null;
                                   // :::
                                   var attrNodes = new AttributeDecorationNodeCollection();
                               .)
= 
  AttributeDecorations<attrs, attrNodes>
                               (. 
                                   Modifiers am = new Modifiers(this); 
                                   var mod = new ModifierNodeCollection();
                               .)
  ModifierList<am, mod>                    
  ( IF ("get".Equals(la.val)) ident     (. accessor = prop.Getter = new AccessorDeclaration(t, prop.DeclaringType, prop); .)
                                        (. CurrentElement = accessor; .)
  | IF ("set".Equals(la.val)) ident     (. accessor = prop.Setter = new AccessorDeclaration(t, prop.DeclaringType, prop); .)
                                        (. CurrentElement = accessor; .)
  | ident                               (. Error("UNDEF", la, "set or get expected"); .)
  ) ";"                                 (. 
                                           accessor.Terminate(t);
                                           accessor.SetModifiers(am.Value); 
                                           accessor.AssignAttributes(attrs); 
                                        .)
  [                                     (. 
                                            attrs = new AttributeCollection(); 
                                            attrNodes = new AttributeDecorationNodeCollection();
                                        .)
    AttributeDecorations<attrs, attrNodes>
                               (. 
                                   am = new Modifiers(this); 
                                   mod = new ModifierNodeCollection();
                               .)
    ModifierList<am, mod>                    
    ( IF ("get".Equals(la.val)) ident   (. 
                                           if (prop.HasGetter) Error("UNDEF", la, "get already declared");  
                                           accessor = prop.Getter = new AccessorDeclaration(t, prop.DeclaringType, prop);
                                           CurrentElement = accessor;
                                        .)
    | IF ("set".Equals(la.val)) ident   (. 
                                           if (prop.HasSetter) Error("UNDEF", la, "set already declared");  
                                           accessor = prop.Setter = new AccessorDeclaration(t, prop.DeclaringType, prop);
                                           CurrentElement = accessor;
                                        .)
    | ident                             (. Error("UNDEF", la, "set or get expected"); .)
    ) ";"                               (. 
                                           accessor.Terminate(t);
                                           accessor.SetModifiers(am.Value); 
                                           accessor.AssignAttributes(attrs); 
                                        .)
  ]
.

// ------------------------------------------------------------------------------------------------
// Declaration of attributes.
//   attrs: List holding the attribute declarations.
//   attrNode: Syntax node holding the attribute declarations.
// ------------------------------------------------------------------------------------------------
Attributes<AttributeCollection attrs, out AttributeDecorationNode attrNode>
  (. 
     string scope = ""; 
     attrNode = null;
     AttributeNode attributeNode;
  .)
=
  "["
  (. attrNode = new AttributeDecorationNode(t); .)
  [ IF (IsAttrTargSpec()) 
    ( ident | Keyword )       
    (.  
       scope = t.val; 
       // :::
       attrNode.IdentifierToken = t;
    .)
    ":"
    (.  attrNode.ColonToken = t; .)
                               
  ] 
  (. AttributeDeclaration attr; .)
  Attribute<out attr, out attributeNode>
  (. 
     attr.Scope = scope;
     attrs.Add(attr);
     // :::
     attrNode.Attributes.Add(attributeNode);
  .)
  { 
    IF (la.kind == _comma && Peek(1).kind != _rbrack) 
    ","
    (.  var separator = t; .)
    Attribute<out attr, out attributeNode>
    (. 
       attr.Scope = scope;
       attrs.Add(attr);
       // :::
       attrNode.Attributes.Add(new AttributeContinuationNode(separator, attributeNode));
    .)
  } 
  [ 
    ","
    (. attrNode.ClosingSeparator = t; .)
  ] 
  "]"                          
  (.
     attr.Terminate(t);
     // :::
     attrNode.Terminate(t);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of attributes.
//   attrs: List holding the attribute declarations.
//   attrNodes: List of attribute decoration nodes.
// ------------------------------------------------------------------------------------------------
AttributeDecorations<AttributeCollection attrs, AttributeDecorationNodeCollection attrNodes>
  (.  AttributeDecorationNode attrNode; .)
=
  {
    Attributes<attrs, out attrNode>
    (. attrNodes.Add(attrNode); .)
  }
.

// ------------------------------------------------------------------------------------------------
// Declarations tokens that function as keywords.
// ------------------------------------------------------------------------------------------------
Keyword
=
  "abstract" | "as" | "base" | "bool" | "break" | "byte" | "case" | "catch"
  | "char" | "checked" | "class" | "const" | "continue" | "decimal" | "default"
  | "delegate" | "do" | "double" | "else" | "enum" | "event" | "explicit"
  | "extern" | "false" | "finally" | "fixed" | "float" | "for" | "foreach"
  | "goto" | "if" | "implicit" | "in" | "int" | "interface" | "internal" | "is"
  | "lock" | "long" | "namespace" | "new" | "null" | "object" | "operator"
  | "out" | "override" | "params" | "private" | "protected" | "public"
  | "readonly" | "ref" | "return" | "sbyte" | "sealed" | "short" | "sizeof"
  | "stackalloc" | "static" | "string" | "struct" | "switch" | "this" | "throw"
  | "true" | "try" | "typeof" | "uint" | "ulong" | "unchecked" | "unsafe"
  | "ushort" | "using" | "virtual" | "void" | "volatile" | "while"
.

// ------------------------------------------------------------------------------------------------
// Declaration of an attribute.
//   attr: Attribute declaration.
//   attrNode: Attribute declaration syntax node.
// ------------------------------------------------------------------------------------------------
Attribute<out AttributeDeclaration attr, out AttributeNode attrNode> 
  (. 
     TypeReference typeRef; 
     // :::
     attrNode = new AttributeNode(t);
     TypeOrNamespaceNode nsNode = null;
  .)
= 
  TypeName<out typeRef, out nsNode>      
  (. 
     attr = new AttributeDeclaration(t, this, typeRef); 
     CurrentElement = attr;
     attrNode.TypeName = nsNode;
  .)
  [ 
    AttributeArguments<attr, attrNode>
  ]
  (. attr.Terminate(t); .)
.

// ------------------------------------------------------------------------------------------------
// Declares the list of attribute arguments.
//   attr: Attribute declaration.
//   attrNode: Attribute declaration syntax node.
// ------------------------------------------------------------------------------------------------
AttributeArguments<AttributeDeclaration attr, AttributeNode argsNode> 
  (.  
     AttributeArgument arg; 
     Token identifier = null;
     Token equal = null;
     ExpressionNode exprNode;
     bool nameFound = false;
  .)
=                           
  "("                          
  (.  argsNode.OpenParenthesis = t; .)
    [                          
      (.  arg = new AttributeArgument(t, this); .)
      [ IF (IsAssignment()) ident
        (.  
           arg.Name = t.val;
           // :::
           identifier = t;
        .)
        "="
        (. 
           nameFound = true; 
           // :::
           equal = t;
        .)
      ]
      (.  Expression expr; .)
      Expression<out expr, out exprNode>           
      (. 
         arg.Expression = expr;
         attr.Arguments.Add(arg); 
         arg.Terminate(t);
         // :::
         var argNode = new AttributeArgumentNode(identifier, equal, exprNode); 
         argNode.Terminate(t);
         argsNode.Arguments.Add(argNode);
      .)
      { 
        ","
        (. 
           arg = new AttributeArgument(t, this); 
           // :::
           var separator = t;
        .)
        ( IF (IsAssignment()) ident
          (. 
             arg.Name = t.val; 
             // :::
             identifier = t;
          .)
          "="
          (.  
             nameFound = true; 
             // :::
             equal = t;
          .)
        |                    
          (.  if (nameFound) Error("UNDEF", la, "no positional argument after named arguments"); .)
        ) 
        Expression<out expr, out exprNode> 
        (.  
           arg.Expression = expr; 
           attr.Arguments.Add(arg); 
           arg.Terminate(t);
           // :::
           var argcNode = new AttributeArgumentContinuationNode(separator, identifier, equal, exprNode); 
           argcNode.Terminate(t);
           argsNode.Arguments.Add(argcNode);
        .)
      }
    ]
  ")"   
  (. argsNode.Terminate(t); .)
.

// ------------------------------------------------------------------------------------------------
// Modifiers that can be assigned to types and members.
//   m: List of modifier flags.
//   mods: List of modifier flags.
// ------------------------------------------------------------------------------------------------
ModifierList<Modifiers m, ModifierNodeCollection mods>
=
{
  (
      "new"                          (. m.Add(Modifier.@new, t); .)
    | "public"                       (. m.Add(Modifier.@public, t); .)
    | "protected"                    (. m.Add(Modifier.@protected, t); .)
    | "internal"                     (. m.Add(Modifier.@internal, t); .)
    | "private"                      (. m.Add(Modifier.@private, t); .)
    | "unsafe"                       (. m.Add(Modifier.@unsafe, t); .)
    | "static"                       (. m.Add(Modifier.@static, t); .)
    | "readonly"                     (. m.Add(Modifier.@readonly, t); .)
    | "volatile"                     (. m.Add(Modifier.@volatile, t); .)
    | "virtual"                      (. m.Add(Modifier.@virtual, t); .)
    | "sealed"                       (. m.Add(Modifier.@sealed, t); .)
    | "override"                     (. m.Add(Modifier.@override, t); .)
    | "abstract"                     (. m.Add(Modifier.@abstract, t); .)
    | "extern"                       (. m.Add(Modifier.@extern, t); .)
  )                                  (. mods.Add(t); .)
}
.

// ------------------------------------------------------------------------------------------------
// Reference for a type
//   typeRef: Type reference
//   voidAllowed: indicates if "void" is an acceptable type or not.
//   typeNode: Type reference syntax node
// ------------------------------------------------------------------------------------------------
Type<out TypeReference typeRef, bool voidAllowed, out TypeOrNamespaceNode typeNode>    
  (. 
     typeRef = null;
     // :::
     typeNode = null;
  .)      
=                                                    
  ( 
     PrimitiveType<out typeRef, out typeNode>
  |  ClassType<out typeRef, out typeNode>                                               
  |  "void"                                           
     (. 
        typeRef = new TypeReference(t, this); 
        typeRef.Name = t.val;
        typeRef.IsVoid = true; 
        // :::
        typeNode = TypeOrNamespaceNode.CreateTypeNode(t);
     .)
  )
  [ 
    "?"                                              
    (. 
       typeRef.IsNullable = true; 
       // :::
       typeNode.NullableToken = t;
    .)                                              
  ]
  PointerOrArray<typeRef, typeNode>
  (. 
     CompilationUnit.AddTypeToFix(typeRef);
     typeRef.Terminate(t); 
  .)
.

// ------------------------------------------------------------------------------------
// Reference for a type
// +typeRef: type reference
// +voidAllowed: indicates if "void" is an acceptable type or not.
// ------------------------------------------------------------------------------------
NonArrayType<out TypeReference typeRef, out TypeOrNamespaceNode typeNode>    
  (. 
     typeRef = null;
     // :::
     typeNode = null;
  .)      
=                                                    
  ( 
    PrimitiveType<out typeRef, out typeNode>
  | 
    ClassType<out typeRef, out typeNode>
  )
  [ 
    "?"
    (. 
       typeRef.IsNullable = true;
       // :::
       typeNode.NullableToken = t;
    .)                                              
  ]
  [
    "*"                         
    (. 
       typeRef.TypeModifiers.Add(new PointerModifier());
       CompilationUnit.AddTypeToFix(typeRef); 
       // :::
       typeNode.TypeModifiers.Add(new PointerModifierNode(t));
    .)
  ]
  (. 
     typeRef.Terminate(t); 
     // :::
     typeNode.Terminate(t);
  .)
.

// ------------------------------------------------------------------------------------
// Reference for a type in a relational expression
// +typeRef: type reference
// +voidAllowed: indicates if "void" is an acceptable type or not.
// ------------------------------------------------------------------------------------
TypeInRelExpr<out TypeReference typeRef, bool voidAllowed>    
  (. 
     typeRef = null;
     // :::
     TypeOrNamespaceNode typeNode = null; 
  .)      
=                                                    
  ( PrimitiveType<out typeRef, out typeNode>
  | ClassType<out typeRef, out typeNode>                                               
  | "void"                                           (. 
                                                        typeRef = new TypeReference(t, this); 
                                                        typeRef.Name = t.val;
                                                        typeRef.IsVoid = true; 
                                                     .)
  )
  [ IF (IsNullableTypeMark())
    "?"                                              
  ]
  PointerOrArray<typeRef, typeNode>
  (. 
     CompilationUnit.AddTypeToFix(typeRef);
     typeRef.Terminate(t); 
  .)
.

// ------------------------------------------------------------------------------------------------
// Sets the appropriate flags of a type reference if the declaration shows it is
// a pointer or array.
//   typeRef: Type reference.
//   typeNode: Type reference node.
// ------------------------------------------------------------------------------------------------
PointerOrArray<TypeReference typeRef, TypeOrNamespaceNode typeNode>
=
  { IF (IsPointerOrDims())
    ( 
      "*"
      (. 
         typeRef.TypeModifiers.Add(new PointerModifier());
         // :::
         if (typeNode != null) typeNode.TypeModifiers.Add(new PointerModifierNode(t)); 
      .)  
    | 
      "["                     
      (. 
         int rank = 1; 
         // :::
         var arrNode = new ArrayModifierNode(t);
      .)
      { 
        ","                 
        (. 
           rank++; 
           // :::
           arrNode.AddSeparator(t);
        .)
      } 
      "]"                     
      (. 
         typeRef.TypeModifiers.Add(new ArrayModifier(rank)); 
         // :::
         arrNode.Terminate(t);
      .)
    )
  }
.

// ------------------------------------------------------------------------------------
// Types that are taken into account as primitive types.
// ------------------------------------------------------------------------------------
PredefinedType<out TypeReference typeRef> (. typeRef = null; .)
=
  (. TypeOrNamespaceNode typeNode; .)
  PrimitiveType<out typeRef, out typeNode> | 
  (                                    
    "object"                           (. typeRef = new TypeReference(t, this, typeof(object)); .)
    | "string"                         (. typeRef = new TypeReference(t, this, typeof(string)); .)
  )                                    (. typeRef.Terminate(t); .)                                 
.

// ------------------------------------------------------------------------------------------------
// Types that are taken into account as primitive types.
//   typeRef: Type reference.
//   typeNode: Type reference node.
// ------------------------------------------------------------------------------------------------
PrimitiveType<out TypeReference typeRef, out TypeOrNamespaceNode typeNode> 
  (. 
     typeRef = null; 
     // :::
     typeNode = null;
  .)
=
  IntegralType<out typeRef, out typeNode> | 
  (
    "float"       
    (. typeRef = new TypeReference(t, this, typeof(float)); .)    
  | "double"    
    (. typeRef = new TypeReference(t, this, typeof(double)); .) 
  | "decimal" 
    (. typeRef = new TypeReference(t, this, typeof(decimal)); .)
  | "bool"    
    (. typeRef = new TypeReference(t, this, typeof(bool)); .)
  )
  (. 
     typeRef.Terminate(t); 
     // :::
     typeNode = TypeOrNamespaceNode.CreateTypeNode(t);
  .)
.

// ------------------------------------------------------------------------------------------------
// Types that are taken into account as integral types.
//   typeRef: Type reference.
//   typeNode: Type reference node.
// ------------------------------------------------------------------------------------------------
IntegralType<out TypeReference typeRef, out TypeOrNamespaceNode typeNode> 
  (. typeRef = null; .)
= (
    "sbyte"       
    (. typeRef = new TypeReference(t, this, typeof(sbyte)); .)
  | "byte"
    (. typeRef = new TypeReference(t, this, typeof(byte)); .)
  | "short" 
    (. typeRef = new TypeReference(t, this, typeof(short)); .)
  | "ushort"
    (. typeRef = new TypeReference(t, this, typeof(ushort)); .)
  | "int"
    (. typeRef = new TypeReference(t, this, typeof(int)); .)
  | "uint"
    (. typeRef = new TypeReference(t, this, typeof(uint)); .)
  | "long"    
    (. typeRef = new TypeReference(t, this, typeof(long)); .)
  | "ulong"     
    (. typeRef = new TypeReference(t, this, typeof(ulong)); .)
  | "char"     
    (. typeRef = new TypeReference(t, this, typeof(char)); .)
  )               
  (. 
     typeRef.Terminate(t); 
     // :::
     typeNode = TypeOrNamespaceNode.CreateTypeNode(t);
  .)
.

// ------------------------------------------------------------------------------------------------
// Types that are taken into account as class types.
//   typeRef: Type reference.
//   typeNode: Type reference node.
// ------------------------------------------------------------------------------------------------
ClassType<out TypeReference typeRef, out TypeOrNamespaceNode typeNode>   
  (. 
     typeRef = null; 
     // ::: 
     typeNode = null;
  .)
=                                      
  TypeName<out typeRef, out typeNode> |               
  (                                    
    "object"                               
    (. typeRef = new TypeReference(t, this, typeof(object)); .)
    | "string"                         
    (. typeRef = new TypeReference(t, this, typeof(string)); .)
  )                                    
  (. 
     typeRef.Terminate(t); 
     // :::
     typeNode = TypeOrNamespaceNode.CreateTypeNode(t);
  .)                                 
.

// ------------------------------------------------------------------------------------
// Declaration of a compound member name
// +typeRef: An instance to a member reference
// ------------------------------------------------------------------------------------
MemberName<out TypeReference typeRef>                                              
=                                        (.
                                            // :::
                                            TypeArgumentListNode argList = null;
                                         .)
  ident                                  (. 
                                            typeRef = new TypeReference(t, this);
                                            typeRef.Name = t.val; 
                                            TypeReference nextType = typeRef;
                                         .)
  [ 
    "::"                                 (. typeRef.IsGlobalScope = true; .)
    ident                                (. 
                                            typeRef.Suffix = new TypeReference(t, this);
                                            typeRef.Suffix.Name = t.val; 
                                            nextType = typeRef.Suffix;
                                         .)
  ]
  [ 
    IF (la.kind == _lt && IsPartOfMemberName()) 
      TypeArgumentList<typeRef.Arguments, out argList> 
  ]
  { IF (la.kind == _dot && Peek(1).kind == _ident)
      "." ident                          (. 
                                            nextType.Suffix = new TypeReference(t, this);
                                            nextType.Suffix.Name = t.val;
                                            nextType = nextType.Suffix;
                                         .)
    [ 
      IF (la.kind == _lt && IsPartOfMemberName()) 
        TypeArgumentList<typeRef.Arguments, out argList>
    ]
  }
.

// ------------------------------------------------------------------------------------------------
// Declaration of a compound type name
//   typeRef: Type reference.
//   typeNode: Type reference node.
// ------------------------------------------------------------------------------------------------
TypeName<out TypeReference typeRef, out TypeOrNamespaceNode resultNode>                             
  (.
     // :::
     resultNode = null;
     Token qualifier = null;
     Token separator = null;
     Token identifier = null;
     TypeArgumentListNode argList = null;
  .)
=               
  ident
  (. 
     typeRef = new TypeReference(t, this);
     typeRef.Name = t.val; 
     TypeReference nextType = typeRef;
     // :::
     qualifier = t;
  .)
  [ 
    "::"
    (. 
       typeRef.IsGlobalScope = true; 
       // :::
       separator = t;
    .)
    ident
    (. 
       typeRef.Suffix = new TypeReference(t, this);
       typeRef.Suffix.Name = t.val; 
       nextType = typeRef.Suffix;
       // :::
       identifier = t;
    .)
  ]
  (.
     if (separator == null)
     {
       resultNode = new TypeOrNamespaceNode(qualifier);
       identifier = qualifier;
     }
     else
     {
       resultNode = new TypeOrNamespaceNode(qualifier, separator);
     }
  .)
  [ TypeArgumentList<nextType.Arguments, out argList> ]
  (.
     // :::
     resultNode.AddTypeTag(new TypeTagNode(identifier, argList));
  .)                                    
  {
    "."
    (.
       // :::
       separator = t;
       argList = null;
    .)
    ident 
    (. 
       nextType.Suffix = new TypeReference(t, this);
       nextType.Suffix.Name = t.val;
       nextType = nextType.Suffix;
       // :::
       identifier = t;
    .)
    [ TypeArgumentList<nextType.Arguments, out argList> ]   
    (.
       // :::
       resultNode.AddTypeTag(new TypeTagContinuationNode(separator, identifier, argList));
    .)                                    
  }
.

// ------------------------------------------------------------------------------------
// Defines a statement.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
Statement<IBlockOwner block>
= 
  IF (la.kind == _ident && Peek(1).kind == _colon) ident ":" Statement<block>
  | ConstStatement<block>
  | IF (IsLocalVarDecl()) LocalVariableDeclaration<block> ";"
  | EmbeddedStatement<block>
.

// ------------------------------------------------------------------------------------
// Defines statements that can be nested in other statements.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
EmbeddedStatement<IBlockOwner block> 
=   
    // --- Block nested into a statement
                    (. BlockStatement embedded = new BlockStatement(t, this, block); .)
    Block<embedded> (. if (block != null) block.Add(embedded); .)
  | EmptyStatement<block>
  | CheckedBlock<block>
  | UncheckedBlock<block>
  | UnsafeBlock<block>
  | StatementExpression<block> ";"
  | IfStatement<block>
  | SwitchStatement<block>
  | WhileStatement<block>
  | DoWhileStatement<block>
  | ForStatement<block>
  | ForEachStatement<block>
  | BreakStatement<block>
  | ContinueStatement<block>
  | GotoStatement<block>
  | ReturnStatement<block>
  | ThrowStatement<block>
  | TryFinallyBlock<block>
  | LockStatement<block>
  | UsingStatement<block>
  | "yield" ( YieldReturnStatement<block> | YieldBreakStatement<block> ) ";"
  | FixedStatement<block>
.

// ------------------------------------------------------------------------------------
// Defines a block of statements.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
Block<IBlockOwner block> (. CurrentElement = block.Owner as LanguageElement; .)
=
  "{" { Statement<block> } "}"
.


// ------------------------------------------------------------------------------------
// Defines a switch statement.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
SwitchStatement<IBlockOwner block>
                          (. ExpressionNode exprNode; .)
=
  "switch"                (. SwitchStatement sws = new SwitchStatement(t, this, block); .)
                          (. CurrentElement = sws; .)
  "("                     (. Expression expr; .)
  Expression<out expr, out exprNode>    
                          (. sws.Expression = expr; .)
  ")" "{" 
  { 
    SwitchSection<sws> 
  } 
  "}"                     (. 
                             if (block != null) block.Add(sws); 
                             sws.Terminate(t);
                          .)
.

// ------------------------------------------------------------------------------------
// Defines a constant statement.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
ConstStatement<IBlockOwner block>
                         (. ExpressionNode exprNode; .)
=
  "const"                (. TypeReference typeRef; .)
                         (. ConstStatement cs = new ConstStatement(t, this, block); .)
                         (. CurrentElement = cs; .)
  (. TypeOrNamespaceNode typeNode; .)
  Type<out typeRef, false, out typeNode> 
  ident                  (. cs.Name = t.val; .)
  "="                    (. Expression expr; .)
  Expression<out expr, out exprNode>   
                         (. cs.Expression = expr; .)
                         (. 
                            if (block != null) block.Add(cs); 
                            cs.Terminate(t);
                         .)
  { ","                  (. cs = new ConstStatement(t, this, block); .)
    ident                (. cs.Name = t.val; .)
    "=" 
    Expression<out expr, out exprNode> 
                         (. cs.Expression = expr; .)
                         (. 
                            if (block != null) block.Add(cs); 
                            cs.Terminate(t);
                         .)
  } ";".                 

// ------------------------------------------------------------------------------------
// Defines an empty statement (";").
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
EmptyStatement<IBlockOwner block>
=
  ";"     (. EmptyStatement es = new EmptyStatement(t, this, block); .)
          (. CurrentElement = es; .)
          (. if (block != null) block.Add(es); .)
.

// ------------------------------------------------------------------------------------
// Defines a "checked" block
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
CheckedBlock<IBlockOwner block>
=
  (
    IF (la.kind == _checked && Peek(1).kind == _lbrace) 
      "checked" (. 
                   CheckedBlock cb = new CheckedBlock(t, this, block);
                   CurrentElement = cb;
                   if (block != null) block.Add(cb);
                .)
    Block<cb>   (. cb.Terminate(t); .)
  )
.

// ------------------------------------------------------------------------------------
// Defines an "unchecked" block
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
UncheckedBlock<IBlockOwner block>
=
  (
    IF (la.kind == _unchecked && Peek(1).kind == _lbrace) 
    "unchecked" (. 
                   UncheckedBlock ucb = new UncheckedBlock(t, this, block);
                   CurrentElement = ucb;
                   if (block != null) block.Add(ucb);
                .)
    Block<ucb>  (. ucb.Terminate(t); .)
  )
.

// ------------------------------------------------------------------------------------
// Defines an "unsafe" block
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
UnsafeBlock<IBlockOwner block>
=
  "unsafe" (. 
              UnsafeBlock usb = new UnsafeBlock(t, this, block);
              CurrentElement = usb;
              if (block != null) block.Add(usb);
           .)
  Block<usb> (. usb.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Defines an "if" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
IfStatement<IBlockOwner block>
                         (. ExpressionNode exprNode; .)
=   
  "if"                   (. IfStatement ifs = new IfStatement(t, this, block); .)
                         (. CurrentElement = ifs; .)
  "("                    (. if (block != null) block.Add(ifs); .)
                         (. Expression expr; .)
    Expression<out expr, out exprNode> 
                         (. ifs.Condition = expr; .)
  ")"                    (. ifs.CreateThenBlock(t); .)
  EmbeddedStatement<ifs.ThenStatements> (. ifs.ThenStatements.Terminate(t); .)
  [ "else"               (. ifs.CreateElseBlock(t); .)
    EmbeddedStatement<ifs.ElseStatements> (. ifs.ElseStatements.Terminate(t); .)
  ]                      (. ifs.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Defines a "while" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
WhileStatement<IBlockOwner block>
                          (. ExpressionNode exprNode; .)
= 
  "while"                 (. WhileStatement whs = new WhileStatement(t, this, block); .)
                          (. CurrentElement = whs; .)
  "("                     (. if (block != null) block.Add(whs); .)
                          (. Expression expr; .)
    Expression<out expr, out exprNode>  
                          (. whs.Condition = expr; .)
  ")" 
  EmbeddedStatement<whs>  (. whs.Terminate(t); .)
.    

// ------------------------------------------------------------------------------------
// Defines a "do...while" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
DoWhileStatement<IBlockOwner block>
                            (. ExpressionNode exprNode; .)
=   
  "do"                      (. DoWhileStatement whs = new DoWhileStatement(t, this, block); .)
                            (. CurrentElement = whs; .)
    EmbeddedStatement<whs>  (. if (block != null) block.Add(whs); .)
  "while" 
  "("                       (. Expression expr; .)
    Expression<out expr, out exprNode>    
                            (. whs.Condition = expr; .)
  ")" ";"                   (. whs.Terminate(t); .)
.    

// ------------------------------------------------------------------------------------
// Defines a "for" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
ForStatement<IBlockOwner block>
                              (. ExpressionNode exprNode; .)
= 
  "for"                       (. ForStatement fs = new ForStatement(t, this, block); .)
                              (. CurrentElement = fs; .)
  "("                         (. if (block != null) block.Add(fs); .)
    [                         (. fs.CreateInitializerBlock(t); .)
      ForInitializer<fs>
    ] ";" 
    [                         (. Expression expr; .)
      Expression<out expr, out exprNode>    
                              (. fs.Condition = expr; .)
    ] ";" 
    [ 
      ForIterator<fs>         (. fs.CreateIteratorBlock(t); .)
    ] 
  ")"
  EmbeddedStatement<fs>       (. fs.Terminate(t); .)
.    

// ------------------------------------------------------------------------------------
// Defines a "foreach" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
ForEachStatement<IBlockOwner block>
                                (. ExpressionNode exprNode; .)
=
  "foreach"                     (. ForEachStatement fes = new ForEachStatement(t, this, block); .)
                                (. CurrentElement = fes; .)
  "("                           (. if (block != null) block.Add(fes); .)
                                (. TypeReference typeRef; .)
    (         
      (. TypeOrNamespaceNode typeNode; .)
      Type<out typeRef, false, out typeNode>
                                (. fes.Variable.ResultingType = typeRef; .)
      | "var"                   (. fes.Variable.IsImplicit = true; .)
    )
    ident                       (. fes.Variable.Name = t.val; .)
    "in"                        (. Expression expr; .)
    Expression<out expr, out exprNode>
                                (. fes.Expression = expr; .)
  ")"                           (. fes.Add(fes.Variable); .)
  EmbeddedStatement<fes>        (. fes.Terminate(t); .)
.    

// ------------------------------------------------------------------------------------
// Defines a "break" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
BreakStatement<IBlockOwner block>
=
  "break" ";" (. BreakStatement bs = new BreakStatement(t, this, block); .)
              (. CurrentElement = bs; .)
              (. if (block != null) block.Add(bs); .)
              (. bs.Terminate(t); .)
.    

// ------------------------------------------------------------------------------------
// Defines a "goto" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
GotoStatement<IBlockOwner block>
                          (. ExpressionNode exprNode; .)
=
  "goto"                  (. GotoStatement gs = new GotoStatement(t, this, block); .)
                          (. CurrentElement = gs; .)
                          (. if (block != null) block.Add(gs); .)
  ( 
    ident                 (. gs.Name = t.val; .)
  | 
    "case"                (. Expression expr; .)
    Expression<out expr, out exprNode>  
                          (. gs.LabelExpression = expr; .)
  | 
    "default"             (. gs.Name = t.val; .)
  ) ";"                   (. gs.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Defines a "continue" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
ContinueStatement<IBlockOwner block>
=
  "continue" ";"  (. ContinueStatement cs = new ContinueStatement(t, this, block); .)
                  (. CurrentElement = cs; .)
                  (. if (block != null) block.Add(cs); .)
                  (. cs.Terminate(t); .)
.    

// ------------------------------------------------------------------------------------
// Defines a "try...catch...finally" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
TryFinallyBlock<IBlockOwner block>
=
  "try"         (. 
                   TryStatement ts = new TryStatement(t, this, block); 
                   CurrentElement = ts;
                   ts.CreateTryBlock(t);
                   if (block != null) block.Add(ts);
                .)
  Block<ts.TryBlock> 
  ( 
    CatchClauses<ts>
    [ 
      "finally" (. ts.CreateFinallyBlock(t); .) 
      Block<ts.FinallyBlock> (. ts.FinallyBlock.Terminate(t); .)
    ] 
  | "finally" (. ts.CreateFinallyBlock(t); .) 
    Block<ts.FinallyBlock>   (. ts.FinallyBlock.Terminate(t); .)
  )                          (. ts.Terminate(t); .) 
.    

// ------------------------------------------------------------------------------------
// Defines a "lock" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
LockStatement<IBlockOwner block>
                          (. ExpressionNode exprNode; .)
=   
  "lock"                  (. LockStatement ls = new LockStatement(t, this, block); .)
                          (. CurrentElement = ls; .)
                          (. if (block != null) block.Add(ls); .)
  "("                     (. Expression expr; .)
    Expression<out expr, out exprNode>  
                          (. ls.Expression = expr; .)
  ")" 
  EmbeddedStatement<ls>   (. ls.Terminate(t); .)
.    

// ------------------------------------------------------------------------------------
// Defines a "using" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
UsingStatement<IBlockOwner block>
          (. ExpressionNode exprNode; .)
=
  "using" (. 
              UsingStatement us = new UsingStatement(t, this, block);
              CurrentElement = us;
              if (block != null) block.Add(us);
           .)
  "(" 
  (
    IF (IsLocalVarDecl()) LocalVariableDeclaration<us>  
  |                             (. Expression expr; .)
    Expression<out expr, out exprNode>        
                                (. us.ResourceExpression = expr; .)
  ) 
  ")" 
  EmbeddedStatement<us>         (. us.Terminate(t); .)
.    

// ------------------------------------------------------------------------------------
// Defines a "return" statement.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
ReturnStatement<IBlockOwner block>
                           (. ExpressionNode exprNode; .)
=
  "return"                 (. ReturnStatement yrs = new ReturnStatement(t, this, block); .)
                           (. CurrentElement = yrs; .)
  [                        (. Expression expr; .)
  Expression<out expr, out exprNode>     
                           (. yrs.Expression = expr; .)
  ]
  ";"                      (. if (block != null) block.Add(yrs); .)
                           (. yrs.Terminate(t); .)
                           
.

// ------------------------------------------------------------------------------------
// Defines a "throw" statement.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
ThrowStatement<IBlockOwner block>
                          (. ExpressionNode exprNode; .)
=
  "throw"                 (. ThrowStatement ts = new ThrowStatement(t, this, block); .)
                          (. CurrentElement = ts; .)
  [                       (. Expression expr; .)
    Expression<out expr, out exprNode>
                          (. ts.Expression = expr; .)
  ] ";"                   (. if (block != null) block.Add(ts); .)
                          (. ts.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Defines a "yield return" statement.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
YieldReturnStatement<IBlockOwner block>
                           (. ExpressionNode exprNode; .)
=
  "return"                 (. Expression expr; .)
  Expression<out expr, out exprNode>
                           (. YieldReturnStatement yrs = new YieldReturnStatement(t, this, block); .)
                           (. CurrentElement = yrs; .)
                           (. yrs.Expression = expr; .)
                           (. if (block != null) block.Add(yrs); .)
                           (. yrs.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Defines a "yield break" statement.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
YieldBreakStatement<IBlockOwner block>
=
  "break"   (. YieldBreakStatement ybs = new YieldBreakStatement(t, this, block); .)
            (. CurrentElement = ybs; .) 
            (. if (block != null) block.Add(ybs); .)
            (. ybs.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Defines a "fixed" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
FixedStatement<IBlockOwner block>
                              (. ExpressionNode exprNode; .)
= 
  "fixed"                     (. FixedStatement fs = new FixedStatement(t, this, block); .)
                              (. CurrentElement = fs; .)
                              (. if (block != null) block.Add(fs); .)
  "("                         (. TypeReference typeRef; .)
          
    (. TypeOrNamespaceNode typeNode; .)
    Type<out typeRef, false, out typeNode>          
                              (. if (!typeRef.IsPointer) Error("UNDEF", la, "can only fix pointer types"); .)
                              (. ValueAssignmentStatement vas = new ValueAssignmentStatement(t, this, block); .)
                              (. CurrentElement = vas; .)
    ident                     (. vas.Name = t.val; .)
    "="                       (. Expression expr; .)
    Expression<out expr, out exprNode>
                              (. vas.Expression = expr; .)
                              (. fs.Assignments.Add(vas); .)
    { 
      ","                     (. vas = new ValueAssignmentStatement(t, this, block); .)
                              (. CurrentElement = vas; .)
      ident                   (. vas.Name = t.val; .)
      "=" 
      Expression<out expr, out exprNode>
                              (. vas.Expression = expr; .)
                              (. fs.Assignments.Add(vas); .)
    }
  ")" EmbeddedStatement<fs>   (. fs.Terminate(t); .)
.    

// ------------------------------------------------------------------------------------
// Defines a statement expression
// +operateor: Assignement operator 
// ------------------------------------------------------------------------------------
StatementExpression<IBlockOwner block>
  (. 
     ExpressionNode exprNode;
     bool isAssignment = assnStartOp[la.kind] || IsTypeCast(); 
     Expression expr = null; 
     ExpressionNode unaryNode;
  .)
=
  Unary<out expr, out unaryNode>
  (. ExpressionStatement es = new ExpressionStatement(t, this, block); .)
                                        (. CurrentElement = es; .)
                                        (. es.Expression = expr; .)
  ( (. AssignmentOperator asgn; .)
    AssignmentOperator<out asgn>        (. es.Expression = asgn; .)
                                        (. asgn.LeftOperand = expr; .)
                                        (. Expression rightExpr; .)
    Expression<out rightExpr, out exprNode>
                                        (. asgn.RightOperand = rightExpr; .)
  | (. if (isAssignment) Error("UNDEF", la, "error in assignment."); .)
  )                                     (. if (block != null) block.Add(es); .)
                                        (. es.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Defines assignment operators.
// +operateor: Assignement operator 
// ------------------------------------------------------------------------------------
AssignmentOperator<out AssignmentOperator op> (. op = null; .)
=
    "="     (. op = new AssignmentOperator(t, this); .)
  | "+="    (. op = new PlusAssignmentOperator(t, this); .)
  | "-="    (. op = new MinusAssignmentOperator(t, this); .)
  | "*="    (. op = new MultiplyAssignmentOperator(t, this); .)
  | "/="    (. op = new DivideAssignmentOperator(t, this); .)
  | "%="    (. op = new ModuloAssignmentOperator(t, this); .)
  | "&="    (. op = new AndAssignmentOperator(t, this); .)
  | "|="    (. op = new OrAssignmentOperator(t, this); .)
  | "^="    (. op = new XorAssignmentOperator(t, this); .)
  | "<<="   (. op = new LeftShiftAssignmentOperator(t, this); .)
  | ">"     (. int pos = t.pos; .)
    ">="    (. if (pos+1 < t.pos) Error("UNDEF", la, "no whitespace allowed in right shift assignment"); .)
            (. op = new RightShiftAssignmentOperator(t, this); .)
.

// ------------------------------------------------------------------------------------
// Represents a section of a switch statement.
// +expr: Label expression
// ------------------------------------------------------------------------------------
SwitchSection<SwitchStatement sws>
=                         (. 
                             SwitchSection section = sws.CreateSwitchSection(t);
                             CurrentElement = section;
                             Expression expr;
                          .)
  SwitchLabel<out expr>   (. 
                            if (expr == null) section.IsDefault = true; 
                             else section.Labels.Add(expr);
                          .)
  { 
    IF (la.kind == _case || (la.kind == _default && Peek(1).kind == _colon)) 
    SwitchLabel<out expr> (. 
                           if (expr == null) section.IsDefault = true; 
                           else section.Labels.Add(expr);
                          .)
  }
  Statement<section> 
  { 
    IF (IsNoSwitchLabelOrRBrace()) 
    Statement<section> 
  }                       (. sws.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Represents a label of a switch statement.
// +expr: Label expression
// ------------------------------------------------------------------------------------
SwitchLabel<out Expression expr> 
                 (. 
                    expr = null; 
                    ExpressionNode exprNode;
                 .)
= 
  "case" Expression<out expr, out exprNode> ":"
  | "default" ":"                 
.

// ------------------------------------------------------------------------------------
// Represents the initializer of a for statement.
// +fs: For statement owning the initializator.
// ------------------------------------------------------------------------------------
ForInitializer<ForStatement fs>
=
  IF (IsLocalVarDecl()) LocalVariableDeclaration<fs>
  | StatementExpression<fs.InitializerBlock> { "," StatementExpression<fs.InitializerBlock> }
.

// ------------------------------------------------------------------------------------
// Represents the iterator of a for statement.
// +fs: For statement owning the iterator.
// ------------------------------------------------------------------------------------
ForIterator<ForStatement fs>
=
  StatementExpression<fs.IteratorBlock> { "," StatementExpression<fs.IteratorBlock> }
.

// ------------------------------------------------------------------------------------
// Represents catch clauses in a try..catch..finally statement.
// +try: Statement owning the catch clauses.
// ------------------------------------------------------------------------------------
CatchClauses<TryStatement tryStm>
  (. TypeOrNamespaceNode typeNode; .)
=                                                     
  "catch"                   (. CatchClause cc = tryStm.CreateCatchClause(t); .)    
                            (. CurrentElement = cc; .)  
  (                         
    Block<cc>
  | 
    "("                     (. TypeReference typeRef; .)
    ClassType<out typeRef, out typeNode>  (. cc.ExceptionType = typeRef; .)
    [ 
      ident                 (. cc.Name = t.val; .)
                            (. cc.CreateInstanceVariable(typeRef, t.val); .)
    ] 
    ")" Block<cc>           (. cc.Terminate(t); .)
    [ CatchClauses<tryStm> ]
  )
.

// ------------------------------------------------------------------------------------
// Gets the signature of the specified lambda expression.
// +lambda: Lambda expression
// ------------------------------------------------------------------------------------
LambdaFunctionSignature<LambdaExpression lambda>
=
  (
    IF (la.kind == _ident)
    ident
  |
    "("
    (
      IF (IsExplicitLambdaParameter(la))
      ExplicitLambdaParameterList<lambda>
    |
      IF (la.kind != _rpar)
      ImplicitLambdaParameterList<lambda>      
    |
    )
    ")"
  )
.

// ------------------------------------------------------------------------------------
// Gets the explicit parameter list of the specified lambda expression.
// +lambda: Lambda expression
// ------------------------------------------------------------------------------------
ExplicitLambdaParameterList<LambdaExpression lambda>
=
                            (. FormalParameter fp = new FormalParameter(t, this); .)
  [
    "ref"                   (. fp.Kind = FormalParameterKind.Ref; .)
    | "out"                 (. fp.Kind = FormalParameterKind.Out; .)
  ]                         (. TypeReference typeRef; .)
  (. TypeOrNamespaceNode typeNode; .)
  Type<out typeRef, false, out typeNode>  
                            (. fp.Type = typeRef; .)
  ident                     (. fp.Name = t.val; .)
                            (. lambda.FormalParameters.Add(fp); .)
  [ "," ExplicitLambdaParameterList<lambda> ]
.

// ------------------------------------------------------------------------------------
// Gets the implicit parameter list of the specified lambda expression.
// +lambda: Lambda expression
// ------------------------------------------------------------------------------------
ImplicitLambdaParameterList<LambdaExpression lambda>
=
  ident                     (. FormalParameter fp = new FormalParameter(t, this); .)
                            (. fp.Name = t.val; .)
                            (. lambda.FormalParameters.Add(fp); .)
  [ "," ImplicitLambdaParameterList<lambda> ]
.

// ------------------------------------------------------------------------------------
// Gets the body of a lambda expression.
// +lambda: Lambda expression
// ------------------------------------------------------------------------------------
LambdaFunctionBody<LambdaExpression lambda>
                            (. ExpressionNode exprNode; .)
=
  (                         (. Expression expr; .)
    Expression<out expr, out exprNode>    
                            (. lambda.Expression = expr; .)
    |Block<lambda>
  )
.

// ------------------------------------------------------------------------------------
// Gets a from clause for a query expression
// +fromClause: From clause declaration
// ------------------------------------------------------------------------------------
FromClause<out FromClause fromClause>
                                (. ExpressionNode exprNode; .)
=
  "from"                        (. Token typeToken = la; .)
                                (. Token start = t; .)
                                (. TypeReference typeRef; .)
                                (. fromClause = new FromClause(start, this); .)
  (                             
    IF (IsType(ref typeToken) && typeToken.val != "in")
    (. TypeOrNamespaceNode typeNode; .)
    Type<out typeRef, false, out typeNode>    (. fromClause.Type = typeRef; .)
  |
  )                             
  ident                         (. fromClause.Name = t.val; .)
  "in"                          (. Expression expr; .)
  Expression<out expr, out exprNode>
                                (. fromClause.Expression = expr; .)
                                (. fromClause.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Gets the body of a query expression.
// +query: Query expression to obtain the body for.
// ------------------------------------------------------------------------------------
QueryBody<QueryBody body>
=
  { QueryBodyClause<body> }
  (
    SelectClause<body>
    | GroupClause<body>
  )
  [ QueryContinuation<body> ]
.

// ------------------------------------------------------------------------------------
// Gets a query body clause
// +body: Query expression body to add the clause for.
// ------------------------------------------------------------------------------------
QueryBodyClause<QueryBody body>
=
  (                                 (. FromClause fromClause; .)
    FromClause<out fromClause>      (. body.Clauses.Add(fromClause); .)
    |                               (. LetClause letClause; .)
      LetClause<out letClause>      (. body.Clauses.Add(letClause); .)
    |                               (. WhereClause whereClause; .)
      WhereClause<out whereClause>  (. body.Clauses.Add(whereClause); .)
    |                               (. JoinClause joinClause; .)
      JoinClause<out joinClause>    (. body.Clauses.Add(joinClause); .)
    |                               (. OrderByClause obClause; .)
      OrderByClause<out obClause>   (. body.Clauses.Add(obClause); .)
  )
.

// ------------------------------------------------------------------------------------
// Gets a let clause
// +letClause: Let clause declaration
// ------------------------------------------------------------------------------------
LetClause<out LetClause letClause>
                        (. ExpressionNode exprNode; .)
=
  "let"                 (. letClause = new LetClause(t, this); .)
  ident                 (. letClause.Name = t.val; .)
  "="                   (. Expression expr; .)
  Expression<out expr, out exprNode>
                        (. letClause.Expression = expr; .)
                        (. letClause.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Gets a where clause
// +whereClause: Where clause declaration
// ------------------------------------------------------------------------------------
WhereClause<out WhereClause whereClause>
                        (. ExpressionNode exprNode; .)
=
  "where"               (. whereClause = new WhereClause(t, this); .)
                        (. Expression expr; .)
  Expression<out expr, out exprNode>  
                        (. whereClause.Expression = expr; .)
                        (. whereClause.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Gets a join clause
// +joinClause: Join clause declaration
// ------------------------------------------------------------------------------------
JoinClause<out JoinClause joinClause>
                                (. ExpressionNode exprNode; .)
=
  "join"                        (. Token typeToken = la; .)
                                (. TypeReference typeRef; .)
                                (. joinClause = new JoinClause(t, this); .)
  (                     
    IF (IsType(ref typeToken) && typeToken.val != "in")
    (. TypeOrNamespaceNode typeNode; .)
    Type<out typeRef, false, out typeNode>    (. joinClause.Type = typeRef; .)
  |
  )
  ident                         (. joinClause.Name = t.val; .)
  "in"                          (. Expression inExpr; .)
  Expression<out inExpr, out exprNode>
                                (. joinClause.InExpression = inExpr; .)
  "on"                          (. Expression onExpr; .)
  Expression<out onExpr, out exprNode>
                                (. joinClause.OnExpression = onExpr; .)
  "equals"                      (. Expression eqExpr; .)
  Expression<out eqExpr, out exprNode>
                                (. joinClause.EqualsExpression = eqExpr; .)
  [ 
    "into"                      
    ident                       (. joinClause.IntoIdentifier = t.val; .)
  ]                             (. joinClause.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Gets an order by clause
// +obClause: Order by clause declaration
// ------------------------------------------------------------------------------------
OrderByClause<out OrderByClause obClause>
=
  "orderby"                     (. obClause = new OrderByClause(t, this); .)
  OrderingClause<obClause>
  { 
    "," 
    OrderingClause<obClause> 
  }                             (. obClause.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Gets an ordering clause
// +obClause: Order by clause declaration
// ------------------------------------------------------------------------------------
OrderingClause<OrderByClause obClause>
                                (. 
                                    Expression expr; 
                                    ExpressionNode exprNode;
                                .)
=
  Expression<out expr, out exprNode>
                                (. OrderingClause oc = new OrderingClause(t, this); .)
  [                             
    "ascending"                 (. oc.Ascending = true; .)
    | "descending"              (. oc.Ascending = false; .)
  ]                             (. oc.Expression = expr; .)
                                (. oc.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Gets a select clause
// +body: Query expression body to add the clause for.
// ------------------------------------------------------------------------------------
SelectClause<QueryBody body>
                        (. ExpressionNode exprNode; .)
=
  "select"              (. Expression expr; .)
  Expression<out expr, out exprNode>  
                        (. body.Select = new SelectClause(t, this); .)
                        (. body.Select.Expression = expr; .)
                        (. body.Select.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Gets a group by clause
// +body: Query expression body to add the clause for.
// ------------------------------------------------------------------------------------
GroupClause<QueryBody body>
                          (. ExpressionNode exprNode; .)
=
  "group"                 (. Expression grExpr; .)
  Expression<out grExpr, out exprNode>
                          (. body.GroupBy = new GroupByClause(t, this); .)
                          (. body.GroupBy.Expression = grExpr; .)
  "by"                    (. Expression byExpr; .)
  Expression<out byExpr, out exprNode>
                          (. body.GroupBy.ByExpression = byExpr; .)
                          (. body.GroupBy.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Gets a query continuation clause
// +body: Query expression body to add the clause for.
// ------------------------------------------------------------------------------------
QueryContinuation<QueryBody body>
=
  "into"
  ident                   (. body.IntoIdentifier = t.val; .)
                          (. body.ContinuationBody = new QueryBody(); .)
  QueryBody<body.ContinuationBody>
.

// ------------------------------------------------------------------------------------------------
// Retrieves an expression.
//   expr: expression retrieved.
//   exprNode: expression onde retrieved.
// ------------------------------------------------------------------------------------------------
Expression<out Expression expr, out ExpressionNode exprNode>   
  (. 
     expr = null; 
     // :::
     exprNode = null;
     Expression leftExpr;
     ExpressionNode leftExprNode;
  .)
=
  (
    IF (IsQueryExpression())      (. QueryExpression query = new QueryExpression(t, this); .)
                                  (. FromClause fromClause; .)
    FromClause<out fromClause>    (. query.From = fromClause; .)
    QueryBody<query.Body>         (. expr = query; .)
  |
    IF (IsLambda())               (. LambdaExpression lambda = new LambdaExpression(t, this); .)
    LambdaFunctionSignature<lambda>   
    "=>"
    LambdaFunctionBody<lambda>    (. expr = lambda; .)
  |
  Unary<out leftExpr, out leftExprNode>
  (
    IF (assgnOps[la.kind] || (la.kind == _gt && Peek(1).kind == _gteq))
                                  (. AssignmentOperator asgn; .)
    AssignmentOperator<out asgn>  (. Expression rightExpr; .)
    Expression<out rightExpr, out exprNode>
                                  (. asgn.RightOperand = rightExpr; .)
                                  (. asgn.LeftOperand = leftExpr; .)
                                  (. expr = asgn; .)
  | (. BinaryOperator simpleExpr; .)
    NullCoalescingExpr<out simpleExpr> 
                                  (. 
                                     if (simpleExpr == null) 
                                     {
                                       expr = leftExpr;
                                     }
                                     else
                                     {
                                       simpleExpr.LeftMostNonNull.LeftOperand = leftExpr;
                                       expr = simpleExpr;
                                     }
                                  .)
    [                             (. ConditionalOperator condExpr = new ConditionalOperator(t, this, expr); .)
                                  (. expr = condExpr; .)    
      "?"                         (. Expression trueExpr; .)
      Expression<out trueExpr, out exprNode>
                                  (. condExpr.TrueExpression = trueExpr; .)
      ":"                         (. Expression falseExpr; .)
      Expression<out falseExpr, out exprNode>
                                  (. condExpr.FalseExpression = falseExpr; .)
                                  (. condExpr.Terminate(t); .)
    ]
  )
  )                               (. if (expr != null) expr.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Defines a null coalescing operator.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
NullCoalescingExpr<out BinaryOperator expr> (. expr = null; .)
=                     
  OrExpr<out expr>    
  { 
    "??"                  (. BinaryOperator oper = new NullCoalescingOperator(t, this); .)
                          (. oper.LeftOperand = expr; .)
    (. 
       Expression unExpr; 
       ExpressionNode unaryNode;
    .)
    Unary<out unExpr, out unaryNode>
    (. BinaryOperator rightExpr; .)
    OrExpr<out rightExpr> (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                             oper.Terminate(t);
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines a logical or operator.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
OrExpr<out BinaryOperator expr> (. expr = null; .)
= 
  AndExpr<out expr>    
  { 
    "||"                  (. BinaryOperator oper = new OrOperator(t, this); .)
                          (. oper.LeftOperand = expr; .)
    (. 
       Expression unExpr; 
       ExpressionNode unaryNode;
    .)
    Unary<out unExpr, out unaryNode>     
    (. BinaryOperator rightExpr; .)
    AndExpr<out rightExpr> (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                             oper.Terminate(t);
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines a logical and operator.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
AndExpr<out BinaryOperator expr> (. expr = null; .)
= 
  BitOrExpr<out expr>    
  { 
    "&&"                  (. BinaryOperator oper = new AndOperator(t, this); .)
                          (. oper.LeftOperand = expr; .)
    (. 
       Expression unExpr; 
       ExpressionNode unaryNode;
    .)
    Unary<out unExpr, out unaryNode>     
    (. BinaryOperator rightExpr; .)
    BitOrExpr<out rightExpr> (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                             oper.Terminate(t);
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines a bitwise or operator.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
BitOrExpr<out BinaryOperator expr> (. expr = null; .)
= 
  BitXorExpr<out expr>    
  { 
    "|"                   (. BinaryOperator oper = new BitwiseOrOperator(t, this); .)
                          (. oper.LeftOperand = expr; .)
                          
    (. 
       Expression unExpr; 
       ExpressionNode unaryNode;
    .)
    Unary<out unExpr, out unaryNode>     
    (. BinaryOperator rightExpr; .)
    BitXorExpr<out rightExpr> (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                             oper.Terminate(t);
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines a bitwise xor operator.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
BitXorExpr<out BinaryOperator expr> (. expr = null; .)
= 
  BitAndExpr<out expr>    
  { 
    "^"                   (. BinaryOperator oper = new BitwiseXorOperator(t, this); .)
                          (. oper.LeftOperand = expr; .)
    (. 
       Expression unExpr; 
       ExpressionNode unaryNode;
    .)
    Unary<out unExpr, out unaryNode>     
    (. BinaryOperator rightExpr; .)
    BitAndExpr<out rightExpr> (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                             oper.Terminate(t);
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines a bitwise and operator.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
BitAndExpr<out BinaryOperator expr> (. expr = null; .)
= 
  EqlExpr<out expr>    
  { 
    "&"                   (. BinaryOperator oper = new BitwiseAndOperator(t, this); .)
                          (. oper.LeftOperand = expr; .)
    (. 
       Expression unExpr; 
       ExpressionNode unaryNode;
    .)
    Unary<out unExpr, out unaryNode>     
    (. BinaryOperator rightExpr; .)
    EqlExpr<out rightExpr> (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                             oper.Terminate(t);
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines an "==" or "!=" operator.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
EqlExpr<out BinaryOperator expr> (. expr = null; .)
= 
  RelExpr<out expr>       (. BinaryOperator oper; .)
  {           
    (                     
      "!="                (. oper = new EqualOperator(t, this); .)
      | "=="              (. oper = new NotEqualOperator(t, this); .)
    )                     (. oper.LeftOperand = expr; .)
    (. 
       Expression unExpr; 
       ExpressionNode unaryNode;
    .)
    Unary<out unExpr, out unaryNode>     
    (. BinaryOperator rightExpr; .) 
    RelExpr<out rightExpr> (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                             oper.Terminate(t);
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines relational and typecheck operators.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
RelExpr<out BinaryOperator expr> (. expr = null; BinaryOperator oper = null; .)
= 
  ShiftExpr<out expr>  
  { 
    (
      "<"                 (. oper = new LessThanOperator(t, this); .)
      | ">"               (. oper = new GreaterThanOperator(t, this); .)
      | "<="              (. oper = new LessThanOrEqualOperator(t, this); .)
      | ">="              (. oper = new GreaterThanOrEqualOperator(t, this); .)
    )                     (. oper.LeftOperand = expr; .)
                          
    (. 
       Expression unExpr; 
       ExpressionNode unaryNode;
    .)
    Unary<out unExpr, out unaryNode>     
    (. BinaryOperator rightExpr; .)
    ShiftExpr<out rightExpr>             
                          (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                             oper.Terminate(t);
                          .)
    |
      (
          "is"            (. oper = new IsOperator(t, this); .)
        | "as"            (. oper = new IsOperator(t, this); .)
      )                   (. oper.LeftOperand = expr; .)
                          (. TypeReference typeRef; .)
      TypeInRelExpr<out typeRef, false>
                          (. oper.RightOperand = new TypeOperator(t, typeRef); .)
                          (. expr = oper; .)
                          (. oper.Terminate(t); .)
  }
.

// ------------------------------------------------------------------------------------
// Defines shift operators.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
ShiftExpr<out BinaryOperator expr> (. expr = null; .)
= 
  AddExpr<out expr>       (. BinaryOperator oper = null; .)
  { IF (IsShift())
    (
      "<<"                (. oper = new LeftShiftOperator(t, this); .)
      | ">" ">"           (. oper = new RightShiftOperator(t, this); .)
    )                     (. oper.LeftOperand = expr; .)
                          
    (. 
       Expression unExpr; 
       ExpressionNode unaryNode;
    .)
    Unary<out unExpr, out unaryNode>     
    (. BinaryOperator rightExpr; .) 
    AddExpr<out rightExpr>
                          (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                             oper.Terminate(t);
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines addition operators.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
AddExpr<out BinaryOperator expr> (. expr = null; .)
= 
  MulExpr<out expr>       (. BinaryOperator oper = null; .)
  {
    ( 
      "+"                 (. oper = new AddOperator(t, this); .)
      | "-"               (. oper = new SubtractOperator(t, this); .)
    )                     (. oper.LeftOperand = expr; .)
    (. 
       Expression unExpr; 
       ExpressionNode unaryNode;
    .)
    Unary<out unExpr, out unaryNode>     
    (. BinaryOperator rightExpr; .) 
    MulExpr<out rightExpr>
                          (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                             oper.Terminate(t);
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines multiplication operators.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
MulExpr<out BinaryOperator expr> 
                          (. 
                             expr = null;
                             BinaryOperator oper = null; 
                          .)
=                          
  {
    (
      "*"                 (. oper = new MultiplyOperator(t, this); .)
      | "/"               (. oper = new DivideOperator(t, this); .)
      | "%"               (. oper = new ModuloOperator(t, this); .)
    )                     (. oper.LeftOperand = expr; .)
    (. 
       Expression unExpr; 
       ExpressionNode unaryNode;
    .)
    Unary<out unExpr, out unaryNode>     
    (. oper.RightOperand = unExpr; .)
    (. expr = oper; .)
    (. oper.Terminate(t); .)
  }
                          
.

// ------------------------------------------------------------------------------------------------
// Retrieves an unary expression.
//   expr: Expression retrieved.
//   exprNode: Expression node retrieved.
// ------------------------------------------------------------------------------------------------
Unary<out Expression expr, out ExpressionNode exprNode>    
  (. 
     UnaryOperator unOp = null;
     expr = null;
     // :::
     exprNode = null;
     UnaryOperatorNode unaryOp = null;
  .)
=
  (
    IF (unaryHead[la.kind] || IsTypeCast())
    ( 
      "+"     
      (. 
         unOp = new UnaryPlusOperator(t, this); 
         unaryOp = new UnaryPlusNode(t);
      .)
    | "-"   
      (. 
         unOp = new UnaryMinusOperator(t, this); 
         unaryOp = new UnaryMinusNode(t);
      .)
    | "!"   
      (. 
         unOp = new NotOperator(t, this); 
         unaryOp = new UnaryNotNode(t);
      .)
    | "~"   
      (. 
        unOp = new BitwiseNotOperator(t, this); 
        unaryOp = new BitwiseNotNode(t);
      .)
    | "++"  
      (. 
         unOp = new PreIncrementOperator(t, this); 
         unaryOp = new PreIncrementNode(t);
      .)
    | "--"  
      (. 
         unOp = new PreDecrementOperator(t, this);
         unaryOp = new PreDecrementNode(t);
      .)
    | "*"   
      (. 
         unOp = new PointerOperator(t, this); 
         unaryOp = new PointerOperatorNode(t);
      .)
    | "&"   
      (. 
         unOp = new ReferenceOperator(t, this); 
         unaryOp = new ReferenceOperatorNode(t);
      .)
    | "("   
      (. 
         TypeReference typeRef;
         TypeCastOperator tcOp = new TypeCastOperator(t, this);
         // :::
         TypeOrNamespaceNode typeNode; 
         var tcNode = new TypecastNode(t);
         unaryOp = tcNode;
      .)
      Type<out typeRef, false, out typeNode> 
      (. tcNode.TypeName = typeNode; .)
      ")"
      (. 
         tcOp.Type = typeRef;
         unOp = tcOp; 
      .)
    )
  )
  (. 
     Expression unaryExpr; 
     // :::
     ExpressionNode unaryNode;
  .)
  Unary<out unaryExpr, out unaryNode>
  (. 
     if (unOp == null) expr = unaryExpr;
     else
     {
       unOp.Operand = unaryExpr;
       expr = unOp;
     }
     unOp.Terminate(t);
     // :::
     if (unaryOp == null) exprNode = unaryNode;
     else
     {
       unaryOp.Operand = unaryNode;
       exprNode = unaryOp;
     }
     unaryOp.Terminate(t);
  .)
  | Primary<out expr, out exprNode>
.

// ------------------------------------------------------------------------------------------------
// Retrieves a primary expression.
//   expr: Expression retrieved.
//   exprNode: Expression node retrieved.
// ------------------------------------------------------------------------------------------------
Primary<out Expression expr, out ExpressionNode exprNode>
  (. 
     Expression innerExpr = null;
     expr = null;
     // :::
     ExpressionNode innerNode = null;
     exprNode = null;
  .)
=
  ( 
    Literal<out innerExpr, out innerNode>             
  | 
    "("
    (. 
       var pExprNode = new ParenthesisExpressionNode(t); 
    .) 
    Expression<out innerExpr, out innerNode>
    (. 
       pExprNode.Expression = innerNode;
       innerNode = pExprNode;
    .)
    ")"  
    (. 
       if (innerExpr != null) innerExpr.BracketsUsed = true; 
       pExprNode.Terminate(t);
    .)
  | PrimitiveNamedLiteral<out innerExpr, out innerNode>
  | NamedLiteral<out innerExpr, out innerNode>
  | "this" 
    (. 
       innerExpr = new ThisLiteral(t, this); 
       innerNode = new ThisNode(t);
    .)
  | "base" 
    (. 
       innerExpr = new BaseLiteral(t, this); 
       innerNode = new BaseNode(t);
    .)
  | NewOperator<out innerExpr>
  | TypeOfOperator<out innerExpr, out innerNode>
  | CheckedOperator<out innerExpr, out innerNode>
  | UncheckedOperator<out innerExpr, out innerNode>
  | DefaultOperator<out innerExpr>
  | AnonymousDelegate<out innerExpr>
  | SizeOfOperator<out innerExpr, out innerNode>
  )

  (. 
     Expression curExpr = innerExpr; 
     var curExprNode = innerNode;
  .)

  { 
  (
      "++"  
      (. 
         curExpr = new PostIncrementOperator(t, this, innerExpr); 
         var incNode = new PostIncrementNode(t);
         incNode.Operand = curExprNode;
         curExprNode = incNode;
      .) 
    | "--"  
      (. 
         curExpr = new PostDecrementOperator(t, this, innerExpr); 
         var decNode = new PostDecrementNode(t);
         decNode.Operand = curExprNode;
         curExprNode = decNode;
      .) 
    | "->"  (. NamedLiteral nl; .)
      SimpleNamedLiteral<out nl>
            (. curExpr = new CTypeMemberAccessOperator(t, innerExpr, nl); .)
    | "."   (. NamedLiteral nl; .)
      SimpleNamedLiteral<out nl>
            (. curExpr = new MemberAccessOperator(t, innerExpr, nl); .)
    | "("   (. ArgumentListOperator alop = new ArgumentListOperator(t, this, innerExpr); .)
        [ Argument<alop.Arguments> { "," Argument<alop.Arguments> } ] 
      ")"   (. curExpr = alop; .)
    |       (. ArrayIndexerOperator aiop = new ArrayIndexerOperator(t, this, innerExpr); .)                                                                         
      ArrayIndexer<aiop> 
            (. curExpr = aiop; .)
  )         (. curExpr.Terminate(t); .)
  }
  
  (. expr = curExpr; .)
.

// ------------------------------------------------------------------------------------
// Declaration of a literal expression.
//   value: Expression retrieved.
//   valNode: Expression node retrieved.
// ------------------------------------------------------------------------------------
Literal<out Expression value, out ExpressionNode valNode>
  (. 
     value = null; 
     // :::
     valNode = null;
  .)
= 
    intCon        
    (. 
       value = IntegerConstant.Create(t, this); 
       valNode = IntegerConstantNode.Create(t);
    .)
  | realCon     
    (. 
       value = RealConstant.Create(t, this); 
       valNode = RealConstantNode.Create(t);
    .)
  | charCon     
    (. 
       value = new CharLiteral(t, this); 
       valNode = new CharNode(t);
    .)
  | stringCon   
    (. 
       value = new StringLiteral(t, this); 
       valNode = new StringNode(t);
    .)
  | "true"
    (. 
       value = new TrueLiteral(t, this); 
       valNode = new TrueNode(t);
    .)
  | "false"     
    (. 
       value = new FalseLiteral(t, this); 
       valNode = new FalseNode(t);
    .)
  | "null"      
    (. 
       value = new NullLiteral(t, this); 
       valNode = new NullNode(t);
    .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a primitive named literal expression.
//   expr: Literal expression value.
//   exprNode: Literal expression node.
// ------------------------------------------------------------------------------------------------
PrimitiveNamedLiteral<out Expression expr, out ExpressionNode exprNode>  
  (. 
     expr = null; 
     exprNode = null;
     PrimitiveNamedLiteral pml = null;
  .)
=            
  (   "bool"      (. pml = new PrimitiveNamedLiteral(t, this, typeof(bool)); .)
    | "byte"      (. pml = new PrimitiveNamedLiteral(t, this, typeof(byte)); .)
    | "char"      (. pml = new PrimitiveNamedLiteral(t, this, typeof(char)); .)
    | "decimal"   (. pml = new PrimitiveNamedLiteral(t, this, typeof(decimal)); .)
    | "double"    (. pml = new PrimitiveNamedLiteral(t, this, typeof(double)); .)
    | "float"     (. pml = new PrimitiveNamedLiteral(t, this, typeof(float)); .)
    | "int"       (. pml = new PrimitiveNamedLiteral(t, this, typeof(int)); .)
    | "long"      (. pml = new PrimitiveNamedLiteral(t, this, typeof(long)); .)
    | "object"    (. pml = new PrimitiveNamedLiteral(t, this, typeof(object)); .)
    | "sbyte"     (. pml = new PrimitiveNamedLiteral(t, this, typeof(sbyte)); .)
    | "short"     (. pml = new PrimitiveNamedLiteral(t, this, typeof(short)); .)
    | "string"    (. pml = new PrimitiveNamedLiteral(t, this, typeof(string)); .)
    | "uint"      (. pml = new PrimitiveNamedLiteral(t, this, typeof(uint)); .)
    | "ulong"     (. pml = new PrimitiveNamedLiteral(t, this, typeof(ulong)); .)
    | "ushort"    (. pml = new PrimitiveNamedLiteral(t, this, typeof(ushort)); .)
  )               
  (. 
     expr = pml; 
     var pnNode = new PrimitiveNamedNode(t);
     exprNode = pnNode;
  .)
  "." 
  (. pnNode.SeparatorToken = t; .)
  ident           
  (. 
     pml.Name = t.val;
     pml.Terminate(t);
     // :::
     pnNode.IdentifierToken = t;
     pnNode.Terminate(t);
  .)
.

// ------------------------------------------------------------------------------------
// Declaration of a named literal expression.
// +expr: Literal expression value.
// ------------------------------------------------------------------------------------
NamedLiteral<out Expression expr, out ExpressionNode exprNode>  
  (. 
     expr = null; 
     // :::
     exprNode = null;
  .)
=              
  ident        
  (. 
     NamedLiteral nl = new NamedLiteral(t, this); 
     expr = nl;
     nl.Name = t.val;
     // :::
     var nlNode = new NamedLiteralNode(t);
     exprNode = nlNode;
  .)
  [ 
    "::"       
    (. 
       nl.IsGlobalScope = true; 
       nlNode.QualifierSeparatorToken = t;
       nlNode.QualifierToken = nlNode.IdentifierToken;
    .)
    ident      
    (. 
       nl.Name = t.val; 
       nlNode.IdentifierToken = t;
    .)
  ] 
  (. TypeArgumentListNode argList; .)
  [ 
    IF (IsGeneric()) TypeArgumentList<nl.TypeArguments, out argList>
    (. nlNode.Arguments = argList; .)
  ]
  (. 
     nl.Terminate(t); 
     // :::
     nlNode.Terminate(t);
  .)
.

// ------------------------------------------------------------------------------------
// Declaration of a simple named literal expression.
// +expr: Named literal expression value.
// ------------------------------------------------------------------------------------
SimpleNamedLiteral<out NamedLiteral expr> 
=            (.
                // :::
                TypeArgumentListNode argList = null;
             .)
ident        (. expr = new NamedLiteral(t, this); .)
  [ IF (IsGeneric()) TypeArgumentList<expr.TypeArguments, out argList> ]
               (. expr.Terminate(t); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a typeof operator.
//   expr: Expression value.
//   exprNode: Expression node.
// ------------------------------------------------------------------------------------------------
TypeOfOperator<out Expression expr, out ExpressionNode exprNode>
= 
  "typeof"                   
  (. 
     TypeOfOperator top = new TypeOfOperator(t, this); 
     var topNode = new TypeofOperatorNode(t);
     exprNode = topNode;
  .)
  "("                        
  (. 
     expr = top; 
     topNode.OpenParenthesis = t;
     TypeReference typeRef; 
     TypeOrNamespaceNode typeNode;
  .)
  Type<out typeRef, true, out typeNode>
  (. 
     top.Type = typeRef; 
     topNode.TypeName = typeNode;
  .)
  ")"
  (. 
     top.Terminate(t); 
     topNode.CloseParenthesis = t;
     exprNode.Terminate(t);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a sizeof operator.
//   expr: Expression value.
//   exprNode: Expression node.
// ------------------------------------------------------------------------------------------------
SizeOfOperator<out Expression expr, out ExpressionNode exprNode>
= 
  "sizeof"                   
  (. 
     SizeOfOperator sop = new SizeOfOperator(t, this); 
     var sopNode = new SizeofOperatorNode(t);
     exprNode = sopNode;
  .)
  "("                        
  (. 
     expr = sop; 
     sopNode.OpenParenthesis = t;
     TypeReference typeRef; 
     TypeOrNamespaceNode typeNode;
  .)
  Type<out typeRef, true, out typeNode>  
  (. 
     sop.Type = typeRef; 
     sopNode.TypeName = typeNode;
  .)
  ")"                        
  (. 
     sop.Terminate(t); 
     sopNode.CloseParenthesis = t;
     exprNode.Terminate(t);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a checked operator.
//   expr: Expression value.
//   exprNode: Expression node.
// ------------------------------------------------------------------------------------------------
CheckedOperator<out Expression expr, out ExpressionNode exprNode>
= 
  "checked"                     
  (. 
     CheckedOperator cop = new CheckedOperator(t, this); 
     var copNode = new CheckedOperatorNode(t);
     exprNode = copNode;
  .)
  "("                           
  (. 
     expr = cop; 
     copNode.OpenParenthesis = t;
     Expression innerExpr;
     ExpressionNode innerNode;
  .)
  Expression<out innerExpr, out innerNode>   
  (. 
     cop.Operand = innerExpr; 
     copNode.Expression = innerNode;
  .)
  ")"
  (. 
     cop.Terminate(t); 
     copNode.CloseParenthesis = t;
     exprNode.Terminate(t);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of an unchecked operator.
//   expr: Expression value.
//   exprNode: Expression node.
// ------------------------------------------------------------------------------------------------
UncheckedOperator<out Expression expr, out ExpressionNode exprNode>
= 
  "unchecked"                   
  (. 
     UncheckedOperator uop = new UncheckedOperator(t, this); 
     var uopNode = new UncheckedOperatorNode(t);
     exprNode = uopNode;
  .)
  "("                           
  (. 
     expr = uop;
     uopNode.OpenParenthesis = t;
     Expression innerExpr; 
     ExpressionNode innerNode;
  .)
  Expression<out innerExpr, out innerNode>
  (. 
     uop.Operand = innerExpr; 
     uopNode.Expression = innerNode;
  .)
  ")"                           
  (. 
     uop.Terminate(t); 
     uopNode.CloseParenthesis = t;
     exprNode.Terminate(t);
  .)
.

// ------------------------------------------------------------------------------------
// Declaration of a default operator.
// +expr: Expression value.
// ------------------------------------------------------------------------------------
DefaultOperator<out Expression expr>
= 
  "default"                 (. DefaultOperator dop = new DefaultOperator(t, this); .)
  "("                       (. expr = dop; .)
    (. 
       Expression innerExpr; 
       ExpressionNode primNode;
    .)
    Primary<out innerExpr, out primNode>  
    (. dop.Operand = innerExpr; .)
  ")"                       (. dop.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Declaration of a "new" operator.
// +expr: Expression value.
// ------------------------------------------------------------------------------------
NewOperator<out Expression expr>  
= 
  "new"                           (. NewOperator nop = new NewOperator(t, this); .)
                                  (. expr = nop; .)
                                  (. TypeReference typeRef; .)
  (
    AnonymousObjectInitializer<nop>
  |
    (. TypeOrNamespaceNode typeNode; .)
    NonArrayType<out typeRef, out typeNode>      
    NewOperatorWithType<nop, typeRef>
  |
    ImplicitArrayCreation<nop>    (. nop.Kind = NewOperatorKind.UntypedArrayInitialization; .)
  )
.

AnonymousObjectInitializer<NewOperator nop>
=
  "{"                                   
  (
    IF (!IsEmptyMemberInitializer()) (. MemberDeclaratorList mInitList; .)      
    MemberDeclaratorList<out mInitList> 
    [ "," ]
  )
  "}"
.

MemberDeclaratorList<out MemberDeclaratorList initList>  
                                  (. 
                                     initList = new MemberDeclaratorList(t, this);
                                     MemberDeclarator mInit;
                                  .)
=                     
  MemberDeclarator<out mInit>     (. initList.Initializers.Add(mInit); .)
  {
    IF (NotFinalComma()) ","
    MemberDeclarator<out mInit>   (. initList.Initializers.Add(mInit); .)
  }                               (. initList.Terminate(t); .)
.

MemberDeclarator<out MemberDeclarator init> 
                                  (. 
                                     init = null; 
                                     Expression expr = null;
                                     ExpressionNode exprNode;
                                  .)
=
  (
    IF (IsMemberInitializer())
    ident                         (. Token start = t; .)
    "=" Expression<out expr, out exprNode>
                                  (. init = new MemberDeclarator(start, this, expr, start.val); .)
  | 
    (. 
       Token start = la; 
       ExpressionNode primNode;
    .)
    Primary<out expr, out primNode>
    (. init = new MemberDeclarator(start, this, expr, start.val, true); .)
  |
                                  (. 
                                     Token start = la; 
                                     TypeReference typeRef;
                                  .)
    PredefinedType<out typeRef>                                  
    "."
    ident                         (. init = new MemberDeclarator(start, this, typeRef, start.val); .)
  )
.

// ------------------------------------------------------------------------------------
// Declaration of a "new" operator with explicit type.
// +nop: NewOperator delcaration
// +typeRef: Type to create with the new operator
// ------------------------------------------------------------------------------------
NewOperatorWithType<NewOperator nop, TypeReference typeRef> 
                                   (. 
                                      ArrayInitializer arrayInit;
                                      nop.Type = typeRef; 
                                      ExpressionNode exprNode;
                                   .)
=
  (
    // --- Simple constructor call
    "(" 
    [ 
      Argument<nop.Arguments> 
      { "," Argument<nop.Arguments> } 
    ] 
    ")"
    // --- Optional initializer list
    [                             (. Initializer init; .)
      ObjectOrCollectionInitializer<out init> 
                                  (. nop.Initializer = init; .)
    ]

  | // --- Implicit default constructor call
                                  (. Initializer init; .)
      ObjectOrCollectionInitializer<out init> 
                                  (. nop.Initializer = init; .)
  | // --- Array initialization
    IF (IsDims())                 (. nop.Kind = NewOperatorKind.TypedArrayInitialization; .)
    "["                           (. nop.RunningDimensions = 1; .)
      { 
        ","                       (. nop.RunningDimensions++; .)
      } 
    "]" 
    ArrayInitializer<out arrayInit>  (. nop.Initializer = arrayInit; .)

  | // --- New array creation
    "["                           (. Expression dimExpr; .)
    Expression<out dimExpr, out exprNode>
                                  (. nop.Dimensions.Add(dimExpr); .)
    { 
      "," 
      Expression<out dimExpr, out exprNode>
                                  (. nop.Dimensions.Add(dimExpr); .)
    } 
    "]" 
    { IF (IsDims()) 
      "["                         (. nop.RunningDimensions = 1; .)
        { 
          ","                     (. nop.RunningDimensions++; .)
        } 
      "]" 
    }                             (. nop.Kind = NewOperatorKind.TypedArrayCreation; .)
    [                             
      ArrayInitializer<out arrayInit> (. nop.Initializer = arrayInit; .)
                                      (. nop.Kind = NewOperatorKind.TypedArrayInitialization; .)
    ] 
  )                                  (. nop.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Declaration of an implicit array creation
// +nop: NewOperator delcaration
// +typeRef: Type to create with the new operator
// ------------------------------------------------------------------------------------
ImplicitArrayCreation<NewOperator nop> 
                                    (. 
                                       ArrayInitializer arrayInit;
                                       nop.IsImplicitArray = true;
                                    .)
=
  "["                               (. nop.RunningDimensions = 1; .)
    { 
      ","                           (. nop.RunningDimensions++; .)
    } 
  "]" 
  [                             
    ArrayInitializer<out arrayInit> (. nop.Initializer = arrayInit; .)
  ]
.

// ------------------------------------------------------------------------------------
// Declares an object or collection initializer used with "new" operator
// +init: initializer resulted from parsing
// ------------------------------------------------------------------------------------
ObjectOrCollectionInitializer<out Initializer init> 
=
  "{"                                     (. init = null; .)
  
  (
    IF (IsEmptyMemberInitializer()) "}"   
  |
    IF (IsMemberInitializer())            (. MemberInitializerList mInitList; .)
    MemberInitializerList<out mInitList>  (. init = mInitList; .)
  |
    CollectionInitializer<out init> 
  )
  "}"
.

// ------------------------------------------------------------------------------------
// Declares a collection initializer used with "new" operator
// +init: initializer resulted from parsing
// ------------------------------------------------------------------------------------
CollectionInitializer<out Initializer init> 
                                          (. 
                                             CollectionInitializer collInit = new CollectionInitializer(t, this); 
                                             init = collInit;
                                             Initializer elInit;
                                          .)
=
  ElementInitializerList<out elInit>      (. collInit.Initializers.Add(elInit); .)
                                          (. init.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Declares an element initializer list of a collection used with "new" operator
// +init: initializer resulted from parsing
// ------------------------------------------------------------------------------------
ElementInitializerList<out Initializer init> 
                                          (. 
                                             CollectionInitializer collInit = new CollectionInitializer(t, this); 
                                             init = collInit;
                                             Initializer elementInit;
                                          .) 
=
  ElementInitializer<out elementInit>     (. collInit.Initializers.Add(elementInit); .)
  {
    IF (NotFinalComma()) ","
    ElementInitializer<out elementInit>   (. collInit.Initializers.Add(elementInit); .)
  } [ "," ]                               (. init.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Declares an element initializer of a collection used with "new" operator
// +init: initializer resulted from parsing
// ------------------------------------------------------------------------------------
ElementInitializer<out Initializer init>   
                                          (. 
                                              Expression expr; init = null; 
                                              ExpressionNode exprNode;
                                          .)
=
  (
    IF (IsValueInitializer())
    Expression<out expr, out exprNode>    (. init = new ExpressionInitializer(t, this, expr); .)
  | 
                                          (. ExpressionListInitializer listInit = new ExpressionListInitializer(t, this); .)
                                          (. init = listInit; .)
    "{"
      Expression<out expr, out exprNode>  (. listInit.Initializers.Add(new ExpressionInitializer(t, this, expr)); .)
      {
        ","
        Expression<out expr, out exprNode> (. listInit.Initializers.Add(new ExpressionInitializer(t, this, expr)); .)
      }
    "}"
  )                                       (. if (init != null) init.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// A member initialization list declaration
// +initList: member initializer list
// ------------------------------------------------------------------------------------
MemberInitializerList<out MemberInitializerList initList>  
                                  (. 
                                     initList = new MemberInitializerList(t, this);
                                     MemberInitializer mInit;
                                  .)
=                     
  MemberInitializer<out mInit>    (. initList.Initializers.Add(mInit); .)
  {
    IF (NotFinalComma()) ","
    MemberInitializer<out mInit>  (. initList.Initializers.Add(mInit); .)
  } [ "," ]                       (. initList.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// A member initialization declaration
// +init: member initializer
// ------------------------------------------------------------------------------------
MemberInitializer<out MemberInitializer init>
                              (. ExpressionNode exprNode; .)
=
  ident                       (. Token startToken = t; .)
  "="                         (. Expression expr; .)
                              (. init = null; .)
  (
    IF (IsValueInitializer())
    Expression<out expr, out exprNode>
                              (. init = new MemberInitializer(startToken, this, expr); .)
  |                           
                              (. Initializer compoundInit; .)
    ObjectOrCollectionInitializer<out compoundInit>
                              (. init = new MemberInitializer(startToken, this, compoundInit); .)
  )
                              (. init.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Declaration of a "new" operator.
// +expr: Expression value.
// ------------------------------------------------------------------------------------
AnonymousDelegate<out Expression expr>  
= 
  "delegate"            (. AnonymousDelegateOperator adop = new AnonymousDelegateOperator(t, this); .)
                        (. CurrentElement = adop; .)
  [                     (. FormalParameter param; .)
    "(" 
    [ 
      AnonymousMethodParameter<out param>     (. adop.FormalParameters.Add(param); .)
      { 
        "," 
        AnonymousMethodParameter<out param>   (. adop.FormalParameters.Add(param); .)
      } 
    ] 
    ")" 
  ] 
  Block<adop>           (. expr = adop; .)
                        (. adop.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Declaration of an anonymous method parameter.
// +param: Parameter definition.
// ------------------------------------------------------------------------------------
AnonymousMethodParameter<out FormalParameter param> (. param = new FormalParameter(t, this); .)
=
  [                             
    "ref"                       (. param.Kind = FormalParameterKind.Ref; .) 
    | "out"                     (. param.Kind = FormalParameterKind.Out; .) 
  ]                             (. TypeReference typeRef; .)
  (. TypeOrNamespaceNode typeNode; .)
  Type<out typeRef, false, out typeNode>      (. param.Type = typeRef; .)
  ident                         (. param.Name = t.val; .)
                                (. param.Terminate(t); .)  
.

// ------------------------------------------------------------------------------------
// Declaration of a "new" operator.
// +expr: Expression value.
// ------------------------------------------------------------------------------------
ArrayIndexer<ArrayIndexerOperator indexer> 
                              (. ExpressionNode exprNode; .) 
= 
  "["                         (. Expression expr; .)
  Expression<out expr, out exprNode>
                              (. indexer.Indexers.Add(expr); .)
  { 
    "," 
    Expression<out expr, out exprNode>
                              (. indexer.Indexers.Add(expr); .)
  } 
  "]"
.

// ------------------------------------------------------------------------------------
// Declaration of a field member variable.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// +typeRef: Type of the constant.
// +isEvent: Flags, if the field is an event field or not.
// ------------------------------------------------------------------------------------
FieldMemberDeclarators<AttributeCollection attrs, Modifiers m, TypeDeclaration td, 
  TypeReference typeRef, bool isEvent, Modifier toCheck>
= 
  SingleFieldMember<attrs, m, td, typeRef, isEvent>
  { "," SingleFieldMember<attrs, m, td, typeRef, isEvent> }
.

// ------------------------------------------------------------------------------------
// Declaration of a single field member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// +typeRef: Type of the constant.
// +isEvent: Flags, if the field is an event field or not.
// ------------------------------------------------------------------------------------
SingleFieldMember<AttributeCollection attrs, Modifiers m, TypeDeclaration td, 
  TypeReference typeRef, bool isEvent>
= 
  ident                      (. 
                                FieldDeclaration fd = new FieldDeclaration(t, td); 
                                CurrentElement = fd;
                                fd.SetModifiers(m.Value);
                                fd.AssignAttributes(attrs);
                                fd.ResultingType = typeRef;
                                fd.Name = t.val;
                                fd.IsEvent = isEvent;
                             .)
  [ "="                      (. Initializer init; .)
    VariableInitializer<out init> (. fd.Initializer = init; .) 
  ]                          (. td.AddMember(fd); .) 
                             (. fd.Terminate(t); .)
.

// ------------------------------------------------------------------------------------
// Defines the operators that can be overloaded.
// +op: overloaddable operator.
// ------------------------------------------------------------------------------------
OverloadableOp<out Operator op> (. op = Operator.Plus; .)
=                          
    "+"                                     
  | "-"                         (. op = Operator.Minus; .)
  | "!"                         (. op = Operator.Not; .)
  | "~"                         (. op = Operator.BitwiseNot; .)
  | "++"                        (. op = Operator.Increment; .)
  | "--"                        (. op = Operator.Decrement; .)
  | "true"                      (. op = Operator.True; .)
  | "false"                     (. op = Operator.False; .)
  | "*"                         (. op = Operator.Multiply; .)
  | "/"                         (. op = Operator.Divide; .)
  | "%"                         (. op = Operator.Modulus; .)
  | "&"                         (. op = Operator.BitwiseAnd; .)
  | "|"                         (. op = Operator.BitwiseOr; .)
  | "^"                         (. op = Operator.BitwiseXor; .)
  | "<<"                        (. op = Operator.LeftShift; .)
  | "=="                        (. op = Operator.Equal; .)
  | "!="                        (. op = Operator.NotEqual; .)
  | ">"                         (. op = Operator.GreaterThan; .)
        [                       (. if (la.pos > t.pos+1) Error("UNDEF", la, "no whitespace allowed in right shift operator"); .)
          ">"                   (. op = Operator.RightShift; .)
        ]
  | "<"                         (. op = Operator.LessThan; .)
  | ">="                        (. op = Operator.GreaterThanOrEqual; .)
  | "<="                        (. op = Operator.LessThanOrEqual; .)
.

// ------------------------------------------------------------------------------------------------
// Type parameter declarations for generic types.
//   td: Type parameter owner.
//   paramNode: syntax node holding type parameters.
// ------------------------------------------------------------------------------------------------
TypeParameterList<ITypeParameterOwner td, ITypeParameterHolder paramNode>
  (. 
     TypeParameter tp;
     Token identifier;
     AttributeDecorationNodeCollection attrNodes;
  .)
=                            
  "<"                        
  (. if (paramNode != null) paramNode.SetOpenSign(t); .)
  TypeParameter<out tp, out attrNodes, out identifier>      
  (. 
     td.AddTypeParameter(tp); 
     // :::
     var typeParam = new TypeParameterNode(identifier, attrNodes);
     if (paramNode != null) paramNode.TypeParameters.Add(typeParam);
  .)
  { 
    "," 
    (. var separator= t; .)
    TypeParameter<out tp, out attrNodes, out identifier>      
    (. 
       td.AddTypeParameter(tp); 
       // :::
       typeParam = new TypeParameterContinuationNode(separator, identifier, attrNodes);
       if (paramNode != null) paramNode.TypeParameters.Add(typeParam);
    .)
  } 
  ">"
  (. if (paramNode != null) paramNode.SetCloseSign(t); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a type parameter.
//   tp: Type parameter defined here.
//   attrNodes: Attributes belonging to the type parameter
//   identifier: Token representing the type parameter
// ------------------------------------------------------------------------------------------------
TypeParameter<out TypeParameter tp, out AttributeDecorationNodeCollection attrNodes,
  out Token identifier>
  (. 
     AttributeCollection attrs = new AttributeCollection(); 
     // :::
     attrNodes = new AttributeDecorationNodeCollection();
  .)
=                         
  AttributeDecorations<attrs, attrNodes>
  ident
  (. 
     tp = new TypeParameter(t, this);
     tp.Name = t.val;
     tp.AssignAttributes(attrs);
     // :::
     identifier = t;
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a type argument list.
//   args: List of type arguments defined here.
//   argList: List of type arguments defined here.
// ------------------------------------------------------------------------------------------------
TypeArgumentList<TypeReferenceCollection args, out TypeArgumentListNode argList>  
  (. TypeReference paramType; .)
= (.
      // :::
      argList = null;
  .) 
  // --- We are a bit sloppy here and allow the type arguments to be "empty" everywhere. This 
  // --- results in unbound-type-names. In fact this is only allowed in typeof statements, 
  // --- see ECMA-334: 14.5.11 and 25.5.
  "<"
  (. 
     paramType = TypeReference.EmptyType;
     argList = new TypeArgumentListNode(t);
  .)
  [ 
    (. TypeOrNamespaceNode typeNode; .)
    Type<out paramType, false, out typeNode>           
  ]                              
  (. args.Add(paramType); .) 
  { 
    ","
    (. paramType = TypeReference.EmptyType; .)
    [ 
      (. TypeOrNamespaceNode typeNode; .)
      Type<out paramType, false, out typeNode>           
    ]
    (. args.Add(paramType); .) 
  } 
  ">"
  (. argList.Terminate(t); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a type parameter constraint belonging to a type, a method or a 
// delegate.
//   constraint: Declaration of the constraint.
//   constrNode: Declaration of the constraint.
// ------------------------------------------------------------------------------------------------
TypeParameterConstraintsClause<out TypeParameterConstraint constraint, 
  out TypeParameterConstraintNode constrNode>   
  (. 
     Token start;
     Token identifier;
  .)      
=
  "where"
  (. start = t; .)
  ident                        
  (. 
     constraint = new TypeParameterConstraint(t, this); 
     constraint.Name = t.val;
     // :::
     identifier = t;
  .)
  ":"
  (. 
     TypeReference typeRef; 
     ConstraintElement element = null;
     // :::
     constrNode = new TypeParameterConstraintNode(start, identifier, t);
     ParameterConstraintTagNode tag;
  .)
  TypeParameterConstraintTag<out element, out tag>
  (. 
     constraint.AddConstraintElement(element); 
     // ::: 
     constrNode.ConstraintTags.Add(tag);
  .)
  {
    "," 
    (. var separator = t; .)
    TypeParameterConstraintTag<out element, out tag>
    (. 
       constraint.AddConstraintElement(element); 
       // ::: 
       constrNode.ConstraintTags.Add(new ParameterConstraintTagContinuationNode(separator, tag));
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Obtains a type parameter constraint tag.
//   element: Type parameter constrtaint tag.
//   tag: Type parameter constrtaint tag.
// ------------------------------------------------------------------------------------------------
TypeParameterConstraintTag<out ConstraintElement element, out ParameterConstraintTagNode tag> 
  (.
    element = null;
    tag = null;
  .)
=
  "class"                    
  (. 
     element = new ConstraintElement(t, this, ConstraintClassification.Class); 
     // :::
     tag = new ParameterConstraintTagNode(t);       
  .)
  |
  "struct"                   
  (. 
     element = new ConstraintElement(t, this, ConstraintClassification.Struct); 
     // :::
     tag = new ParameterConstraintTagNode(t);       
  .)
  |
  "new"                      
  (. 
     element = new ConstraintElement(t, this, ConstraintClassification.New); 
     var start = t;
  .)
  "(" 
  (. var openPar = t; .)
  ")" 
  (. tag = new ParameterConstraintTagNode(start, openPar, t); .)
  |
  (. 
     Token elemToken = t; 
     TypeReference typeRef; 
     // :::
     TypeOrNamespaceNode typeNode;
  .)
  ClassType<out typeRef, out typeNode>     
  (. 
     element = new ConstraintElement(elemToken, this, typeRef); 
     // :::
     tag = new ParameterConstraintTagNode(typeNode);       
  .)
.

END CS2.
