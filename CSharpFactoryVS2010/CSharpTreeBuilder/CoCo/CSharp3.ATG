using CSharpTreeBuilder.Ast;

COMPILER CS3

// ================================================================================================
// Scanner description
// ================================================================================================

CHARACTERS

  tab                = '\u0009'. /*  9 = tabulator */
  eol                = '\u000a'. /* 10 = line feed */
  cr                 = '\u000d'. /* 13 = carriage return */
  newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */

  startLetter        = 'A' .. 'Z' + 'a' .. 'z' + '_' + '\u00aa' + '\u00b5' + '\u00ba' + '\u00c0' .. '\u00d6' + '\u00d8' .. '\u00f6' + '\u00f8' .. '\u00ff'.
  partLetter         = '0' .. '9' + 'A' .. 'Z' + 'a' .. 'z' + '_' + '\u00a0' + '\u00aa' + '\u00b5' + '\u00ba' + '\u00c0' .. '\u00d6' + '\u00d8' .. '\u00f6' + '\u00f8' .. '\u00ff'.

  digit              = "0123456789".  
  hexDigit           = digit + "ABCDEFabcdef".
  notDigit           = ANY - digit.

  char               = ANY - "'" - '\\' - newLine.
  verbatimStringChar = ANY - '"'.
  regularStringChar  = ANY - '"' - '\\' - newLine.
  notNewLine         = ANY - newLine .
  ws                 = " " + tab + '\u000b' + '\u000c'. /* Any character with Unicode class Zs */
  blockComCh         = ANY - '*' - '/'.

TOKENS

  // ----------------------------------------------------------------------------------------------

  ident =
    ['@']
    ( startLetter
    | '\\'
      ( 'u' hexDigit hexDigit hexDigit hexDigit
      | 'U' hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
      )
    )
    { partLetter
    | '\\'
      ( 'u' hexDigit hexDigit hexDigit hexDigit
      | 'U' hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
      )
    }.

  // ----------------------------------------------------------------------------------------------

  intCon =
    ( digit {digit} | digit {digit} CONTEXT ("." notDigit)
    | ("0x" | "0X") hexDigit {hexDigit}
    )
    ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"].

  // ----------------------------------------------------------------------------------------------

  realCon =
    "." digit {digit} 
    [("e" | "E") ["+" | "-"] digit {digit}] 
    ["F" | "f" | "D" | "d" | "M" | "m"]
  | digit {digit} 
    ( "." digit {digit} 
      [("e" | "E" ) ["+" | "-"] digit {digit} ] 
      ["F" | "f" | "D" | "d" | "M" | "m"]
    | ("e" | "E") ["+" | "-"] digit {digit}
      ["F" | "f" | "D" | "d" | "M" | "m"]
    | "F" | "f" | "D" | "d" | "M" | "m"
    ).

  // ----------------------------------------------------------------------------------------------

  charCon =
    "'" ( char
        | "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v"
        | "\\x" hexDigit [hexDigit] [hexDigit] [hexDigit]
        | "\\u" hexDigit hexDigit hexDigit hexDigit
        | "\\U" hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
        ) 
    "'".

  // ----------------------------------------------------------------------------------------------

  stringCon =
    "\""  { regularStringChar
          | "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v"
          | "\\x" hexDigit [hexDigit] [hexDigit] [hexDigit]
          | "\\u" hexDigit hexDigit hexDigit hexDigit
          | "\\U" hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
          } 
    "\""
  | "@\"" {verbatimStringChar | "\"\""} "\"".

  // ----------------------------------------------------------------------------------------------
  // Keyword names needed in LL(1) resolvers
  // ----------------------------------------------------------------------------------------------
  
  abstract   = "abstract".
  as         = "as".
  base       = "base".
  bool       = "bool".
  break      = "break".
  byte       = "byte".
  case       = "case".
  catch      = "catch".
  char       = "char".
  checked    = "checked".
  class      = "class".
  const      = "const".
  continue   = "continue".
  decimal    = "decimal".
  default    = "default".
  delegate   = "delegate".
  do         = "do".
  double     = "double".
  else       = "else".
  enum       = "enum".
  event      = "event".
  explicit   = "explicit".
  extern     = "extern".
  false      = "false".
  finally    = "finally".
  fixed      = "fixed".
  float      = "float".
  for        = "for".
  foreach    = "foreach".
  goto       = "goto".
  if         = "if".
  implicit   = "implicit".
  in         = "in".
  int        = "int".
  interface  = "interface".
  internal   = "internal".
  is         = "is".
  lock       = "lock".
  long       = "long".
  namespace  = "namespace".
  new        = "new".
  null       = "null".
  object     = "object".
  operator   = "operator".
  out        = "out".
  override   = "override".
  params     = "params".
  private    = "private".
  protected  = "protected".
  public     = "public".
  readonly   = "readonly".
  ref        = "ref".
  return     = "return".
  sbyte      = "sbyte".
  sealed     = "sealed".
  short      = "short".
  sizeof     = "sizeof".
  stackalloc = "stackalloc".
  static     = "static".
  string     = "string".
  struct     = "struct".
  switch     = "switch".
  this       = "this".
  throw      = "throw".
  true       = "true".
  try        = "try".
  typeof     = "typeof".
  uint       = "uint".
  ulong      = "ulong".
  unchecked  = "unchecked".
  unsafe     = "unsafe".
  ushort     = "ushort".
  usingKW    = "using".
  virtual    = "virtual".
  void       = "void".
  volatile   = "volatile".
  while      = "while".

  // ----------------------------------------------------------------------------------------------
  // Operators and special characters needed in LL(1) resolvers
  // ----------------------------------------------------------------------------------------------

  and        = "&".
  andassgn   = "&=".
  assgn      = "=".
  colon      = ":".
  comma      = ",".
  dec        = "--".
  divassgn   = "/=".
  dot        = ".".
  dblcolon   = "::".
  eq         = "==".
  gt         = ">".
  gteq       = ">=".
  inc        = "++".
  lbrace     = "{".
  lbrack     = "[".
  lpar       = "(".
  lshassgn   = "<<=".
  lt         = "<".
  ltlt       = "<<".
  minus      = "-".
  minusassgn = "-=".
  modassgn   = "%=".
  neq        = "!=".
  not        = "!".
  orassgn    = "|=".
  plus       = "+".
  plusassgn  = "+=".
  question   = "?".
  rbrace     = "}".
  rbrack     = "]".
  rpar       = ")".
  scolon     = ";".
  tilde      = "~".
  times      = "*".
  timesassgn = "*=".
  xorassgn   = "^=".
  larrow     = "=>".

PRAGMAS

  // ----------------------------------------------------------------------------------------------
  // Preprocessor directives.                                               
  // The exact parsing of their syntax is left for later processing.
  // ----------------------------------------------------------------------------------------------

  ppDefine  = "#" {ws} "define" {notNewLine} newLine.     (. AddConditionalDirective(la); .)
  ppUndef   = "#" {ws} "undef" {notNewLine} newLine.      (. RemoveConditionalDirective(la); .)
  ppIf      = "#" {ws} "if" {notNewLine} newLine.         (. IfPragma(la); .)
  ppElif    = "#" {ws} "elif" {notNewLine} newLine.       (. ElifPragma(la); .) 
  ppElse    = "#" {ws} "else" {notNewLine} newLine.       (. ElsePragma(la); .) 
  ppEndif   = "#" {ws} "endif" {notNewLine} newLine.      (. EndifPragma(la); .) 
  ppLine    = "#" {ws} "line" {notNewLine} newLine.       (. LinePragma(la); .) 
  ppError   = "#" {ws} "error" {notNewLine} newLine.      (. ErrorPragma(la); .) 
  ppWarning = "#" {ws} "warning" {notNewLine} newLine.    (. WarningPragma(la); .) 
  ppPragma  = "#" {ws} "pragma" {notNewLine} newLine.     (. PragmaPragma(la); .) 
  ppRegion  = "#" {ws} "region" {notNewLine} newLine.     (. RegionPragma(la); .) 
  ppEndReg  = "#" {ws} "endregion" {notNewLine} newLine.  (. EndRegionPragma(la); .) 

  // ----------------------------------------------------------------------------------------------
  // Comments are handled as special pragmas
  // ----------------------------------------------------------------------------------------------
  
  cBlockCom = "/*" { "/" | blockComCh | "*"{"*"} blockComCh } "*"{"*"}"/". (. HandleBlockComment(la); .)
  cLineCom  = "//" { notNewLine } newLine.                                 (. HandleLineComment(la); .)

IGNORE eol + cr + tab

PRODUCTIONS

// ================================================================================================
// This is the definition of C# 3.0 grammar. The definition contains the grammar syntax definition 
// with the corresponding semantic actions. This is main entry point of the grammar parser.
// ================================================================================================
CS3
=                                                               
  (. 
     CompilationUnitNode.SetStartToken(la); 
  .)
  { IF (IsExternAliasDirective()) ExternAliasDirective<CompilationUnitNode> }
  { UsingDirective<CompilationUnitNode> }
  { IF (IsGlobalAttrTarget()) GlobalAttributes }
  { NamespaceMemberDeclaration<CompilationUnitNode> }
  (. 
     Terminate(CompilationUnitNode); 
  .)
.

// ------------------------------------------------------------------------------------------------
// "extern alias" directive that is used in conjunction with a file or with a namespace
// ------------------------------------------------------------------------------------------------
ExternAliasDirective<NamespaceScopeNode parentNode>
=
  "extern"   
  (. 
     SignRealToken(); 
     var eaNode = New<ExternAliasNode>(t);
  .)
  ident
  (. 
     if (t.val != "alias") Error1003(t, "alias"); 
     eaNode.AliasToken = t;
  .)
  ident      
  (. eaNode.IdentifierToken = t; .)
  ";"
  (. 
     Terminate(eaNode); 
     parentNode.ExternAliasNodes.Add(eaNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// "using" directive that is used in conjunction with a source file or a namespace.
// ------------------------------------------------------------------------------------------------
UsingDirective<NamespaceScopeNode parentNode>
(.
   Token alias = null;
   Token eq = null;
   NamespaceOrTypeNameNode nsNode = null;
.)                                     
=                           
  "using"
  (. 
     SignRealToken();
     Token start = t;
  .)
  [ IF (IsAssignment()) 
    ident                 
    (. alias = t; .)
    "="
    (. eq = t; .)
  ]
  NamespaceOrTypeName<out nsNode> 
  ";"
  (. 
     var node = (alias == null)
       ? parentNode.AddUsing(start, nsNode, t)
       : parentNode.AddUsingWithAlias(start, alias, eq, nsNode, t);
     SetCommentOwner(node);
     Terminate(node);
  .)
.

// ------------------------------------------------------------------------------------------------
// Global attributes belonging to a file. This element accepts only attributes with "assembly" or 
// "module" scope. All global attributes are assigned to the current source file node, so this
// production does not have any input parameter.
// ------------------------------------------------------------------------------------------------
GlobalAttributes
=
  (. AttributeDecorationNode globAttrNode = null; .)
  "["
  (. 
     SignRealToken();
     globAttrNode = new AttributeDecorationNode(t);
  .)
  ident                        
  (. globAttrNode.TargetToken = t; .) 
  ":"
  (. var separator = t; .)
  (. AttributeNode attrNode; .)
  Attribute<out attrNode>
  (. globAttrNode.Attributes.Add(separator, attrNode); .)
  { 
    IF (NotFinalComma()) ","   
    (. separator = t; .)
    Attribute<out attrNode> 
    (. globAttrNode.Attributes.Add(separator, attrNode); .)
  } 
  [ 
    ","
    (. globAttrNode.OrphanSeparator = t; .) 
  ]
  "]"                          
  (. 
     Terminate(globAttrNode);
     CompilationUnitNode.GlobalAttributes.Add(globAttrNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a namespace member (type or nested namespace).
// ------------------------------------------------------------------------------------------------
NamespaceMemberDeclaration<NamespaceScopeNode parentNode>  
=
  "namespace"    
  (. 
     SignRealToken();
     Token startToken = t; 
     var nsDecl = new NamespaceDeclarationNode(parentNode, t);
     SetCommentOwner(nsDecl);
  .)
  ident
  (. nsDecl.NameTags.Add(t); .)
  {              
    "."
    (. var sepToken = t; .)
    ident
    (. nsDecl.NameTags.Add(sepToken, t); .)
  } 
  "{"
  (. nsDecl.OpenBracket = t; .)
  { IF (IsExternAliasDirective()) ExternAliasDirective<nsDecl> } 
  { UsingDirective<nsDecl> } 
  { NamespaceMemberDeclaration<nsDecl> } 
  "}"
  (. 
     nsDecl.CloseBracket = t;
     Terminate(nsDecl);
  .)
  [ 
    ";"
    (. Terminate(nsDecl); .)
  ]
  (.
     parentNode.NamespaceDeclarations.Add(nsDecl);
     parentNode.InScopeDeclarations.Add(nsDecl);
  .)
  | 
    (. 
       var mod = new ModifierNodeCollection();
       var attrNodes = new AttributeDecorationNodeCollection();
    .)  
    AttributeDecorations<attrNodes>
    ModifierList<mod> 
    (. TypeDeclarationNode typeDecl; .)
    TypeDeclaration<null, out typeDecl>
    (.
       typeDecl.AttributeDecorations = attrNodes;
       typeDecl.Modifiers = mod;
       typeDecl.DeclaringNamespace = parentNode;
       parentNode.TypeDeclarations.Add(typeDecl);
       parentNode.InScopeDeclarations.Add(typeDecl);
    .)
.

// ------------------------------------------------------------------------------------------------
// Type declaration within a file or a namespace.
// ------------------------------------------------------------------------------------------------
TypeDeclaration<TypeDeclarationNode declaringType, out TypeDeclarationNode typeDecl>            
= 
  (. 
     typeDecl = null; 
     Token partialToken = null;
  .)
  (   
    (
      [
        //IF (la.kind == _ident && la.val == "partial")
        ident
        (. partialToken = t; .)
      ]
      ( 
        ClassDeclaration<out typeDecl> 
      | StructDeclaration<out typeDecl> 
      | InterfaceDeclaration<out typeDecl>
      )
    )
    | EnumDeclaration<out typeDecl> 
    | DelegateDeclaration<out typeDecl>
  )
  (. 
     if (typeDecl != null)
     {
       typeDecl.PartialToken = partialToken;
       typeDecl.DeclaringType = declaringType;
       Terminate(typeDecl);
     }
  .)                               
.

// ------------------------------------------------------------------------------------------------
// Class declaration within a file, a namespace or a type declaration.
// ------------------------------------------------------------------------------------------------
ClassDeclaration<out TypeDeclarationNode typeDecl>
=
  "class"                                            
  (. var start = t; .)
  ident    
  (. 
     var classDecl = new ClassDeclarationNode(start, t);
     SetCommentOwner(classDecl);
     typeDecl = classDecl;
  .)
  [ TypeParameterList<typeDecl> ] 
  [ BaseTypeList<typeDecl> ]
  {    
    (. TypeParameterConstraintNode constrNode; .)
    TypeParameterConstraintsClause<out constrNode>   
    (. typeDecl.TypeParameterConstraints.Add(constrNode); .)
  } ClassBody<classDecl>
  (. Terminate(typeDecl); .)
  [ 
    ";" 
    (. Terminate(typeDecl); .)
  ]                                                       
.

// ------------------------------------------------------------------------------------------------
// Base type and interface declaration of a class, struct or interface.
// ------------------------------------------------------------------------------------------------
BaseTypeList<TypeDeclarationNode typeDecl>
=
  (. TypeNode typeNode; .)
  ":"
  (. typeDecl.ColonToken = t; .)                        
  ClassType<out typeNode>     
  (. 
     typeDecl.BaseTypes.Add(typeNode);
     SetCommentOwner(typeNode);
  .)
  { 
    ","  
    (. var separator = t; .)
    ClassType<out typeNode>    
    (. 
       typeNode.SeparatorToken = separator;
       typeDecl.BaseTypes.Add(typeNode); 
       SetCommentOwner(typeNode);
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Body declaration of a class.
// ------------------------------------------------------------------------------------------------
ClassBody<ClassDeclarationNode typeDecl>
=
  "{" 
  (. typeDecl.OpenBrace = t; .)
  {
    (. var attrNodes = new AttributeDecorationNodeCollection(); .)
    AttributeDecorations<attrNodes>
    (. var mod = new ModifierNodeCollection(); .)                          
    ModifierList<mod>
    (. MemberDeclarationNode memNode; .)
    ClassMemberDeclaration<attrNodes, mod, typeDecl, out memNode>
    (. 
       if (memNode != null) 
       {
         memNode.AttributeDecorations = attrNodes;
         memNode.Modifiers = mod;
         typeDecl.MemberDeclarations.Add(memNode); 
       }
    .)
  }
  "}"
  (. typeDecl.CloseBrace = t; .)
.

// ------------------------------------------------------------------------------------------------
// Structure declaration within a file, a namespace or a type declaration.
// ------------------------------------------------------------------------------------------------
StructDeclaration<out TypeDeclarationNode typeDecl>
=
  "struct"
  (. var start = t; .)
  ident
  (. 
     var structDecl = new StructDeclarationNode(start, t);
     SetCommentOwner(structDecl);
     typeDecl = structDecl;
  .)
  [ TypeParameterList<typeDecl> ]
  [ BaseTypeList<typeDecl> ]
  {                                                
    (. TypeParameterConstraintNode constrNode; .)
    TypeParameterConstraintsClause<out constrNode> 
    (. typeDecl.TypeParameterConstraints.Add(constrNode); .)
  } 
  StructBody<structDecl>
  (. Terminate(typeDecl); .)
  [ 
    ";" 
    (. Terminate(typeDecl); .)
  ]                                                       
.

// ------------------------------------------------------------------------------------------------
// Body declaration of a structure.
// ------------------------------------------------------------------------------------------------
StructBody<StructDeclarationNode typeDecl>
=
  "{" 
  (. typeDecl.OpenBrace = t; .)
  {
    (. var attrNodes = new AttributeDecorationNodeCollection(); .)
    AttributeDecorations<attrNodes>
    (. var mod = new ModifierNodeCollection(); .)                             
    ModifierList<mod>
    (. MemberDeclarationNode memNode; .)
    StructMemberDeclaration<attrNodes, mod, typeDecl, out memNode>
    (. 
       if (memNode != null) 
       {
         memNode.AttributeDecorations = attrNodes;
         memNode.Modifiers = mod;
         typeDecl.MemberDeclarations.Add(memNode); 
       }
    .)
  }
  "}"   
  (. typeDecl.CloseBrace = t; .)
.

// ------------------------------------------------------------------------------------------------
// Enumerated type declaration within a file, a namespace or a type declaration.
// ------------------------------------------------------------------------------------------------
EnumDeclaration<out TypeDeclarationNode typeDecl>
=
  "enum"                         
  (. var start = t; .)
  ident                          
  (. 
     var enumDecl = new EnumDeclarationNode(start, t);
     SetCommentOwner(enumDecl);
     typeDecl = enumDecl;
  .)
  [ 
    ":"                          
    (. TypeNode typeNode = null; .)
    ( ClassType<out typeNode> | IntegralType<out typeNode> )
    (. enumDecl.EnumBase = typeNode; .)
  ] 
  EnumBody<enumDecl>                   
  (. Terminate(typeDecl); .)
  [ 
    ";"                          
    (. Terminate(typeDecl); .)
  ]                                                       
.

// ------------------------------------------------------------------------------------------------
// Body declaration of an enumerated type.
// ------------------------------------------------------------------------------------------------
EnumBody<EnumDeclarationNode typeDecl>
=
  "{" 
  (. typeDecl.OpenBrace = t; .)
  [ 
    (. EnumValueNode valNode; .)
    EnumMemberDeclaration<out valNode> 
    (. typeDecl.Values.Add(valNode); .)
    { 
      IF (NotFinalComma())  
      "," 
      (. var separator = t; .)
      SYNC EnumMemberDeclaration<out valNode>
      (. typeDecl.Values.Add(separator, valNode); .)
    } 
    [ 
      "," 
      (. typeDecl.OrphanSeparator = t; .)
    ] 
  ] 
  SYNC "}"
  (. 
     typeDecl.CloseBrace = t; 
     Terminate(typeDecl);
  .)
.

// ------------------------------------------------------------------------------------------------
// Enumeration value declaration within an enumeration type.
// ------------------------------------------------------------------------------------------------
EnumMemberDeclaration<out EnumValueNode valNode>  
=                             
  (. 
     valNode = null;
     var attrNodes = new AttributeDecorationNodeCollection();
  .)
  AttributeDecorations<attrNodes>
  ident                      
  (. 
     valNode = new EnumValueNode(t);
     SetCommentOwner(valNode);
     valNode.AttributeDecorations = attrNodes;
  .)
  [ 
    "=" 
    (.
       valNode.EqualToken = t;
       ExpressionNode exprNode;
    .)
    Expression<out exprNode> 
    (. valNode.Expression = exprNode; .)
  ]     
  (. Terminate(valNode); .)
.

// ------------------------------------------------------------------------------------------------
// Delegate type declaration within a file, a namespace or a type declaration.
// ------------------------------------------------------------------------------------------------
DelegateDeclaration<out TypeDeclarationNode typeDecl>
=
  "delegate"                                       
  (. 
     var start = t;
     TypeNode typeNode;
  .)
  Type<out typeNode>
  ident
  (. 
     var ddNode = new DelegateDeclarationNode(start, t);
     SetCommentOwner(ddNode);
     typeDecl = ddNode;
     ddNode.Type = typeNode;
  .)
  [ TypeParameterList<typeDecl> ]
  "(" 
  [ FormalParameterList<ddNode.FormalParameters> ] 
  ")"
  (. Terminate(ddNode.FormalParameters); .)
  {                                                
    (. TypeParameterConstraintNode constrNode; .)
    TypeParameterConstraintsClause<out constrNode> 
    (. typeDecl.TypeParameterConstraints.Add(constrNode); .)
  } 
  ";"                                                         
  (. Terminate(typeDecl); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a class member.
// ------------------------------------------------------------------------------------------------
ClassMemberDeclaration<AttributeDecorationNodeCollection attrNodes, ModifierNodeCollection mod,
  TypeDeclarationNode typeDecl, out MemberDeclarationNode memNode>
  (. memNode = null; .)
=
  StructMemberDeclaration<attrNodes, mod, typeDecl, out memNode>
  | 
    "~" 
    (. 
       var finNode = new DestructorDeclarationNode(t);
       SetCommentOwner(finNode);
       memNode = finNode;
    .)
    ident   
    (. finNode.IdentifierToken = t; .)
    "(" 
    ")" 
    (. Terminate(finNode.FormalParameters); .)
    ( 
      (. BlockStatementNode blockNode; .)
      Block<out blockNode> 
      (. finNode.Body = blockNode; .)
    | ";"
      (. finNode.ClosingSemicolon = t; .) 
    )
    (. Terminate(memNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a structure member.
// ------------------------------------------------------------------------------------------------
StructMemberDeclaration<AttributeDecorationNodeCollection attrNodes, ModifierNodeCollection mod,
  TypeDeclarationNode typeDecl, out MemberDeclarationNode memNode>        
=                                             
  (. memNode = null; .)
  (                                                                          
    ConstMemberDeclaration<out memNode> 
  | EventDeclaration<out memNode> 
  | IF (la.kind == _ident && Peek(1).kind == _lpar)                         
      ConstructorDeclaration<out memNode> 
  | 
    // --- Partial method declaration (the resolver also makes sure that the return type is void)
    IF (IsPartialMethod())
    // --- At this point ident is "partial"
    ident
    (. 
       var partialToken = t; 
       TypeNode typeNode; 
    .)
    Type<out typeNode>
    (. NamespaceOrTypeNameNode nameNode; .)
    MemberName<out nameNode>
    (.
       // BUGBUG: the following line seems incorrect becuase partialToken can be null, so startToken won't be set
       var metNode = new MethodDeclarationNode(partialToken);
       
       metNode.PartialToken = partialToken;
       SetCommentOwner(metNode);
       metNode.Type = typeNode;
       metNode.MemberName = nameNode;
       memNode = metNode;
    .)
    MethodDeclaration<metNode>
  | 
    (. TypeNode typeNode; .)
    Type<out typeNode>
    ( 
        // --- Overloadable operator declaration
        (. 
           var opNode = new OperatorDeclarationNode(typeNode.StartToken); 
           SetCommentOwner(opNode);
           opNode.Type = typeNode;
           memNode = opNode;
        .)
        OperatorDeclaration<opNode>
      | 
        // --- Field declaration
        IF (IsFieldDecl()) 
        (. 
           var fiNode = new FieldDeclarationNode(typeNode.StartToken); 
           SetCommentOwner(fiNode);
           fiNode.Type = typeNode;
           memNode = fiNode;
        .)
        FieldMemberDeclarators<fiNode> 
        ";"
        (. Terminate(memNode); .)
      |                                  
        // --- Members than can be used in explicit interface implementations:
        // --- Property declaration        
        (. NamespaceOrTypeNameNode nameNode; .)
        MemberName<out nameNode>
        ( 
          (. 
             var propNode = new PropertyDeclarationNode(typeNode.StartToken);
             SetCommentOwner(propNode);
             propNode.Type = typeNode; 
             propNode.MemberName = nameNode;
             memNode = propNode;
          .)
          PropertyDeclaration<propNode>
        | 
          // --- Explicit indexer declaration
          (.
             var indNode = new IndexerDeclarationNode(typeNode.StartToken);
             SetCommentOwner(indNode);
             indNode.Type = typeNode;
             indNode.MemberName = nameNode;
             memNode = indNode;
          .)
          "."
          (. indNode.MemberNameSeparator = t; .)
          IndexerDeclaration<indNode>
        |
          // --- Method declaration 
          (.
             var metNode = new MethodDeclarationNode(typeNode.StartToken);
             SetCommentOwner(metNode);
             metNode.Type = typeNode;
             metNode.MemberName = nameNode;
             memNode = metNode;
          .)
          MethodDeclaration<metNode>
        )
      | 
        // --- Simple indexer declaration
        (. 
           var indNode = new IndexerDeclarationNode(typeNode.StartToken);
           SetCommentOwner(indNode);
           indNode.Type = typeNode;
           memNode = indNode;
        .)
        IndexerDeclaration<indNode>
    )
    | CastOperatorDeclaration<out memNode>
    |                                           
      // --- Nested type declaration    
      (. TypeDeclarationNode nestedTypeNode; .)
      TypeDeclaration<typeDecl, out nestedTypeNode> 
      (. 
         nestedTypeNode.AttributeDecorations = attrNodes;
         nestedTypeNode.Modifiers = mod;
         nestedTypeNode.DeclaringNamespace = typeDecl.DeclaringNamespace;
         nestedTypeNode.DeclaringType = typeDecl;
         typeDecl.NestedDeclarations.Add(nestedTypeNode);
         typeDecl.NestedTypes.Add(nestedTypeNode);
      .)
  )
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "const" member.
// ------------------------------------------------------------------------------------------------
ConstMemberDeclaration<out MemberDeclarationNode memNode>
=                                    
  (. memNode = null; .)
  "const"
  (. 
     var constNode = new ConstDeclarationNode(t);
     SetCommentOwner(constNode);
     memNode = constNode;
     TypeNode typeNode;
  .)
  Type<out typeNode>
  (. 
     memNode.Type = typeNode; 
     ConstTagNode tagNode;
  .)
  SingleConstMember<out tagNode>
  (. constNode.ConstTags.Add(tagNode); .)
  {
    "," 
    (. var separator = t; .)
    SingleConstMember<out tagNode> 
    (. constNode.ConstTags.Add(separator, tagNode); .)
  } 
  ";"
  (. Terminate(memNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a single "const" member.
// ------------------------------------------------------------------------------------------------
SingleConstMember<out ConstTagNode tagNode>
=
  ident
  (. 
     tagNode = new ConstTagNode(t); 
     SetCommentOwner(tagNode);
  .)
  "="
  (. 
     tagNode.EqualToken = t;
     ExpressionNode exprNode;
  .)
  Expression<out exprNode>
  (. 
     tagNode.Expression = exprNode;
     Terminate(tagNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a event member.
// ------------------------------------------------------------------------------------------------
EventDeclaration<out MemberDeclarationNode memNode>
  (. memNode = null; .)
=
  (. TypeNode typeNode; .)
  "event"
  (. var eventToken = t; .)
  Type<out typeNode>
  ( 
    IF (IsFieldDecl()) 
    (. 
       var fiNode = new FieldDeclarationNode(eventToken); 
       SetCommentOwner(fiNode);
       memNode = fiNode;
       fiNode.Type = typeNode;
    .)
    FieldMemberDeclarators<fiNode> 
    ";"
    (. Terminate(fiNode); .)
  |                              
    (. 
       var evpNode = new EventPropertyDeclarationNode(t);
       SetCommentOwner(evpNode);
       memNode = evpNode;
       evpNode.Type = typeNode;
       NamespaceOrTypeNameNode memberName = null;
    .)
    MemberName<out memberName> 
    (. evpNode.MemberName = memberName; .)
    "{"
    (. evpNode.OpenBrace = t; .)
    EventAccessorDeclarations<evpNode>
    "}"
    (. 
       evpNode.CloseBrace = t;
       Terminate(evpNode);
    .)
  )
.

// ------------------------------------------------------------------------------------------------
// Declaration of a constructor member.
// ------------------------------------------------------------------------------------------------
ConstructorDeclaration<out MemberDeclarationNode memNode>
= 
  (. memNode = null; .)
  ident
  (. 
     var cstNode = new ConstructorDeclarationNode(t);
     SetCommentOwner(cstNode);
     memNode = cstNode;
  .)
  "(" 
  [                                    
    FormalParameterList<cstNode.FormalParameters>
  ] 
  ")" 
  (. Terminate(cstNode.FormalParameters); .)
  [                                        
    ":" 
    (. 
       Token colonToken = t;
       ConstructorInitializerNode initializerNode = null;
    .)
    ( "base"          
      (. 
         initializerNode = new BaseConstructorInitializerNode(colonToken);
         initializerNode.BaseOrThisToken = t;
         SetCommentOwner(initializerNode);
      .)
    | "this"              
      (. 
         initializerNode = new ThisConstructorInitializerNode(colonToken); 
         initializerNode.BaseOrThisToken = t;
         SetCommentOwner(initializerNode);
      .)
    ) 
    "("
    CurrentArgumentList<initializerNode.Arguments>
    ")"
    (.
       Terminate(initializerNode);
       cstNode.Initializer = initializerNode;
    .)
  ] 
  ( 
    (. BlockStatementNode blockNode; .)
    Block<out blockNode>
    (. cstNode.Body = blockNode; .) 
  | ";" 
    (. cstNode.ClosingSemicolon = t; .)
  )   
  (. Terminate(memNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a property member.
// ------------------------------------------------------------------------------------------------
PropertyDeclaration<PropertyDeclarationNodeBase propNode>
=                  
  "{" 
  (. propNode.OpenBrace = t; .)
  AccessorDeclarations<propNode> 
  "}"             
  (. 
     propNode.CloseBrace = t;
     Terminate(propNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of an indexer member.
// ------------------------------------------------------------------------------------------------
IndexerDeclaration<IndexerDeclarationNode indNode>
=
  "this"
  (. indNode.ThisToken = t; .)
  "[" 
  [ FormalParameterList<indNode.FormalParameters> ] 
  "]" 
  (. Terminate(indNode.FormalParameters); .)
  "{" 
  (. indNode.OpenBrace = t; .)
      AccessorDeclarations<indNode> 
  "}"
  (. indNode.CloseBrace = t; .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a method member.
// ------------------------------------------------------------------------------------------------
MethodDeclaration<MethodDeclarationNode metNode>
=                                                    
  [ TypeParameterList<metNode> ]
  "(" 
  [ FormalParameterList<metNode.FormalParameters> ] 
  ")"
  (. Terminate(metNode.FormalParameters); .)
  {                                                 
    (. TypeParameterConstraintNode constrNode; .)
    TypeParameterConstraintsClause<out constrNode>  
    (. metNode.TypeParameterConstraints.Add(constrNode); .)
  } 
  ( 
    (. BlockStatementNode blockNode; .)
    Block<out blockNode>
    (. metNode.Body = blockNode; .)
  | ";"
    (. metNode.ClosingSemicolon = t; .)
  )
  (. Terminate(metNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a cast operator member.
// ------------------------------------------------------------------------------------------------
CastOperatorDeclaration<out MemberDeclarationNode memNode>
  (. memNode = null; .)
=
  ( 
    "implicit"                        
  | "explicit"
  )
  (. 
     var copNode = new CastOperatorDeclarationNode(t); 
     SetCommentOwner(copNode);
     memNode = copNode;
  .)
  "operator"                        
  (. 
     copNode.OperatorToken = t; 
     TypeNode typeNode; 
  .)
  Type<out typeNode>
  (. copNode.Type = typeNode; .)
  "("   
  [ FormalParameterList<copNode.FormalParameters> ]   
  ")"
  (. Terminate(copNode.FormalParameters); .)
  ( 
    (. BlockStatementNode blockNode; .)
    Block<out blockNode>
    (. copNode.Body = blockNode; .)
  | 
    ";" 
    (. copNode.ClosingSemicolon = t; .)
  )
  (. Terminate(memNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of an overloaded operator member.
// ------------------------------------------------------------------------------------------------
OperatorDeclaration<OperatorDeclarationNode opNode>
=
  "operator" 
  (. opNode.OperatorToken = t; .)
  OverloadableOp<opNode>
  "("
  [ FormalParameterList<opNode.FormalParameters> ]
  ")"
  (. Terminate(opNode.FormalParameters); .)
  ( 
    (. BlockStatementNode blockNode; .)
    Block<out blockNode>
    (. opNode.Body = blockNode; .)
  | 
    ";" 
    (. opNode.ClosingSemicolon = t; .)
  )
.

// ------------------------------------------------------------------------------------------------
// Interface declaration within a file, a namespace or a type declaration.
// ------------------------------------------------------------------------------------------------
InterfaceDeclaration<out TypeDeclarationNode typeDecl>
=
  "interface"       
  (. var start = t; .)
  ident            
  (. 
     var intfDecl = new InterfaceDeclarationNode(start, t);
     SetCommentOwner(intfDecl);
     typeDecl = intfDecl;
  .)
  [ TypeParameterList<typeDecl> ]
  [ BaseTypeList<typeDecl> ]
  {                                                   
    (. TypeParameterConstraintNode constrNode; .)
    TypeParameterConstraintsClause<out constrNode>    
    (. typeDecl.TypeParameterConstraints.Add(constrNode); .)
  }
  "{" 
  (. intfDecl.OpenBrace = t; .)
  { InterfaceMemberDeclaration<intfDecl> } 
  "}" 
  (. 
     intfDecl.CloseBrace = t;
     Terminate(typeDecl);
  .)
  [ 
    ";" 
    (. Terminate(typeDecl); .)
  ]                                                       
.

// ------------------------------------------------------------------------------------------------
// Declaration of an interface member.
// ------------------------------------------------------------------------------------------------
InterfaceMemberDeclaration<InterfaceDeclarationNode typeDecl>
=                              
  (. 
     var mod = new ModifierNodeCollection();
     var attrNodes = new AttributeDecorationNodeCollection();
     Token identifier;
     MemberDeclarationNode memNode = null;
  .)
  AttributeDecorations<attrNodes>
  ModifierList<mod>
  ( 
    (. TypeNode typeNode; .)
    Type<out typeNode>
    (                          
      ident                   
      (. identifier = t; .)
      ( 
        (.
           var metNode = new MethodDeclarationNode(typeNode.StartToken);
           SetCommentOwner(metNode);
           metNode.Type = typeNode;
           metNode.MemberName = NamespaceOrTypeNameNode.CreateSimpleName(identifier);
           memNode = metNode;
        .)
        MethodDeclaration<metNode>        
      | // --- Interface property
        (. 
           var propNode = new PropertyDeclarationNode(typeNode.StartToken);
           SetCommentOwner(propNode);
           propNode.Type = typeNode;
           propNode.MemberName = NamespaceOrTypeNameNode.CreateSimpleName(identifier);
           memNode = propNode;
        .)
        "{" 
        (. propNode.OpenBrace = t; .)
        InterfaceAccessors<propNode>
        "}" 
        (. 
           propNode.CloseBrace = t; 
           Terminate(memNode);
        .)
      )
    |  
      "this" 
      (. 
         var indNode = new IndexerDeclarationNode(typeNode.StartToken);
         SetCommentOwner(indNode);
         indNode.Type = typeNode;
         indNode.ThisToken = t;
         memNode = indNode;
      .)
      "[" 
      [ FormalParameterList<indNode.FormalParameters> ] 
      "]" 
      (. Terminate(indNode.FormalParameters); .)
      "{" 
      (. indNode.OpenBrace = t; .)
      InterfaceAccessors<indNode>
      "}" 
      (. 
         indNode.CloseBrace = t; 
         Terminate(indNode);
      .)
    )
  | InterfaceEventDeclaration<out memNode>
  ) 
  (.
     if (memNode != null) 
     {
       memNode.AttributeDecorations = attrNodes;
       memNode.Modifiers = mod;
       typeDecl.MemberDeclarations.Add(memNode);
     }
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of an interface event member.
// ------------------------------------------------------------------------------------------------
InterfaceEventDeclaration<out MemberDeclarationNode memNode>
=
  "event" 
  (. 
     var ieNode = new InterfaceEventDeclarationNode(t);
     SetCommentOwner(ieNode);
     memNode = ieNode;
  .)
  (. TypeNode typeNode; .)
  Type<out typeNode>
  (. ieNode.Type = typeNode; .)
  ident 
  (. ieNode.IdentifierToken = t; .)
  ";"
  (. Terminate(memNode); .)
.

// ------------------------------------------------------------------------------------------------
// Local variable declaration within a block.
// ------------------------------------------------------------------------------------------------
LocalVariableDeclaration<out LocalVariableNode varNode> 
=
  (. 
     TypeNode typeNode = null;
     varNode = null;
  .)
  (
    IF (IsVar())
    ident
    (. typeNode = TypeNode.CreateTypeNode(t); .)
  |
    Type<out typeNode>
  )
  (. 
     varNode = new LocalVariableNode(typeNode); 
     SetCommentOwner(varNode);
     LocalVariableTagNode varTagNode;
  .)
  LocalVariableDeclarator<out varTagNode>
  (. if (varNode != null) varNode.VariableTags.Add(varTagNode); .)
  { 
    "," 
    (. var separator = t; .)
    LocalVariableDeclarator<out varTagNode> 
    (. 
       if (varNode != null) varNode.VariableTags.Add(separator, varTagNode); 
    .)
  }
  (. Terminate(varNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declares a local variable within a block with the specified type.
// ------------------------------------------------------------------------------------------------
LocalVariableDeclarator<out LocalVariableTagNode varDeclNode>
= 
  ident 
  (. 
     varDeclNode = new LocalVariableTagNode(t); 
     SetCommentOwner(varDeclNode);
  .)       
  [
    "="
    (. var start = t; .) 
    (   
      (. VariableInitializerNode varInitNode; .)
      VariableInitializer<out varInitNode> 
      (. varDeclNode.Initializer = varInitNode; .)
    | 
      "stackalloc" 
      (. 
         var stcInitNode = new StackAllocInitializerNode(start);
         SetCommentOwner(stcInitNode);
         varDeclNode.Initializer = stcInitNode;
         stcInitNode.StackAllocToken = t;
      .)
      (. TypeNode typeNode; .)
      Type<out typeNode> 
      (. stcInitNode.Type = typeNode; .)
      "[" 
      (. 
         stcInitNode.OpenSquareToken = t;
         ExpressionNode exprNode; 
      .)
      Expression<out exprNode> 
      (. stcInitNode.Expression = exprNode; .)
      "]" 
      (. 
         stcInitNode.CloseSquareToken = t;
         Terminate(stcInitNode);
      .)
    )
  ]
  (. Terminate(varDeclNode); .)
. 

// ------------------------------------------------------------------------------------------------
// Creates an initializer.
// ------------------------------------------------------------------------------------------------
VariableInitializer<out VariableInitializerNode initNode> 
  (. 
     initNode = null; 
     ExpressionNode exprNode; 
  .)
= 
    Expression<out exprNode>  
    (. 
       var exprInitNode = new ExpressionInitializerNode(exprNode);
       SetCommentOwner(exprInitNode);
       initNode = exprInitNode;
    .)
  | 
    (. ArrayInitializerNode arrInitNode; .)
    ArrayInitializer<out arrInitNode> 
    (. initNode = arrInitNode; .)
.

// -----------------------------------------------------------------------------------------------
// Creates an array initializer.
// -----------------------------------------------------------------------------------------------
ArrayInitializer<out ArrayInitializerNode initNode> 
= 
  (. initNode = null; .)
  "{"
  (. 
     initNode = new ArrayInitializerNode(t); 
     SetCommentOwner(initNode);
  .)
  [ 
    (. VariableInitializerNode varInitNode; .)
    VariableInitializer<out varInitNode> 
    (. 
       initNode.VariableInitializers.Add(varInitNode);
    .)
    {
      IF (NotFinalComma()) 
      ","
      (. var separator = t; .)
      VariableInitializer<out varInitNode> 
      (.
        varInitNode.SeparatorToken = t; 
        initNode.VariableInitializers.Add(varInitNode);
      .)
    } 
    [ 
      ","
      (. initNode.OrphanComma = t; .)
    ] 
  ] 
  "}" 
  (. Terminate(initNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines an item on the list of formal parameters.
// ------------------------------------------------------------------------------------------------
FormalParameterTag<out FormalParameterNode parNode>
=
  (. 
     var attrNodes = new AttributeDecorationNodeCollection();
     parNode = null;
     var modifier = FormalParameterModifier.In;
     Token start = null;
  .)
  AttributeDecorations<attrNodes>                                       
  [ 
    (
      "ref"                            
      (. modifier = FormalParameterModifier.Ref; .) 
    | "out"                          
      (. modifier = FormalParameterModifier.Out; .)
    | "this"                         
      (. modifier = FormalParameterModifier.This; .)
    | "params"                    
      (. modifier = FormalParameterModifier.Params; .)
    )
    (. start = t; .)
  ] 
  (. TypeNode typeNode; .)
  Type<out typeNode>
  (. if (start == null) start = typeNode.StartToken; .)
  ident                              
  (. 
     parNode = new FormalParameterNode(start);
     SetCommentOwner(parNode);
     parNode.AttributeDecorations = attrNodes;
     parNode.Modifier = modifier;
     parNode.IdentifierToken = t;
     parNode.Type = typeNode;
     Terminate(parNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a formal parameter list
//   parsNode List holding the formal parameter declarations.
// ------------------------------------------------------------------------------------------------
FormalParameterList<FormalParameterNodeCollection parsNode>  
  (. FormalParameterNode node; .)                                                
=                                    
  FormalParameterTag<out node>
  (. if (parsNode != null && node != null) parsNode.Add(node); .)
  {
    ","
    (. var separator = t; .)
    FormalParameterTag<out node>
    (. 
       if (parsNode != null && node != null) 
         parsNode.Add(separator, node); 
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Declaration of a current parameter list
// ------------------------------------------------------------------------------------------------
CurrentArgumentList<ArgumentNodeCollection argNodes> 
=
  [
    (. ArgumentNode argNode; .)
    CurrentArgumentItem<out argNode>
    (. if (argNodes != null) argNodes.Add(argNode); .)
    {
      ","
      (. var separator = t; .)
      CurrentArgumentItem<out argNode>
      (. if (argNodes != null) argNodes.Add(separator, argNode); .)
    }
  ]
.

// ------------------------------------------------------------------------------------------------
// Declaration of an item of the current parameter list
// ------------------------------------------------------------------------------------------------
CurrentArgumentItem<out ArgumentNode argNode> 
=
  (. 
     ExpressionNode exprNode; 
     Token argKind = null;
  .)
  [           
    ( "ref" | "out" )
    (. argKind = t; .)
  ]           
  Expression<out exprNode>
  (. 
     argNode = new ArgumentNode(argKind == null ? 
       (exprNode == null ? t : exprNode.StartToken) : argKind);
     SetCommentOwner(argNode);
     argNode.KindToken = argKind;
     argNode.Expression = exprNode;
     Terminate(argNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of property accessors.
// ------------------------------------------------------------------------------------------------
AccessorDeclarations<PropertyDeclarationNodeBase propNode>
= 
  (. var attrNodes = new AttributeDecorationNodeCollection(); .)
  AttributeDecorations<attrNodes>
  (. var mod = new ModifierNodeCollection(); .)
  ModifierList<mod>                    
  ident   
  (.
     var accNode = new AccessorNode(t);
     SetCommentOwner(accNode);
     accNode.AttributeDecorations = attrNodes;
     accNode.Modifiers = mod;
     propNode.FirstAccessor = accNode;
     BlockStatementNode blockNode;
  .)
  (
    Block<out blockNode>
    (. accNode.Body = blockNode; .)
  | ";"                               
    (. accNode.ClosingSemicolon = t; .)
  )                                   
  (. Terminate(accNode); .)
  [                                   
    (. attrNodes = new AttributeDecorationNodeCollection(); .)
    AttributeDecorations<attrNodes>
    (. mod = new ModifierNodeCollection(); .)
    ModifierList<mod>                  
    ident 
    (.
       accNode = new AccessorNode(t);
       SetCommentOwner(accNode);
       accNode.AttributeDecorations = attrNodes;
       accNode.Modifiers = mod;
       propNode.SecondAccessor = accNode;
    .)
    (
      Block<out blockNode>
      (. accNode.Body = blockNode; .)
    | ";"
      (. accNode.ClosingSemicolon = t; .)
    ) 
    (. Terminate(accNode); .)
  ]
.

// ------------------------------------------------------------------------------------------------
// Declaration of event property accessors.
// ------------------------------------------------------------------------------------------------
EventAccessorDeclarations<PropertyDeclarationNodeBase propNode>                                                 
= 
  (. var attrNodes = new AttributeDecorationNodeCollection(); .)
  AttributeDecorations<attrNodes>
  (. var mod = new ModifierNodeCollection(); .)
  ModifierList<mod>                    
  ident       
  (. 
     var accNode = new AccessorNode(t);
     SetCommentOwner(accNode);
     accNode.AttributeDecorations = attrNodes;
     accNode.Modifiers = mod;
     BlockStatementNode blockNode; 
  .)
  Block<out blockNode>
  (. 
     accNode.Body = blockNode;
     Terminate(accNode);
     propNode.FirstAccessor = accNode;
  .)
  [
    (. attrNodes = new AttributeDecorationNodeCollection(); .)
    AttributeDecorations<attrNodes>
    (. mod = new ModifierNodeCollection(); .)
    ModifierList<mod>                      
    ident     
    (. 
       accNode = new AccessorNode(t);
       SetCommentOwner(accNode);
       accNode.AttributeDecorations = attrNodes;
       accNode.Modifiers = mod;
    .)
    Block<out blockNode>
    (. 
       accNode.Body = blockNode;
       Terminate(accNode);
       propNode.SecondAccessor = accNode;
    .)
  ]
.

// ------------------------------------------------------------------------------------------------
// Declaration of interface property/indexer accessors.
// ------------------------------------------------------------------------------------------------
InterfaceAccessors<PropertyDeclarationNodeBase propNode>
= 
  (. var attrNodes = new AttributeDecorationNodeCollection(); .)
  AttributeDecorations<attrNodes>
  (. var mod = new ModifierNodeCollection(); .)
  ModifierList<mod>                    
  ident
  (.
     var accNode = new AccessorNode(t);
     SetCommentOwner(accNode);
     accNode.AttributeDecorations = attrNodes;
     accNode.Modifiers = mod;
     propNode.FirstAccessor = accNode;
  .)
  ";"
  (. 
     accNode.ClosingSemicolon = t; 
     Terminate(accNode);
  .)
  [
    (. attrNodes = new AttributeDecorationNodeCollection(); .)
    AttributeDecorations<attrNodes>
    (. mod = new ModifierNodeCollection(); .)
    ModifierList<mod>                    
    ident
    (.
       accNode = new AccessorNode(t);
       SetCommentOwner(accNode);
       accNode.AttributeDecorations = attrNodes;
       accNode.Modifiers = mod;
       propNode.SecondAccessor = accNode;
    .)
    ";"
    (. 
       accNode.ClosingSemicolon = t; 
       Terminate(accNode);
    .)
  ]
.

// ------------------------------------------------------------------------------------------------
// Declaration of attributes.
// ------------------------------------------------------------------------------------------------
Attributes<out AttributeDecorationNode attrNode>
  (. 
     AttributeNode attributeNode;
     Token separator = null;
  .)
=
  "["
  (. attrNode = new AttributeDecorationNode(t); .)
  [ IF (IsAttrTargSpec()) 
    ( ident | Keyword )       
    (. attrNode.TargetToken = t; .)
    ":"
    (. separator = t; .)
  ] 
  Attribute<out attributeNode>
  (. attrNode.Attributes.Add(separator, attributeNode); .)
  { 
    IF (la.kind == _comma && Peek(1).kind != _rbrack) 
    ","
    (. separator = t; .)
    Attribute<out attributeNode>
    (. attrNode.Attributes.Add(separator, attributeNode); .)
  } 
  [ 
    ","
    (. attrNode.OrphanSeparator = t; .)
  ] 
  "]"                          
  (. Terminate(attrNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of attribute decorations.
// ------------------------------------------------------------------------------------------------
AttributeDecorations<AttributeDecorationNodeCollection attrNodes>
  (.  AttributeDecorationNode attrNode; .)
=
  {
    Attributes<out attrNode>
    (. attrNodes.Add(attrNode); .)
  }
.

// ------------------------------------------------------------------------------------------------
// Declarations tokens that function as keywords.
// ------------------------------------------------------------------------------------------------
Keyword
=
  "abstract" | "as" | "base" | "bool" | "break" | "byte" | "case" | "catch"
  | "char" | "checked" | "class" | "const" | "continue" | "decimal" | "default"
  | "delegate" | "do" | "double" | "else" | "enum" | "event" | "explicit"
  | "extern" | "false" | "finally" | "fixed" | "float" | "for" | "foreach"
  | "goto" | "if" | "implicit" | "in" | "int" | "interface" | "internal" | "is"
  | "lock" | "long" | "namespace" | "new" | "null" | "object" | "operator"
  | "out" | "override" | "params" | "private" | "protected" | "public"
  | "readonly" | "ref" | "return" | "sbyte" | "sealed" | "short" | "sizeof"
  | "stackalloc" | "static" | "string" | "struct" | "switch" | "this" | "throw"
  | "true" | "try" | "typeof" | "uint" | "ulong" | "unchecked" | "unsafe"
  | "ushort" | "using" | "virtual" | "void" | "volatile" | "while"
.

// ------------------------------------------------------------------------------------------------
// Declaration of an attribute.
//   attrNode: Attribute declaration syntax node.
// ------------------------------------------------------------------------------------------------
Attribute<out AttributeNode attrNode> 
= 
  (. 
     attrNode = new AttributeNode(la);
     SetCommentOwner(attrNode);
     NamespaceOrTypeNameNode nsNode = null;
  .)
  NamespaceOrTypeName<out nsNode>      
  (. attrNode.TypeName = nsNode; .)
  [ AttributeArguments<attrNode> ]
  (. Terminate(attrNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declares the list of attribute arguments.
// ------------------------------------------------------------------------------------------------
AttributeArguments<AttributeNode argsNode> 
=                           
  (.  
     Token identifier = null;
     Token equal = null;
     ExpressionNode exprNode;
  .)
  "("                          
  (.  Start(argsNode.Arguments); .)
    [                          
      [ IF (IsAssignment()) ident
        (. identifier = t; .)
        "="
        (. equal = t; .)
      ]
      Expression<out exprNode>           
      (. 
         var newArg = new AttributeArgumentNode(identifier, equal, exprNode);
         SetCommentOwner(newArg);
         argsNode.Arguments.Add(newArg); 
      .)
      { 
        ","
        (. var separator = t; .)
        ( IF (IsAssignment()) ident
          (. identifier = t; .)
          "="
          (. equal = t; .)
        |                    
        ) 
        Expression<out exprNode> 
        (. 
           newArg = new AttributeArgumentNode(identifier, equal, exprNode);
           SetCommentOwner(newArg);
           argsNode.Arguments.Add(separator, newArg); 
        .)
      }
    ]
  ")"   
  (. Terminate(argsNode.Arguments); .)
.

// ------------------------------------------------------------------------------------------------
// Modifiers that can be assigned to types and members.
// ------------------------------------------------------------------------------------------------
ModifierList<ModifierNodeCollection mods>
=
{
  (
      "new"
    | "public"
    | "protected"
    | "internal" 
    | "private"  
    | "unsafe"   
    | "static"   
    | "readonly" 
    | "volatile" 
    | "virtual"  
    | "sealed"   
    | "override" 
    | "abstract" 
    | "extern"   
  )                                  
  (. mods.Add(t); .)
}
.

// ------------------------------------------------------------------------------------------------
// Gets a reference to a type name with optional type parameters.
// ------------------------------------------------------------------------------------------------
Type<out TypeNode typeNode>    
=                                                    
  (. typeNode = null; .)      
  ( 
    PrimitiveType<out typeNode>
  |  
    ClassType<out typeNode>                                               
  |  
    "void"                                           
    (. typeNode = TypeNode.CreateTypeNode(t); .)
  )
  [ 
    "?"                                              
    (. typeNode.NullableToken = t; .)                                              
  ]
  PointerOrArray<typeNode>
  (. Terminate(typeNode); .)
.

// ------------------------------------------------------------------------------------------------
// Gets a reference for a non-array type.
// ------------------------------------------------------------------------------------------------
NonArrayType<out TypeNode typeNode>    
=                                                    
  (. typeNode = null; .)      
  ( 
    PrimitiveType<out typeNode>
  | 
    ClassType<out typeNode>
  )
  [ 
    "?"
    (. typeNode.NullableToken = t; .)                                              
  ]
  {
    "*"                         
    (. 
       typeNode.PointerTokens.Add(t); 
    .)
  }
  (. Terminate(typeNode); .)
.

// ------------------------------------------------------------------------------------------------
// Gets a reference for a type that can be used in a relational expression
// ------------------------------------------------------------------------------------------------
TypeInRelExpr<out TypeNode typeNode>    
=                                                    
  (. typeNode = null; .)      
  ( PrimitiveType<out typeNode>
  | ClassType<out typeNode>                                               
  | "void"                                           
    (. typeNode = TypeNode.CreateTypeNode(t); .)
  )
  [ IF (IsNullableTypeMark())
    "?" 
    (. typeNode.NullableToken = t; .)                                             
  ]
  PointerOrArray<typeNode>
  (. Terminate(typeNode); .)
.

// ------------------------------------------------------------------------------------------------
// Sets the appropriate flags of a type reference if the declaration shows it is a pointer or array.
// ------------------------------------------------------------------------------------------------
PointerOrArray<TypeNode typeNode>
=
  { IF (IsPointerOrDims())
    ( 
      "*"
      (. typeNode.PointerTokens.Add(t); .)  
    | 
      "["                     
      (. 
         var rankSpecifier = new RankSpecifierNode(t);
         typeNode.RankSpecifiers.Add(rankSpecifier);
         SetCommentOwner(rankSpecifier);
      .)
      { 
        ","                 
        (. rankSpecifier.Commas.Add(t); .)
      } 
      "]"                     
      (. 
        rankSpecifier.CloseSquareBracket = t;
        Terminate(rankSpecifier); 
      .)
    )
  }
.

/*
// ------------------------------------------------------------------------------------------------
// Types that are taken into account as primitive types.
// ------------------------------------------------------------------------------------------------
PredefinedType<out TypeNode typeNode> 
  (. typeNode = null; .)
=
    PrimitiveType<out typeNode> 
  | 
    ( "object" | "string" )                                    
    (. typeNode = TypeNode.CreateTypeNode(t); .)                                 
.
*/

// ------------------------------------------------------------------------------------------------
// Types that are taken into account as primitive types.
// ------------------------------------------------------------------------------------------------
PrimitiveType<out TypeNode typeNode> 
  (. typeNode = null; .)
=
    IntegralType<out typeNode> 
  | 
    ( "float" | "double" | "decimal" | "bool" )
    (. typeNode = TypeNode.CreateTypeNode(t); .)
.

// ------------------------------------------------------------------------------------------------
// Types that are taken into account as integral types.
// ------------------------------------------------------------------------------------------------
IntegralType<out TypeNode typeNode> 
= 
  (
    "sbyte"       
  | "byte"
  | "short" 
  | "ushort"
  | "int"
  | "uint"
  | "long"    
  | "ulong"     
  | "char"     
  )               
  (. typeNode = TypeNode.CreateTypeNode(t); .)
.

// ------------------------------------------------------------------------------------------------
// Types that are taken into account as class types.
// ------------------------------------------------------------------------------------------------
ClassType<out TypeNode typeNode>   
  (. typeNode = null; .)
=                 
    (.
      NamespaceOrTypeNameNode namespaceOrTypeName;
    .)
    NamespaceOrTypeName<out namespaceOrTypeName> 
    (.
      typeNode = new TypeNode(namespaceOrTypeName.StartToken);
      typeNode.TypeName = namespaceOrTypeName;
      typeNode.Terminate(t);
    .)
  |               
    ( "object" | "string" )                                    
    (. typeNode = TypeNode.CreateTypeNode(t); .)                                 
.

// ------------------------------------------------------------------------------------------------
// Declaration of a compound member name
// ------------------------------------------------------------------------------------------------
MemberName<out NamespaceOrTypeNameNode resultNode>                                              
  (.
     resultNode = null;
     Token separator = null;
     Token identifier = null;
     TypeNodeCollection argList = null;
  .)
=                                         
  ident
  (. 
     resultNode = new NamespaceOrTypeNameNode(t);
     SetCommentOwner(resultNode);
     identifier = t; 
  .)
  [ 
    "::"
    (. 
       resultNode.QualifierToken = identifier;
       separator = t; 
    .)
    ident                           
    (. identifier = t; .)
  ]
  [ IF (la.kind == _lt && IsPartOfMemberName()) TypeArgumentList<out argList> ]
  (. 
     var tagNode = new TypeTagNode(identifier, argList);
     SetCommentOwner(tagNode);
     resultNode.TypeTags.Add(separator, tagNode); 
  .)
  { 
    IF (la.kind == _dot && Peek(1).kind == _ident)
    "." 
    (.
       separator = t;
       argList = null;
    .)
    ident
    (. identifier = t; .)
    [ IF (la.kind == _lt && IsPartOfMemberName()) TypeArgumentList<out argList> ]
    (. 
       tagNode = new TypeTagNode(identifier, argList);
       SetCommentOwner(tagNode);
       resultNode.TypeTags.Add(separator, tagNode); 
    .)
  }
  (. Terminate(resultNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a compound type name
// ------------------------------------------------------------------------------------------------
NamespaceOrTypeName<out NamespaceOrTypeNameNode resultNode>                             
=               
  (.
     resultNode = null;
     Token separator = null;
     Token identifier = null;
     TypeNodeCollection argList = null;
  .)
  ident
  (. 
     resultNode = new NamespaceOrTypeNameNode(t);
     SetCommentOwner(resultNode);
     identifier = t; 
  .)
  [ 
    "::"
    (. 
       resultNode.QualifierToken = identifier;
       separator = t; 
    .)
    ident
    (. identifier = t; .)
  ]
  [ TypeArgumentList<out argList> ]
  (. 
     var tagNode = new TypeTagNode(identifier, argList);
     SetCommentOwner(tagNode);
     resultNode.TypeTags.Add(separator, tagNode); 
  .)
  {
    "."
    (.
      separator = t;
      argList = null;
    .)
    ident 
    (. identifier = t; .)
    [ TypeArgumentList<out argList> ]   
    (. 
       tagNode = new TypeTagNode(identifier, argList);
       SetCommentOwner(tagNode);
       resultNode.TypeTags.Add(separator, tagNode); 
    .)
  }
  (. Terminate(resultNode); .)
.

// ------------------------------------------------------------------------------------------------
// Statement declaration.
// ------------------------------------------------------------------------------------------------
Statement<out StatementNode stmtNode>
  (. stmtNode = null; .)
= 
    IF (la.kind == _ident && Peek(1).kind == _colon) 
    (. Token identifier; .)
    ident 
    (. identifier = t; .)
    ":" 
    (. 
       var label = new LabelNode(identifier, t); 
       SetCommentOwner(label);
    .)
    Statement<out stmtNode>
    (. if (stmtNode != null) stmtNode.Labels.AddLabel(label); .)
  | ConstStatement<out stmtNode>
  | IF (IsLocalVarDecl()) 
    (. LocalVariableNode varNode; .)
    LocalVariableDeclaration<out varNode>
    (. 
       var varDecl = new VariableDeclarationStatementNode(varNode.StartToken);
       SetCommentOwner(varDecl);
       stmtNode = varDecl;
       varDecl.Declaration = varNode;
    .)
    ";"
    (. Terminate(varDecl); .)
  | EmbeddedStatement<out stmtNode>
.

// ------------------------------------------------------------------------------------------------
// Defines statements that can be nested in other statements.
// ------------------------------------------------------------------------------------------------
EmbeddedStatement<out StatementNode stmtNode>
  (. stmtNode = null; .)
=   
    IF (la.kind == _ident && la.val == "yield")
    ident ( YieldReturnStatement<out stmtNode> | YieldBreakStatement<out stmtNode> )
  |
    (. BlockStatementNode blockNode; .)
    Block<out blockNode> 
    (. stmtNode = blockNode; .)
  | EmptyStatement<out stmtNode>
  | CheckedBlock<out stmtNode>
  | UncheckedBlock<out stmtNode>
  | UnsafeBlock<out stmtNode>
  | 
    (. ExpressionNode exprNode; .)
    (. 
       var eNode = new ExpressionStatementNode(la); 
       SetCommentOwner(eNode);
    .)
    StatementExpression<out exprNode> 
    (. eNode.Expression = exprNode; .)
    ";"
    (.
       stmtNode = eNode;
       Terminate(eNode); 
    .) 
  | IfStatement<out stmtNode>
  | SwitchStatement<out stmtNode>
  | WhileStatement<out stmtNode>
  | DoWhileStatement<out stmtNode>
  | ForStatement<out stmtNode>
  | ForEachStatement<out stmtNode>
  | BreakStatement<out stmtNode>
  | ContinueStatement<out stmtNode>
  | GotoStatement<out stmtNode>
  | ReturnStatement<out stmtNode>
  | ThrowStatement<out stmtNode>
  | TryFinallyBlock<out stmtNode>
  | LockStatement<out stmtNode>
  | UsingStatement<out stmtNode>
  | FixedStatement<out stmtNode>
.

// ------------------------------------------------------------------------------------------------
// Defines a block of statements.
// ------------------------------------------------------------------------------------------------
Block<out BlockStatementNode blockNode> 
=
  (. 
     StatementNode stmtNode;
     blockNode = null;
  .)
  "{" 
  (. 
     blockNode = new BlockStatementNode(t); 
     SetCommentOwner(blockNode);
  .)
  { 
    Statement<out stmtNode> 
    (. if (stmtNode != null) blockNode.Statements.Add(stmtNode); .)
  } 
  "}"
  (. Terminate(blockNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "switch" statement.
// ------------------------------------------------------------------------------------------------
SwitchStatement<out StatementNode stmtNode>
=
  "switch"
  (.
     var swcNode = new SwitchStatementNode(t);
     SetCommentOwner(swcNode);
     stmtNode = swcNode; 
  .)
  "("
  (. 
     swcNode.OpenParenthesis = t; 
     ExpressionNode exprNode; 
  .)
  Expression<out exprNode>    
  (. swcNode.Expression = exprNode; .)
  ")" 
  (. swcNode.CloseParenthesis = t; .)
  "{"
  (. swcNode.SwitchSections.StartToken = t; .)
  { 
    SwitchSection<swcNode>
  } 
  "}"
  (. 
     Terminate(swcNode.SwitchSections); 
     Terminate(stmtNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "const" statement.
// ------------------------------------------------------------------------------------------------
ConstStatement<out StatementNode stmtNode>
  (. ExpressionNode exprNode; .)
=
  "const"                
  (. 
     var csNode = new ConstStatementNode(t);
     SetCommentOwner(csNode);
     stmtNode = csNode;
     TypeNode typeNode;
  .)
  Type<out typeNode> 
  (. csNode.Type = typeNode; .)
  ident
  (. 
     var cmTag = new ConstTagNode(t); 
     SetCommentOwner(cmTag);
  .)
  "="                    
  (. cmTag.EqualToken = t; .)
  Expression<out exprNode>   
  (. 
     cmTag.Expression = exprNode;
     Terminate(cmTag);
     csNode.ConstTags.Add(cmTag);
  .)
  { 
    ","
    (. var separator = t; .)
    ident                
    (. 
       var cmcTag = new ConstTagNode(t); 
       SetCommentOwner(cmcTag);
    .)
    "=" 
    (. cmcTag.EqualToken = t; .)
    Expression<out exprNode> 
    (. 
       cmcTag.Expression = exprNode;
       Terminate(cmcTag);
       csNode.ConstTags.Add(separator, cmcTag);
    .)
  } 
  ";"
  (. Terminate(csNode); .)
.                 

// ------------------------------------------------------------------------------------------------
// Defines an empty statement (";").
// ------------------------------------------------------------------------------------------------
EmptyStatement<out StatementNode stmtNode>
=
  ";"
  (. 
     stmtNode = new EmptyStatementNode(t); 
     SetCommentOwner(stmtNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "checked" block
// ------------------------------------------------------------------------------------------------
CheckedBlock<out StatementNode stmtNode>
=
  (
    "checked"
    (. 
       var start = t; 
       BlockStatementNode blockNode;
    .)
    Block<out blockNode>
    (. 
       stmtNode = new CheckedStatementNode(t, blockNode); 
       SetCommentOwner(stmtNode);
    .)
  )
.

// ------------------------------------------------------------------------------------------------
// Defines an "unchecked" block
// ------------------------------------------------------------------------------------------------
UncheckedBlock<out StatementNode stmtNode>
=
  (
    "unchecked"
    (. 
       var start = t; 
       BlockStatementNode blockNode;
    .)
    Block<out blockNode>
    (. 
       stmtNode = new UncheckedStatementNode(t, blockNode); 
       SetCommentOwner(stmtNode);
    .)
  )
.

// ------------------------------------------------------------------------------------------------
// Defines an "unsafe" block
// ------------------------------------------------------------------------------------------------
UnsafeBlock<out StatementNode stmtNode>
=
  "unsafe" 
    (. 
       var start = t; 
       BlockStatementNode blockNode;
    .)
   Block<out blockNode>
   (. 
      stmtNode = new UnsafeStatementNode(t, blockNode); 
      SetCommentOwner(stmtNode);
   .)
.

// ------------------------------------------------------------------------------------------------
// Defines an "if" statement
// ------------------------------------------------------------------------------------------------
IfStatement<out StatementNode stmtNode>
=   
  "if"
  (. 
     var ifNode = new IfStatementNode(t);
     SetCommentOwner(ifNode);
     stmtNode = ifNode;
  .)
  "("
  (. 
     ifNode.OpenParenthesis = t;
     ExpressionNode exprNode; 
  .)
  Expression<out exprNode> 
  (. ifNode.Condition = exprNode; .)
  ")"
  (. 
     ifNode.CloseParenthesis = t;
     StatementNode thenBranchNode; 
     StatementNode elseBranchNode; 
  .)
  EmbeddedStatement<out thenBranchNode>
  (. ifNode.ThenStatement = thenBranchNode; .)
  [ 
    "else"
    (. ifNode.ElseToken = t; .)
    EmbeddedStatement<out elseBranchNode>
    (. ifNode.ElseStatement = elseBranchNode; .)
  ]
  (. Terminate(stmtNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "while" statement
// ------------------------------------------------------------------------------------------------
WhileStatement<out StatementNode stmtNode>
= 
  "while"
  (. 
     var whNode = new WhileStatementNode(t); 
     SetCommentOwner(whNode);
     stmtNode = whNode;
  .)
  "("
  (. 
     whNode.OpenParenthesis = t;
     ExpressionNode exprNode; 
  .)
  Expression<out exprNode>  
  (. whNode.Condition = exprNode; .)
  ")" 
  (. 
     whNode.CloseParenthesis = t;
     StatementNode bodyNode; 
  .)
  EmbeddedStatement<out bodyNode>
  (.
     whNode.Statement = bodyNode;
     Terminate(whNode);
  .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "do...while" statement
// ------------------------------------------------------------------------------------------------
DoWhileStatement<out StatementNode stmtNode>
=   
  "do"
  (. 
     var dwhNode = new DoWhileStatementNode(t); 
     SetCommentOwner(dwhNode);
     stmtNode = dwhNode;
     StatementNode bodyNode; 
  .)
  EmbeddedStatement<out bodyNode>
  (. dwhNode.Statement = bodyNode; .)
  "while" 
  (. dwhNode.WhileToken = t; .)
  "("
  (. 
     ExpressionNode exprNode;
     dwhNode.OpenParenthesis = t; 
  .)
  Expression<out exprNode>
  (. dwhNode.Condition = exprNode; .)    
  ")" 
  (. dwhNode.CloseParenthesis = t; .)
  ";"
  (. Terminate(stmtNode); .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "for" statement
// ------------------------------------------------------------------------------------------------
ForStatement<out StatementNode stmtNode>
= 
  "for"
  (.
     var forNode = new ForStatementNode(t);
     SetCommentOwner(forNode);
     stmtNode = forNode;
  .)
  "("
  (. forNode.OpenParenthesis = t; .)
  [
    ForInitializer<forNode>
  ] 
  ";" 
  (. forNode.InitSeparator = t; .)
  [
    (. ExpressionNode exprNode; .)
    Expression<out exprNode>
    (. forNode.Condition = exprNode; .)
  ] 
  ";" 
  (. forNode.ConditionSeparator = t; .)
  [ 
    ForIterator<forNode>
  ] 
  ")"
  (. 
     forNode.CloseParenthesis = t; 
     StatementNode bodyNode; 
  .)
  EmbeddedStatement<out bodyNode>
  (.
     forNode.Statement = bodyNode;
     Terminate(forNode); 
  .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "foreach" statement
// ------------------------------------------------------------------------------------------------
ForEachStatement<out StatementNode stmtNode>
=
  "foreach"
  (. 
     var feNode = new ForeachStatementNode(t); 
     SetCommentOwner(feNode);
     stmtNode = feNode;
  .)
  "("
  (. 
     feNode.OpenParenthesis = t; 
     TypeNode typeNode = null; 
  .)
  ( 
    IF (IsVar())
    ident
    (. typeNode = TypeNode.CreateTypeNode(t); .)
  |        
    Type<out typeNode>
  )
  (. feNode.Type = typeNode; .)
  ident
  (. feNode.IdentifierToken = t; .)
  "in"
  (. 
     feNode.InToken = t; 
     ExpressionNode exprNode;
  .)
  Expression<out exprNode>
  (. feNode.CollectionExpression = exprNode; .)
  ")"
  (.
     feNode.CloseParenthesis = t; 
     StatementNode bodyNode; 
  .)
  EmbeddedStatement<out bodyNode>
  (.
     feNode.Statement = bodyNode;
     Terminate(stmtNode); 
  .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "break" statement
// ------------------------------------------------------------------------------------------------
BreakStatement<out StatementNode stmtNode>
=
  "break"
  (. 
     stmtNode = new BreakStatementNode(t); 
     SetCommentOwner(stmtNode);
  .)
  ";"
  (. Terminate(stmtNode); .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "goto" statement
// ------------------------------------------------------------------------------------------------
GotoStatement<out StatementNode stmtNode>
=
  "goto"
  (. 
     var gotoNode = new GotoStatementNode(t); 
     SetCommentOwner(gotoNode);
  .)
  ( 
    ident
    (. gotoNode.IdentifierToken = t; .)
  | 
    "case"
    (. 
       gotoNode.IdentifierToken = t;
       ExpressionNode exprNode; 
    .)
    Expression<out exprNode>  
    (. gotoNode.Expression = exprNode; .)
  | 
    "default"
    (. gotoNode.IdentifierToken = t; .)
  ) 
  (. stmtNode = gotoNode; .)
  ";"
  (. Terminate(stmtNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "continue" statement
// ------------------------------------------------------------------------------------------------
ContinueStatement<out StatementNode stmtNode>
=
  "continue" 
  (. 
     stmtNode = new ContinueStatementNode(t); 
     SetCommentOwner(stmtNode);
  .)
  ";"
  (. Terminate(stmtNode); .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "try...catch...finally" statement
// ------------------------------------------------------------------------------------------------
TryFinallyBlock<out StatementNode stmtNode>
=
  "try"
  (. 
     var tryNode = new TryStatementNode(t);
     SetCommentOwner(tryNode);
     stmtNode = tryNode;
     BlockStatementNode blockNode; 
  .)
  Block<out blockNode>
  (. tryNode.TryBlock = blockNode; .) 
  ( 
    CatchClauses<tryNode>
    [ 
      "finally" 
      (. tryNode.FinallyToken = t; .)
      Block<out blockNode>
      (. tryNode.FinallyBlock = blockNode; .) 
    ] 
  | "finally"
    (. tryNode.FinallyToken = t; .)
    Block<out blockNode>
    (. tryNode.FinallyBlock = blockNode; .) 
  )
.    

// ------------------------------------------------------------------------------------------------
// Defines a "lock" statement
// ------------------------------------------------------------------------------------------------
LockStatement<out StatementNode stmtNode>
=   
  "lock"
  (. 
     var lckNode = new LockStatementNode(t); 
     SetCommentOwner(lckNode);
     stmtNode = lckNode;
  .)
  "("
  (. 
     lckNode.OpenParenthesis = t;
     ExpressionNode exprNode;
  .)
  Expression<out exprNode>  
  (. lckNode.Expression = exprNode; .)
  ")" 
  (. 
     lckNode.CloseParenthesis = t;
     StatementNode bodyNode;;
  .)
  EmbeddedStatement<out bodyNode>
  (.
     lckNode.Statement = bodyNode;
     Terminate(stmtNode);
  .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "using" statement
// ------------------------------------------------------------------------------------------------
UsingStatement<out StatementNode stmtNode>
=
  "using"
  (. 
     var usNode = new UsingStatementNode(t); 
     SetCommentOwner(usNode);
     stmtNode = usNode;
  .)
  "(" 
  (. usNode.OpenParenthesis = t; .)
  (
    IF (IsLocalVarDecl()) 
    (. LocalVariableNode varNode; .)
    LocalVariableDeclaration<out varNode>  
    (. usNode.Initializer = varNode; .)
  |
    (. ExpressionNode exprNode; .)
    Expression<out exprNode>      
    (. usNode.Expression = exprNode; .)  
  ) 
  ")" 
  (. 
     usNode.CloseParenthesis = t;   
     StatementNode bodyNode; 
  .)
  EmbeddedStatement<out bodyNode>
  (.
     usNode.Statement = bodyNode;
     Terminate(stmtNode); 
  .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "return" statement.
// ------------------------------------------------------------------------------------------------
ReturnStatement<out StatementNode stmtNode>
=
  (. ExpressionNode exprNode = null; .)
  "return"
  (. var start = t; .)
  [
    Expression<out exprNode>     
  ]
  (. 
     stmtNode = new ReturnStatementNode(t, exprNode); 
     SetCommentOwner(stmtNode);
  .)
  ";"
  (. Terminate(stmtNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "throw" statement.
// ------------------------------------------------------------------------------------------------
ThrowStatement<out StatementNode stmtNode>
=
  (. ExpressionNode exprNode = null; .)
  "throw"
  (. var start = t; .)
  [
    Expression<out exprNode>
  ] 
  (. 
     stmtNode = new ThrowStatementNode(t, exprNode); 
     SetCommentOwner(stmtNode);
  .)
  ";"
  (. Terminate(stmtNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "yield return" statement.
// ------------------------------------------------------------------------------------------------
YieldReturnStatement<out StatementNode stmtNode>
=
  (. 
     var start = t;
     ExpressionNode exprNode; 
  .)
  "return"
  (. var returnToken = t; .)
  Expression<out exprNode>
  (. 
     stmtNode = new YieldReturnStatementNode(t, returnToken, exprNode); 
     SetCommentOwner(stmtNode);
  .)
  ";"
  (. Terminate(stmtNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "yield break" statement.
// ------------------------------------------------------------------------------------------------
YieldBreakStatement<out StatementNode stmtNode>
=
  (. var start = t; .)
  "break"
  (. var breakToken = t; .)
  (. 
     stmtNode = new YieldBreakStatementNode(t, breakToken); 
     SetCommentOwner(stmtNode);
  .)
  ";"
  (. Terminate(stmtNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "fixed" statement
// ------------------------------------------------------------------------------------------------
FixedStatement<out StatementNode stmtNode>
= 
  "fixed"
  (.
     var fixNode = new FixedStatementNode(t);
     SetCommentOwner(fixNode);
     stmtNode = fixNode;
  .)
  "("
  (.
     fixNode.OpenParenthesis = t; 
     TypeNode typeNode; 
  .)
  Type<out typeNode>
  (. fixNode.Type = typeNode; .)
  ident
  (. 
     var fiNode = new FixedInitializerNode(t); 
     SetCommentOwner(fiNode);
  .)
  "="
  (. 
     fiNode.EqualToken = t; 
     ExpressionNode exprNode; 
  .)
  Expression<out exprNode>
  (. 
     fiNode.Expression = exprNode; 
     Terminate(fiNode);
     fixNode.Initializers.Add(fiNode);
  .)
  { 
    ","
    (. var separator = t; .)
    ident
    (. 
       fiNode = new FixedInitializerNode(t); 
       SetCommentOwner(fiNode);
    .)
    "=" 
    (. fiNode.EqualToken = t; .)
    Expression<out exprNode>
    (. 
       fiNode.Expression = exprNode; 
       Terminate(fiNode);
       fixNode.Initializers.Add(separator, fiNode);
    .)
  }
  ")" 
  (. 
     fixNode.CloseParenthesis = t;
     StatementNode bodyNode; 
  .)
  EmbeddedStatement<out bodyNode>
  (.
     fixNode.Statement = bodyNode;
     Terminate(fixNode); 
  .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a statement expression
// ------------------------------------------------------------------------------------------------
StatementExpression<out ExpressionNode exprNode>
  (. 
     bool isAssignment = assnStartOp[la.kind] || IsTypeCast(); 
     exprNode = null;
  .)
=
  (. ExpressionNode unaryNode; .)
  Unary<out unaryNode>
  (. exprNode = unaryNode; .)
  ( 
    (. AssignmentExpressionNode asgnNode; .)
    AssignmentOp<out asgnNode>
    (. 
       asgnNode.LeftOperand = unaryNode;
       exprNode = asgnNode;
       ExpressionNode rightNode; 
    .)
    Expression<out rightNode>
    (. asgnNode.RightOperand = rightNode; .)
  | (. if (isAssignment) Error("UNDEF", la, "error in assignment."); .)
  )
.

// ------------------------------------------------------------------------------------------------
// Defines an assignment operator.
// ------------------------------------------------------------------------------------------------
AssignmentOp<out AssignmentExpressionNode opNode> 
  (. 
     AssignmentOperator op = AssignmentOperator.SimpleAssignment;
     Token start;
     Token second = null;
  .)
=
  (. start = la; .)
  (
    "="     
    (. op = AssignmentOperator.SimpleAssignment; .)
  | "+="    
    (. op = AssignmentOperator.AdditionAssignment; .)
  | "-="    
    (. op = AssignmentOperator.SubtractionAssignment; .)
  | "*="    
    (. op = AssignmentOperator.MultiplicationAssignment; .)
  | "/="    
    (. op = AssignmentOperator.DivisionAssignment; .)
  | "%="    
    (. op = AssignmentOperator.ModuloAssignment; .)
  | "&="    
    (. op = AssignmentOperator.LogicalAndAssignment; .)
  | "|="    
    (. op = AssignmentOperator.LogicalOrAssignment; .)
  | "^="    
    (. op = AssignmentOperator.LogicalXorAssignment; .)
  | "<<="   
    (. op = AssignmentOperator.LeftShiftAssignment; .)
  | ">"     
    (. int pos = t.pos; .)
    ">="    
    (. 
       if (pos+1 < t.pos) Error("UNDEF", la, "no whitespace allowed in right shift assignment");
       op = AssignmentOperator.RightShiftAssignment;
       second = t;
    .)
  )
  (. 
     opNode = new AssignmentExpressionNode(start, second, op);
     SetCommentOwner(opNode); 
  .)
.

// ------------------------------------------------------------------------------------------------
// Represents a section of a switch statement.
// ------------------------------------------------------------------------------------------------
SwitchSection<SwitchStatementNode swcNode>
=
  (. 
     var ssNode = new SwitchSectionNode(la); 
     SetCommentOwner(ssNode);
     SwitchLabelNode slNode;
  .)
  SwitchLabel<out slNode>
  (. ssNode.Labels.Add(slNode); .)
  { 
    IF (la.kind == _case || (la.kind == _default && Peek(1).kind == _colon)) 
    SwitchLabel<out slNode>
    (. ssNode.Labels.Add(slNode); .)
  }
  (. StatementNode stmtNode; .)
  Statement<out stmtNode>
  (. ssNode.Statements.Add(stmtNode); .)
  { 
    IF (IsNoSwitchLabelOrRBrace()) 
    Statement<out stmtNode> 
    (. ssNode.Statements.Add(stmtNode); .)
  }
  (. swcNode.SwitchSections.Add(ssNode); .)
.

// ------------------------------------------------------------------------------------------------
// Represents a label of a switch statement.
// ------------------------------------------------------------------------------------------------
SwitchLabel<out SwitchLabelNode slNode>
  (. 
     slNode = new SwitchLabelNode(la); 
     SetCommentOwner(slNode);
  .)
= 
  (
    "case" 
    (. ExpressionNode exprNode; .)
    Expression<out exprNode> 
    (. slNode.Expression = exprNode; .)
  | 
    "default" 
  )
  ":"
  (. Terminate(slNode); .)
.

// ------------------------------------------------------------------------------------------------
// Represents the initializer of a for statement.
// ------------------------------------------------------------------------------------------------
ForInitializer<ForStatementNode forNode>
=
    IF (IsLocalVarDecl()) 
    (. LocalVariableNode varNode; .)
    LocalVariableDeclaration<out varNode>
    (. forNode.Initializer = varNode; .)
  | 
    (. ExpressionNode exprNode; .)
    StatementExpression<out exprNode>
    (. if (exprNode != null) forNode.Initializers.Add(exprNode); .)
    { 
      "," 
      (. var separator = t; .)
      StatementExpression<out exprNode>
      (. if (exprNode != null) forNode.Initializers.Add(separator, exprNode); .)
    }
.

// ------------------------------------------------------------------------------------------------
// Represents the iterator of a for statement.
// ------------------------------------------------------------------------------------------------
ForIterator<ForStatementNode forNode>
=
  (. ExpressionNode exprNode; .)
  StatementExpression<out exprNode>
  (. if (exprNode != null) forNode.Iterators.Add(exprNode); .)
  { 
    "," 
    (. var separator = t; .)
    StatementExpression<out exprNode>
    (. if (exprNode != null) forNode.Iterators.Add(separator, exprNode); .)
  }
.

// ------------------------------------------------------------------------------------------------
// Represents catch clauses in a "try..catch..finally" statement.
// ------------------------------------------------------------------------------------------------
CatchClauses<TryStatementNode tryNode>
=                                                     
  "catch"
  (. 
     var ccNode = new CatchClauseNode(t);
     SetCommentOwner(ccNode);
     BlockStatementNode blockNode;
  .)
  (                         
    Block<out blockNode>
    (. 
       ccNode.Block = blockNode; 
       Terminate(ccNode);
       tryNode.CatchClauses.Add(ccNode);
    .)
  | 
    "("
    (. 
       ccNode.OpenParenthesis = t; 
       TypeNode typeNode;
    .)
    ClassType<out typeNode>
    (. ccNode.Type = typeNode; .)
    [ 
      ident
      (. ccNode.IdentifierToken = t; .)
    ] 
    ")" 
    (. ccNode.CloseParenthesis = t; .)
    Block<out blockNode>
    (. 
       ccNode.Block = blockNode; 
       Terminate(ccNode);
       tryNode.CatchClauses.Add(ccNode);
    .)
    [ 
      CatchClauses<tryNode>
    ]
  )
.

// ------------------------------------------------------------------------------------------------
// Gets the signature of the specified lambda expression.
// ------------------------------------------------------------------------------------------------
LambdaFunctionSignature<LambdaExpressionNode lambdaNode>
=
  (
    //IF (la.kind == _ident)
    ident
    (.
       var fpNode = new FormalParameterNode(t);
       SetCommentOwner(fpNode);
       fpNode.IdentifierToken = t;
       Terminate(fpNode);
       lambdaNode.FormalParameters.Add(fpNode);
    .)
  |
    "("
    (. 
       lambdaNode.OpenParenthesis = t;
       FormalParameterNode parNode; 
    .)
    (
      IF (IsExplicitLambdaParameter(la))
      ExplicitLambdaParameter<out parNode>
      (. lambdaNode.FormalParameters.Add(parNode); .)
      {
        ","
        (. var separator = t; .)
        ExplicitLambdaParameter<out parNode>
        (. lambdaNode.FormalParameters.Add(separator, parNode); .)
      }
    |
      //IF (la.kind != _rpar)
      ident
      (.
         parNode = new FormalParameterNode(t);
         SetCommentOwner(parNode);
         parNode.Type = TypeNode.CreateEmptyTypeNode(null);
         parNode.IdentifierToken = t;
         Terminate(parNode);
         lambdaNode.FormalParameters.Add(parNode);
      .)
      {
        ","
        (. var separator = t; .)
        ident
        (.
           parNode = new FormalParameterNode(t);
           SetCommentOwner(parNode);
           parNode.Type = TypeNode.CreateEmptyTypeNode(null);
           parNode.IdentifierToken = t;
           Terminate(parNode);
           lambdaNode.FormalParameters.Add(separator, parNode);
        .)
      }
    |
    )
    ")"
    (. lambdaNode.OpenParenthesis = t; .)
  )
.

// ------------------------------------------------------------------------------------------------
// Gets the explicit parameter list of the specified lambda expression.
// ------------------------------------------------------------------------------------------------
ExplicitLambdaParameter<out FormalParameterNode fpNode>
=
  (. 
     fpNode = new FormalParameterNode(la); 
     SetCommentOwner(fpNode);
  .)
  [
    "ref" 
    (. fpNode.Modifier = FormalParameterModifier.Ref; .)
  | "out"
    (. fpNode.Modifier = FormalParameterModifier.Out; .)
  ]
  (. TypeNode typeNode; .)
  Type<out typeNode>
  (. fpNode.Type = typeNode; .)
  ident
  (. 
     fpNode.IdentifierToken = t; 
     Terminate(fpNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Gets the body of a lambda expression.
// ------------------------------------------------------------------------------------------------
LambdaFunctionBody<LambdaExpressionNode lambdaNode>
=
  (
    (. ExpressionNode exprNode; .)
    Expression<out exprNode>
    (. lambdaNode.Expression = exprNode; .)
  |
    (. BlockStatementNode blockNode; .)
    Block<out blockNode>
    (. lambdaNode.Block = blockNode; .)
  )
.

// ------------------------------------------------------------------------------------------------
// Gets a "from" clause for a query expression
// ------------------------------------------------------------------------------------------------
FromClause<out FromClauseNode fromNode>
=
  // --- At this point ident is "from"
  ident 
  (. 
     if (t.val!="from") Error("SYNERR", t, "Expected 'from' but found '{0}'.", t.val);
     fromNode = new FromClauseNode(t); 
     SetCommentOwner(fromNode);
     var typeToken = la;
  .)
  [                            
    IF (IsType(ref typeToken) && typeToken.val != "in")
    (. TypeNode typeNode; .)
    Type<out typeNode>
    (. fromNode.Type = typeNode; .)
  ]                             
  ident
  (. fromNode.IdentifierToken = t; .)
  "in"
  (. 
     fromNode.InToken = t; 
     ExpressionNode exprNode;
  .)
  Expression<out exprNode>
  (. 
     fromNode.Expression = exprNode;
     Terminate(fromNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Gets the body of a query expression.
// ------------------------------------------------------------------------------------------------
QueryBody<out QueryBodyNode bodyNode>
=
  (. 
     bodyNode = new QueryBodyNode(la); 
     SetCommentOwner(bodyNode);
  .)
  { 
    IF (la.kind == _ident && (la.val == "from" || la.val == "let" || la.val == "where" || la.val == "join" || la.val == "orderby"))
    (. QueryBodyClauseNode bodyClauseNode = null; .)
    QueryBodyClause<out bodyClauseNode> 
    (. bodyNode.BodyClauses.Add(bodyClauseNode); .)
  }

  (
    IF (la.kind == _ident && la.val == "select")
    (. SelectClauseNode selectNode; .)
    SelectClause<out selectNode>
    (. bodyNode.SelectClause = selectNode; .)
  | 
    //IF (la.kind == _ident && la.val == "group")
    (. GroupClauseNode groupNode; .)
    GroupClause<out groupNode>
    (. bodyNode.GroupClause = groupNode; .)
  )

  [
    IF (la.kind == _ident && la.val == "into")
    (. QueryContinuationNode intoNode; .)
    QueryContinuation<out intoNode>
    (. bodyNode.QueryContinuation = intoNode; .)
  ]
.

// ------------------------------------------------------------------------------------------------
// Gets a query body clause
// ------------------------------------------------------------------------------------------------
QueryBodyClause<out QueryBodyClauseNode bodyClauseNode>
=
  (. bodyClauseNode=null; .)
  (
    IF (la.kind == _ident && la.val == "from")
    (. FromClauseNode fromNode; .)
    FromClause<out fromNode>
    (. bodyClauseNode = fromNode; .)
  | 
    IF (la.kind == _ident && la.val == "let")
    (. LetClauseNode letNode; .)
    LetClause<out letNode>
    (. bodyClauseNode = letNode; .)
  | 
    IF (la.kind == _ident && la.val == "where")
    (. WhereClauseNode whereNode; .)
    WhereClause<out whereNode>
    (. bodyClauseNode = whereNode; .)
  |
    IF (la.kind == _ident && la.val == "join")
    (. JoinClauseNode joinNode; .)
    JoinClause<out joinNode>
    (. bodyClauseNode = joinNode; .)
  | 
    //IF (la.kind == _ident && la.val == "orderby")
    (. OrderByClauseNode orderNode; .)
    OrderByClause<out orderNode>
    (. bodyClauseNode = orderNode; .)
    
/* I think the following voodoo magic is not necessary any more, but I leave it here in a comment block just in case.
  |
    // WARNING: omitting the following ident could cause an infinite loop in parsing
    ident
    // --- At this point we have faced an identifier that would cause an infinite parsing loop
    (. Error("SYNERR", t, "invalid identifier in query expression", null); .)
*/
    
  )
.

// ------------------------------------------------------------------------------------------------
// Gets a "let" clause
// ------------------------------------------------------------------------------------------------
LetClause<out LetClauseNode letNode>
=
  (. ExpressionNode exprNode; .)
  // --- At this point ident is "let"
  ident
  (. 
     if (t.val!="let") Error("SYNERR", t, "Expected 'let' but found '{0}'.", t.val);
     letNode = new LetClauseNode(t); 
     SetCommentOwner(letNode);
  .)
  ident
  (. letNode.IdentifierToken = t; .)
  "="  
  (. letNode.EqualToken = t; .)
  Expression<out exprNode>
  (. 
     letNode.Expression = exprNode; 
     Terminate(letNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Gets a "where" clause
// ------------------------------------------------------------------------------------------------
WhereClause<out WhereClauseNode whereNode>
=
  (. ExpressionNode exprNode; .)
  // --- At this point ident is "where"
  ident
  (. 
     if (t.val!="where") Error("SYNERR", t, "Expected 'where' but found '{0}'.", t.val);
     whereNode = new WhereClauseNode(t); 
     SetCommentOwner(whereNode);
  .)
  Expression<out exprNode>
  (. 
     whereNode.Expression = exprNode; 
     Terminate(whereNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Gets an "into" clause
// ------------------------------------------------------------------------------------------------
QueryContinuation<out QueryContinuationNode intoNode>
=
  // --- At this point ident is "into"
  ident
  (. 
     if (t.val!="into") Error("SYNERR", t, "Expected 'into' but found '{0}'.", t.val);
     intoNode = new QueryContinuationNode(t); 
     SetCommentOwner(intoNode);
  .)
  ident
  (. 
     intoNode.IdentifierToken = t; 
     Terminate(intoNode);
     QueryBodyNode bodyNode;
  .)
  QueryBody<out bodyNode>
  (.
    intoNode.QueryBody = bodyNode;
  .)
.

// ------------------------------------------------------------------------------------------------
// Gets a "join" or "join-into" clause
// ------------------------------------------------------------------------------------------------
JoinClause<out JoinClauseNode joinNode>
=
  (. ExpressionNode exprNode; .)
  // --- At this point ident is "join"
  ident
  (. 
     if (t.val!="join") Error("SYNERR", t, "Expected 'join' but found '{0}'.", t.val);
     joinNode = new JoinClauseNode(t);
     SetCommentOwner(joinNode);
     Token typeToken = la; 
  .)

  [                    
    IF (IsType(ref typeToken) && typeToken.val != "in")
    (. TypeNode typeNode; .)
    Type<out typeNode>
    (. joinNode.Type = typeNode; .)
  ]

  ident
  (. joinNode.IdentifierToken = t; .)
  "in" 
  (. joinNode.InToken = t; .)
  Expression<out exprNode>
  (. joinNode.InExpression = exprNode; .)

  ident
  (. 
     if (t.val!="on") Error("SYNERR", t, "Expected 'on' but found '{0}'.", t.val);
     joinNode.OnToken = t; 
  .)
  Expression<out exprNode>
  (. joinNode.OnExpression = exprNode; .)
  
  ident
  (. 
    if (t.val!="equals") Error("SYNERR", t, "Expected 'equals' but found '{0}'.", t.val);
    joinNode.EqualsToken = t; 
  .)
  
  Expression<out exprNode>
  (. joinNode.EqualsExpression = exprNode; .)
  
  [ 
    IF (la.kind == _ident && la.val == "into")
    (. 
      // create a JoinIntoClauseNode based on the JoinClauseNode that was built so far
      var joinIntoNode = new JoinIntoClauseNode(joinNode.StartToken);
      joinIntoNode.Comment = joinNode.Comment;
      joinIntoNode.Type = joinNode.Type;
      joinIntoNode.IdentifierToken = joinNode.IdentifierToken;
      joinIntoNode.InToken = joinNode.InToken;
      joinIntoNode.InExpression = joinNode.InExpression;
      joinIntoNode.OnToken = joinNode.OnToken;
      joinIntoNode.OnExpression = joinNode.OnExpression;
      joinIntoNode.EqualsToken = joinNode.EqualsToken;
      joinIntoNode.EqualsExpression = joinNode.EqualsExpression;
    .)  
    ident
    (. 
      if (t.val!="into") Error("SYNERR", t, "Expected 'into' but found '{0}'.", t.val);
      joinIntoNode.IntoToken = t; 
    .)
    ident
    (. 
      joinIntoNode.IntoIdentifierToken = t; 
      joinNode = joinIntoNode;
    .)
  ]
  
  (. Terminate(joinNode); .)
.

// ------------------------------------------------------------------------------------------------
// Gets an "orderby" clause
// ------------------------------------------------------------------------------------------------
OrderByClause<out OrderByClauseNode obNode>
=
  (. OrderingClauseNode ordNode; .)
  // --- At this point ident is "orderby"
  ident
  (. 
     if (t.val!="orderby") Error("SYNERR", t, "Expected 'orderby' but found '{0}'.", t.val);
     obNode = new OrderByClauseNode(t); 
     SetCommentOwner(obNode);
  .)
  OrderingClause<out ordNode>
  (. obNode.Orderings.Add(ordNode); .)
  { 
    "," 
    (. var separator = t; .)
    OrderingClause<out ordNode>
    (. obNode.Orderings.Add(separator, ordNode); .)
  }
  (. Terminate(obNode); .)
.

// ------------------------------------------------------------------------------------------------
// Gets an ordering clause
// ------------------------------------------------------------------------------------------------
OrderingClause<out OrderingClauseNode ordNode>
=
  (. 
     ordNode = new OrderingClauseNode(la);
     SetCommentOwner(ordNode);
     ExpressionNode exprNode;
  .)
  Expression<out exprNode>
  (. ordNode.Expression = exprNode; .)
  [
    IF (la.kind == _ident && (la.val == "ascending" || la.val == "descending"))
    ident
    (. ordNode.Direction = t; .)
  ]
.

// ------------------------------------------------------------------------------------------------
// Gets a "select" clause
// ------------------------------------------------------------------------------------------------
SelectClause<out SelectClauseNode selNode>
=
  // --- At this point ident is "select"
  ident
  (. 
     if (t.val!="select") Error("SYNERR", t, "Expected 'select' but found '{0}'.", t.val);
     selNode = new SelectClauseNode(t);
     SetCommentOwner(selNode);
     ExpressionNode exprNode; 
  .)
  Expression<out exprNode>  
  (. 
     selNode.Expression = exprNode;
     Terminate(selNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Gets a "group..by" clause
// ------------------------------------------------------------------------------------------------
GroupClause<out GroupClauseNode groupNode>
  (. groupNode = null; .)
=
  (. ExpressionNode exprNode; .)
  // --- At this point ident is "group"
  ident
  (. 
     if (t.val!="group") Error("SYNERR", t, "Expected 'group' but found '{0}'.", t.val);
     groupNode = new GroupClauseNode(t); 
     SetCommentOwner(groupNode);
  .)
  Expression<out exprNode>
  (. groupNode.GroupExpression = exprNode; .)
  // --- At this point ident must be "by"
  ident
  (. 
     if (t.val!="by") Error("SYNERR", t, "Expected 'by' but found '{0}'.", t.val);
     groupNode.ByToken = t; 
  .)
  Expression<out exprNode>
  (. 
     groupNode.ByExpression = exprNode; 
     Terminate(groupNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Retrieves an expression.
// ------------------------------------------------------------------------------------------------
Expression<out ExpressionNode exprNode>   
  (. 
     exprNode = null;
     ExpressionNode leftExprNode;
  .)
=
  (
    IF (IsQueryExpression())
    (.
       var qNode = new QueryExpressionNode(la);    
       SetCommentOwner(qNode);
       FromClauseNode fromNode; 
       exprNode = qNode;
    .)
    FromClause<out fromNode>
    (. 
       qNode.FromClause = fromNode; 
       QueryBodyNode bodyNode;
    .)
    QueryBody<out bodyNode>
    (.
      qNode.QueryBody = bodyNode;
    .)
  |
    IF (IsLambda()) 
    (.
       var lambdaNode = new LambdaExpressionNode(t);
       SetCommentOwner(lambdaNode);
       exprNode = lambdaNode;
    .)              
    LambdaFunctionSignature<lambdaNode>
    "=>"
    (. lambdaNode.LambdaToken = t; .)
    LambdaFunctionBody<lambdaNode>
    (. Terminate(lambdaNode); .)
  |
  Unary<out leftExprNode>
  (
    IF (assgnOps[la.kind] || (la.kind == _gt && Peek(1).kind == _gteq))
    (. AssignmentExpressionNode asgnNode; .)
    AssignmentOp<out asgnNode>  
    (. ExpressionNode rightExprNode; .)
    Expression<out rightExprNode>
    (. 
       asgnNode.RightOperand = rightExprNode;
       asgnNode.LeftOperand = leftExprNode;
       exprNode = asgnNode;
    .)
  | (. BinaryExpressionNodeBase ncNode; .)
    NullCoalescingExpr<out ncNode> 
    (. 
       if (ncNode == null)
       {
         exprNode = leftExprNode;
       }
       else
       {
         ncNode.LeftmostExpressionWithMissingLeftOperand.LeftOperand = leftExprNode;
         exprNode = ncNode;
       }
    .)
    [ 
      "?"                            
      (. 
         var condNode = new ConditionalExpressionNode(exprNode);
         SetCommentOwner(condNode);
         exprNode = condNode;
         ExpressionNode trueNode;
      .)
      Expression<out trueNode>
      (. if (condNode != null) condNode.TrueExpression = trueNode; .)
      ":"                         
      (. ExpressionNode falseNode; .)
      Expression<out falseNode>
      (. 
         if (condNode != null) 
         {
           condNode.FalseExpression = falseNode; 
           Terminate(condNode);
         }
      .)
    ]
  )
  )                               
  (. if (exprNode != null) Terminate(exprNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a null coalescing operator.
// ------------------------------------------------------------------------------------------------
NullCoalescingExpr<out BinaryExpressionNodeBase exprNode>
=                     
  (. exprNode = null; .)
  OrExpr<out exprNode>    
  { 
    "??"                  
    (. 
       var opNode = new BinaryExpressionNode(t, BinaryOperator.NullCoalescing);
       SetCommentOwner(opNode);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>
    (. BinaryExpressionNodeBase rgNode; .) 
    OrExpr<out rgNode> 
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines a "logical or" operator.
// ------------------------------------------------------------------------------------------------
OrExpr<out BinaryExpressionNodeBase exprNode>
= 
  (. exprNode = null; .)
  AndExpr<out exprNode>    
  { 
    "||"                  
    (. 
       var opNode = new BinaryExpressionNode(t, BinaryOperator.ConditionalOr);
       SetCommentOwner(opNode);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryExpressionNodeBase rgNode; .) 
    AndExpr<out rgNode> 
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines a "logical and" operator.
// ------------------------------------------------------------------------------------------------
AndExpr<out BinaryExpressionNodeBase exprNode>
= 
  (. exprNode = null; .)
  BitOrExpr<out exprNode>    
  { 
    "&&"                  
    (. 
       var opNode = new BinaryExpressionNode(t, BinaryOperator.ConditionalAnd);
       SetCommentOwner(opNode);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryExpressionNodeBase rgNode; .) 
    BitOrExpr<out rgNode> 
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines a "bitwise or" operator.
// ------------------------------------------------------------------------------------------------
BitOrExpr<out BinaryExpressionNodeBase exprNode>
= 
  (. exprNode = null; .)
  BitXorExpr<out exprNode>    
  { 
    "|"
    (. 
       var opNode = new BinaryExpressionNode(t, BinaryOperator.LogicalOr);
       SetCommentOwner(opNode);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryExpressionNodeBase rgNode; .) 
    BitXorExpr<out rgNode> 
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines a "bitwise xor" operator.
// ------------------------------------------------------------------------------------------------
BitXorExpr<out BinaryExpressionNodeBase exprNode> 
= 
  (. exprNode = null; .)
  BitAndExpr<out exprNode>    
  { 
    "^"                   
    (. 
       var opNode = new BinaryExpressionNode(t, BinaryOperator.LogicalXor);
       SetCommentOwner(opNode);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryExpressionNodeBase rgNode; .) 
    BitAndExpr<out rgNode> 
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines a "bitwise and" operator.
// ------------------------------------------------------------------------------------------------
BitAndExpr<out BinaryExpressionNodeBase exprNode> 
= 
  (. exprNode = null; .)
  EqlExpr<out exprNode>    
  { 
    "&"                   
    (. 
       var opNode = new BinaryExpressionNode(t, BinaryOperator.LogicalAnd);
       SetCommentOwner(opNode);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryExpressionNodeBase rgNode; .) 
    EqlExpr<out rgNode> 
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines an "==" or "!=" operator.
// ------------------------------------------------------------------------------------------------
EqlExpr<out BinaryExpressionNodeBase exprNode>
= 
  (. exprNode = null; .)
  RelExpr<out exprNode>       
  (. BinaryExpressionNode opNode = null; .)
  {           
    (                     
      "!="                
      (. opNode = new BinaryExpressionNode(t, BinaryOperator.NotEquals); .)
    | "=="              
      (. opNode = new BinaryExpressionNode(t, BinaryOperator.Equals); .)
    )
    (.  
       SetCommentOwner(opNode);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryExpressionNodeBase rgNode; .) 
    RelExpr<out rgNode> 
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines relational and typecheck operators.
// ------------------------------------------------------------------------------------------------
RelExpr<out BinaryExpressionNodeBase exprNode> 
= 
  (. exprNode = null; .)
  ShiftExpr<out exprNode>  
  (. BinaryExpressionNode opNode = null; .)
  { 
    (
      "<"                 
      (. opNode = new BinaryExpressionNode(t, BinaryOperator.LessThan); .)
    | ">"               
      (. opNode = new BinaryExpressionNode(t, BinaryOperator.GreaterThan); .)
    | "<="              
      (. opNode = new BinaryExpressionNode(t, BinaryOperator.LessThanOrEqual); .)
    | ">="              
      (. opNode = new BinaryExpressionNode(t, BinaryOperator.GreaterThanOrEqual); .)
    )
    (. 
       SetCommentOwner(opNode);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryExpressionNodeBase rgNode; .) 
    ShiftExpr<out rgNode>             
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
    |
      (. TypeTestingExpressionNode typeTestingNode = null; .)
      (
        "is"            
        (. typeTestingNode = new TypeTestingExpressionNode(t, TypeTestingOperator.Is); .)
      | "as"            
        (. typeTestingNode = new TypeTestingExpressionNode(t, TypeTestingOperator.As); .)
      )   
      (. 
         SetCommentOwner(typeTestingNode);
         TypeNode typeNode; 
      .)
      TypeInRelExpr<out typeNode>
      (. 
         typeTestingNode.RightOperand = typeNode;
         typeTestingNode.LeftOperand = exprNode;
         SetCommentOwner(typeTestingNode.RightOperand);
         exprNode = typeTestingNode;
      .)
  }
  (. Terminate(exprNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines shift operators.
// ------------------------------------------------------------------------------------------------
ShiftExpr<out BinaryExpressionNodeBase exprNode> 
= 
  (. 
     exprNode = null;
     Token start;
     BinaryExpressionNode addExpr;
  .)
  AddExpr<out addExpr>       
  (. 
     exprNode = addExpr;
     BinaryExpressionNode opNode = null; 
  .)
  { IF (IsShift())
    (
      "<<"
      (. opNode = new BinaryExpressionNode(t, BinaryOperator.LeftShift); .)
    | ">" 
      (. start = t; .)
      ">"           
      (. opNode = new BinaryExpressionNode(start, t, BinaryOperator.RightShift); .)
    )                     
    (. 
       SetCommentOwner(opNode);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryExpressionNode rgNode; .) 
    AddExpr<out rgNode>
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines addition operators.
// ------------------------------------------------------------------------------------------------
AddExpr<out BinaryExpressionNode exprNode> 
= 
  (. exprNode = null; .)
  MulExpr<out exprNode>       
  (. BinaryExpressionNode opNode = null; .)
  {
    ( 
      "+"                 
      (. opNode = new BinaryExpressionNode(t, BinaryOperator.Addition); .)
    | "-"               
      (. opNode = new BinaryExpressionNode(t, BinaryOperator.Subtraction); .)
    )                     
    (. 
       SetCommentOwner(opNode);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryExpressionNode rgNode; .) 
    MulExpr<out rgNode>
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines multiplication operators.
// ------------------------------------------------------------------------------------------------
MulExpr<out BinaryExpressionNode exprNode> 
=                          
  (. 
     exprNode = null;
     BinaryExpressionNode opNode = null;
  .)
  {
    (
      "*"                 
      (. opNode = new BinaryExpressionNode(t, BinaryOperator.Multiplication); .)
    | "/"               
      (. opNode = new BinaryExpressionNode(t, BinaryOperator.Division); .)
    | "%"               
      (. opNode = new BinaryExpressionNode(t, BinaryOperator.Modulo); .)
    )                     
    (. 
       SetCommentOwner(opNode);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. 
       opNode.RightOperand = unaryNode;
       exprNode = opNode;
       Terminate(opNode);
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Retrieves an unary expression.
// ------------------------------------------------------------------------------------------------
Unary<out ExpressionNode exprNode>   
  (. 
     exprNode = null;  
     UnaryExpressionNodeBase unaryOp = null;
  .)
=
  (
    IF (unaryHead[la.kind] || IsTypeCast())
    ( 
      "+"     
      (. unaryOp = new UnaryOperatorExpressionNode(t, UnaryOperator.Identity); .)
    | "-"   
      (. unaryOp = new UnaryOperatorExpressionNode(t, UnaryOperator.Negation);.)
    | "!"   
      (. unaryOp = new UnaryOperatorExpressionNode(t, UnaryOperator.LogicalNegation); .)
    | "~"   
      (. unaryOp = new UnaryOperatorExpressionNode(t, UnaryOperator.BitwiseNegation); .)
    | "++"  
      (. unaryOp = new PreIncrementExpressionNode(t); .)
    | "--"  
      (. unaryOp = new PreDecrementExpressionNode(t); .)
    | "*"   
      (. unaryOp = new UnaryOperatorExpressionNode(t, UnaryOperator.PointerIndirection); .)
    | "&"   
      (. unaryOp = new UnaryOperatorExpressionNode(t, UnaryOperator.AddressOf); .)
    | "("   
      (. 
         TypeNode typeNode; 
         var tcNode = new CastExpressionNode(t);
         unaryOp = tcNode;
      .)
      Type<out typeNode> 
      (. tcNode.Type = typeNode; .)
      ")"
      (. Terminate(tcNode); .)
    )
    (. SetCommentOwner(unaryOp); .)
  )
  (. ExpressionNode unaryNode; .)
  Unary<out unaryNode>
  (. 
     if (unaryOp == null) exprNode = unaryNode;
     else
     {
       unaryOp.Operand = unaryNode;
       exprNode = unaryOp;
     }
     Terminate(unaryOp);
  .)
  | 
    Primary<out exprNode>
.

// ------------------------------------------------------------------------------------------------
// Retrieves a primary expression.
// ------------------------------------------------------------------------------------------------
Primary<out ExpressionNode exprNode>
=
  (. 
     exprNode = null;
  .)
  ( 
    Literal<out exprNode>             
  | 
    "("
    (. 
       var pExprNode = new ParenthesizedExpressionNode(t); 
       SetCommentOwner(pExprNode);
    .) 
    Expression<out exprNode>
    (. 
       pExprNode.Expression = exprNode;
       exprNode = pExprNode;
    .)
    ")"  
    (. Terminate(pExprNode); .)
  | 
    PredefinedTypeMemberAccess<out exprNode>
  | 
    IF (IsQualifiedAliasMember()) QualifiedAliasMemberAccess<out exprNode>
  | 
    (. SimpleNameNode sn = null; .)
    SimpleName<out sn>
    (. exprNode = sn; .)
  | 
    "this" 
    (. 
       exprNode = new ThisAccessNode(t); 
       SetCommentOwner(exprNode);
    .)
  | 
    "base" 
    ( 
      (. BaseMemberAccessNode baseNode = null; .)
      BaseMemberAccess<out baseNode> 
      (. exprNode = baseNode; .)
    | 
      (. BaseElementAccessNode baseNode = null; .)
      BaseElementAccess<out baseNode> 
      (. exprNode = baseNode; .)
    )  
  | NewOperator<out exprNode>
  | TypeOfOperator<out exprNode>
  | CheckedOperator<out exprNode>
  | UncheckedOperator<out exprNode>
  | DefaultOperator<out exprNode>
  | AnonymousDelegate<out exprNode>
  | SizeOfOperator<out exprNode>
  )

  { 
    (
      "++"  
      (. 
         var incNode = new PostIncrementExpressionNode(t);
         SetCommentOwner(incNode);
         incNode.Operand = exprNode;
         exprNode = incNode;
      .) 
    | "--"  
      (. 
         var decNode = new PostDecrementExpressionNode(t);
         SetCommentOwner(decNode);
         decNode.Operand = exprNode;
         exprNode = decNode;
      .) 
    | "->"  
      (. 
         var pointerNode = new PointerMemberAccessNode(t, exprNode);
         SetCommentOwner(pointerNode);
         pointerNode.SeparatorToken = t;
      .)
      ident           
      (. 
         pointerNode.IdentifierToken = t;
         TypeNodeCollection argList;
      .)
      [
        IF (IsGeneric()) TypeArgumentList<out argList>
        (. pointerNode.Arguments = argList; .)
      ]
      (.
         exprNode = pointerNode;
      .)
    | "."   
      (. 
         var maNode = new PrimaryExpressionMemberAccessNode(t, exprNode);
         SetCommentOwner(maNode);
         maNode.SeparatorToken = t;
      .)
      ident           
      (. 
         maNode.IdentifierToken = t;
         TypeNodeCollection argList;
      .)
      [
        IF (IsGeneric()) TypeArgumentList<out argList>
        (. maNode.Arguments = argList; .)
      ]
      (.
         exprNode = maNode;
      .)
    | "("   
      (. 
         var invNode = new InvocationExpressionNode(t, exprNode);
         SetCommentOwner(invNode);
      .)
      CurrentArgumentList<invNode.Arguments>
      ")"   
      (. 
         Terminate(invNode);
         exprNode = invNode;
      .)
    |       
      "["
      (. 
         var elementAccess = new ElementAccessNode(t, exprNode);
         SetCommentOwner(elementAccess);
      .)
      ArrayIndexer<elementAccess.Expressions> 
      "]"
      (. 
        Terminate(elementAccess); 
        exprNode = elementAccess;
      .)
    )         
  }
.

// ------------------------------------------------------------------------------------
// Declaration of a literal expression.
// ------------------------------------------------------------------------------------
Literal<out ExpressionNode valNode>
  (. valNode = null; .)
= 
  (
    intCon        
    (. valNode = IntegerLiteralNode.Create(t); .)
  | realCon     
    (. valNode = RealLiteralNode.Create(t); .)
  | charCon     
    (. valNode = new CharLiteralNode(t); .)
  | stringCon   
    (. valNode = new StringLiteralNode(t); .)
  | "true"
    (. valNode = new TrueLiteralNode(t); .)
  | "false"     
    (. valNode = new FalseLiteralNode(t); .)
  | "null"      
    (. valNode = new NullLiteralNode(t); .)
  )
  (. SetCommentOwner(valNode); .)
.

// ------------------------------------------------------------------------------------------------
// A predefined type member access expression.
// ------------------------------------------------------------------------------------------------
PredefinedTypeMemberAccess<out ExpressionNode exprNode>  
=            
  (. exprNode = null; .)
  (   "bool"
    | "byte"
    | "char"
    | "decimal"
    | "double"
    | "float"
    | "int"
    | "long"
    | "object"
    | "sbyte"
    | "short"
    | "string"
    | "uint"
    | "ulong"
    | "ushort"
  )               
  (. 
     var typeName = NamespaceOrTypeNameNode.CreateSimpleName(t);
     var predefMemAccessNode = new PredefinedTypeMemberAccessNode(t, typeName);
     SetCommentOwner(predefMemAccessNode);
  .)
  "." 
  (. 
     predefMemAccessNode.SeparatorToken = t; 
  .)
  ident           
  (. 
     predefMemAccessNode.IdentifierToken = t;
     TypeNodeCollection argList;
  .)
  [
    IF (IsGeneric()) TypeArgumentList<out argList>
    (. predefMemAccessNode.Arguments = argList; .)
  ]
  (.
     exprNode = predefMemAccessNode;
     Terminate(exprNode);
  .)
.

// ------------------------------------------------------------------------------------
// A qualified alias member access expression.
// ------------------------------------------------------------------------------------
QualifiedAliasMemberAccess<out ExpressionNode exprNode>  
= 
  (. exprNode = null; .)
  ident        
  (. 
     var qam = new QualifiedAliasMemberNode(t);
  .)
  "::"
  (.       
    qam.QualifierSeparatorToken = t;
  .)
  ident        
  (. 
    qam.IdentifierToken = t; 
    Terminate(qam);
  .)
  [ 
    (. 
      TypeNodeCollection argList; 
    .)
    TypeArgumentList<out argList>
    (. 
      qam.Arguments = argList; 
      Terminate(qam);
    .)
  ]
  "."          
  (. 
    Token separatorToken = t;
  .)
  ident        
  (. 
    exprNode = new QualifiedAliasMemberAccessNode(t, qam); 
    SetCommentOwner(exprNode);

    Terminate(exprNode); 
  .)
.

// ------------------------------------------------------------------------------------
// A simple name expression.
// ------------------------------------------------------------------------------------
SimpleName<out SimpleNameNode sn>  
= 
  (. sn = null; .)
  ident        
  (. 
    sn = new SimpleNameNode(t); 
    SetCommentOwner(sn);
    TypeNodeCollection argList; 
  .)
  [ 
    IF (IsGeneric()) TypeArgumentList<out argList>
    (. sn.Arguments = argList; .)
  ]
  (. Terminate(sn); .)
.

// ------------------------------------------------------------------------------------
// A base.member expression
// ------------------------------------------------------------------------------------
BaseMemberAccess<out BaseMemberAccessNode exprNode>  
= 
  "."       
  (. 
    Token separatorToken = t;
    exprNode = new BaseMemberAccessNode(t); 
    SetCommentOwner(exprNode);
  .)
  ident    
  (.
    var simpleNameNode = new SimpleNameNode(t);
    SetCommentOwner(simpleNameNode);
    simpleNameNode.SeparatorToken = separatorToken;
    Terminate(simpleNameNode);

    exprNode.MemberName = simpleNameNode; 
    exprNode.Terminate(t); 
  .)
.

// ------------------------------------------------------------------------------------
// A base[i] expression.
// ------------------------------------------------------------------------------------
BaseElementAccess<out BaseElementAccessNode exprNode>
=
  "["                             
  (. 
    Token separatorToken = t;
    exprNode = new BaseElementAccessNode(t);
    SetCommentOwner(exprNode);
  .)
  ArrayIndexer<exprNode.Expressions> 
  "]"                             
  (. exprNode.Terminate(t); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "typeof" operator.
// ------------------------------------------------------------------------------------------------
TypeOfOperator<out ExpressionNode exprNode>
= 
  "typeof"                   
  (. 
     var topNode = new TypeofExpressionNode(t);
     SetCommentOwner(topNode);
     exprNode = topNode;
  .)
  "("                        
  (. 
     topNode.OpenParenthesis = t;
     TypeNode typeNode;
  .)
  Type<out typeNode>
  (. topNode.Type = typeNode; .)
  ")"
  (. 
     topNode.CloseParenthesis = t;
     Terminate(exprNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "sizeof" operator.
// ------------------------------------------------------------------------------------------------
SizeOfOperator<out ExpressionNode exprNode>
= 
  "sizeof"                   
  (. 
     var sopNode = new SizeofExpressionNode(t);
     SetCommentOwner(sopNode);
     exprNode = sopNode;
  .)
  "("                        
  (. 
     sopNode.OpenParenthesis = t;
     TypeNode typeNode;
  .)
  Type<out typeNode>  
  (. sopNode.Type = typeNode; .)
  ")"                        
  (. 
     sopNode.CloseParenthesis = t;
     Terminate(exprNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "checked" operator.
// ------------------------------------------------------------------------------------------------
CheckedOperator<out ExpressionNode exprNode>
= 
  "checked"                     
  (. 
     var copNode = new CheckedExpressionNode(t);
     SetCommentOwner(copNode);
     exprNode = copNode;
  .)
  "("                           
  (. 
     copNode.OpenParenthesis = t;
     ExpressionNode innerNode;
  .)
  Expression<out innerNode>   
  (. copNode.Expression = innerNode; .)
  ")"
  (. 
     copNode.CloseParenthesis = t;
     Terminate(exprNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of an "unchecked" operator.
// ------------------------------------------------------------------------------------------------
UncheckedOperator<out ExpressionNode exprNode>
= 
  "unchecked"                   
  (. 
     var uopNode = new UncheckedExpressionNode(t);
     SetCommentOwner(uopNode);
     exprNode = uopNode;
  .)
  "("                           
  (. 
     uopNode.OpenParenthesis = t;
     ExpressionNode innerNode;
  .)
  Expression<out innerNode>
  (. uopNode.Expression = innerNode; .)
  ")"                           
  (. 
     uopNode.CloseParenthesis = t;
     Terminate(exprNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "default" operator.
// ------------------------------------------------------------------------------------------------
DefaultOperator<out ExpressionNode exprNode>
= 
  "default"     
  (. 
     var defNode = new DefaultValueExpressionNode(t);
     SetCommentOwner(defNode);
     exprNode = defNode;
  .)
  "("                        
  (. 
     defNode.OpenParenthesis = t;
     TypeNode typeNode;
  .)
  Type<out typeNode>  
  (. defNode.Type = typeNode; .)
  ")"                        
  (. 
     defNode.CloseParenthesis = t;
     Terminate(defNode);
  .)

.

// ------------------------------------------------------------------------------------------------
// Declaration of a "new" operator.
// ------------------------------------------------------------------------------------------------
NewOperator<out ExpressionNode exprNode>  
= 
  (. exprNode = null; .)
  "new"
  (. var newToken = t; .)

  (
    // new anonymous-object-initializer ==== new { member-declarator-list-opt } 

    (. 
       var anonNode = new AnonymousObjectCreationExpressionNode(t); 
       SetCommentOwner(anonNode);
    .)
    AnonymousObjectInitializer<anonNode>
    (. exprNode = anonNode; .)
  | 
    // alternatives:
    //   new type ( argument-list-opt ) object-or-collection-initializer-opt
    //   new delegate-type ( expression ) <-- this one cannot be distinguised from the previous based solely on syntax
    //   new type object-or-collection-initializer
    //   new non-array-type [ expression-list ] rank-specifiers-opt array-initializer-opt
    //   new array-type array-initializer

    (. TypeNode typeNode; .)
    NonArrayType<out typeNode>
    NewOperatorWithType<newToken, typeNode, out exprNode>
  |
    // new rank-specifier array-initializer ==== new [ dim-separators-opt ] array-initializer

    (. 
       var impArrNode = new ArrayCreationExpressionNode(t); 
       SetCommentOwner(impArrNode);
    .)
    ImplicitArrayCreation<impArrNode>
    (. exprNode = impArrNode; .)
  )
  (. Terminate(exprNode); .)
.

// ------------------------------------------------------------------------------------------------
// Represents an anonymous object initializer
// ------------------------------------------------------------------------------------------------
AnonymousObjectInitializer<AnonymousObjectCreationExpressionNode anonNode>
=
  "{"                                   
  (. anonNode.OpenBrace = t; .)
  [
    MemberDeclaratorList<anonNode> 
    [ 
      "," 
      (. anonNode.OrphanComma = t; .)
    ]
  ]
  "}"
  (. 
     anonNode.CloseBrace = t; 
     Terminate(anonNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of "new" operator member declaration list.
// ------------------------------------------------------------------------------------------------
MemberDeclaratorList<AnonymousObjectCreationExpressionNode anonNode>  
=                     
  (. MemberDeclaratorNode mdNode; .)
  MemberDeclarator<out mdNode>     
  (. anonNode.Declarators.Add(mdNode); .)
  {
    IF (NotFinalComma()) 
    ","
    (. var separator = t; .)
    MemberDeclarator<out mdNode>   
    (. anonNode.Declarators.Add(separator, mdNode); .)
  } 
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "new" operator declaration member.
// ------------------------------------------------------------------------------------------------
MemberDeclarator<out MemberDeclaratorNode mdNode> 
=
  (.
    mdNode = null; 
    ExpressionNode exprNode = null; 
    Token identToken = null;
    Token equalToken = null;
  .)
  [ 
    IF (IsAssignment()) 
    ident
    (. identToken = t; .)
    "=" 
    (. equalToken = t; .)
  ] 
  Expression<out exprNode>

  /* The spec (May 2006) allows only:                    *
   *   - simple-name                                     *
   *   - member-access                                   *
   *   - identifier = expression                         *
   * The CreateMemberDeclarator method will handle this. */

  (.
    mdNode = CreateMemberDeclarator(identToken, equalToken, exprNode);
    SetCommentOwner(mdNode);
    Terminate(mdNode); 
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "new" operator with explicit type.
// ------------------------------------------------------------------------------------------------
NewOperatorWithType<Token newToken, TypeNode typeNode, out ExpressionNode exprNode>
  (. exprNode = null; .)
=
  (
    // new type (here we stand) ( argument-list-opt ) object-or-collection-initializer-opt
    (. 
       var objectCreationNode = new ObjectCreationExpressionNode(newToken); 
       SetCommentOwner(objectCreationNode);
       objectCreationNode.Type = typeNode;
       exprNode = objectCreationNode;
    .)
    
    "("
    (. objectCreationNode.OpenParenthesis = t; .)
    
    CurrentArgumentList<objectCreationNode.Arguments>   // this rule accepts empty arg-list as well
    
    ")"
    (. objectCreationNode.CloseParenthesis = t; .)
    
    [         
      (. ObjectOrCollectionInitializerNode initNode; .)                 
      ObjectOrCollectionInitializer<out initNode>
      (. objectCreationNode.ObjectOrCollectionInitializer = initNode; .)
    ]
    (. Terminate(objectCreationNode); .)
  | 
    // new type (here we stand) object-or-collection-initializer ==== new type (here we stand) { ...
    (. 
       var objectCreationNode = new ObjectCreationExpressionNode(newToken); 
       SetCommentOwner(objectCreationNode);
       objectCreationNode.Type = typeNode;
       exprNode = objectCreationNode;
       ObjectOrCollectionInitializerNode initNode; 
     .)
    ObjectOrCollectionInitializer<out initNode>
    (. 
       objectCreationNode.ObjectOrCollectionInitializer = initNode; 
       Terminate(objectCreationNode);
    .)
  | 
    // new array-type array-initializer ==== new non-array-type (here we stand) rank-specifiers array-initializer
    IF (IsDims())                 
    (. 
       var arrayCreationNode = new ArrayCreationExpressionNode(t); 
       SetCommentOwner(arrayCreationNode);
       arrayCreationNode.Type = typeNode;
       exprNode = arrayCreationNode;
    .)
    RankSpecifiers<arrayCreationNode>
    (. ArrayInitializerNode arrInitNode; .)                     
    ArrayInitializer<out arrInitNode> 
    (. 
      arrayCreationNode.Initializer = arrInitNode;
      Terminate(arrayCreationNode); 
    .)
  | 
    // new non-array-type (here we stand) [ expression-list ] rank-specifiers-opt array-initializer-opt
    (. 
       var arrayCreationNode = new ArrayCreationExpressionNode(newToken); 
       SetCommentOwner(arrayCreationNode);
       arrayCreationNode.Type = typeNode;
       exprNode = arrayCreationNode;
       ExpressionNode initExprNode; 
    .)
    "["
    (. arrayCreationNode.ArraySizeSpecifier.OpenSquareBracket = t; .)
    Expression<out initExprNode>
    (. arrayCreationNode.ArraySizeSpecifier.Expressions.Add(initExprNode); .)
    { 
      ","
      (. 
        arrayCreationNode.ArraySizeSpecifier.Commas.Add(t);
        var separator = t; 
      .)
      Expression<out initExprNode>
      (. arrayCreationNode.ArraySizeSpecifier.Expressions.Add(separator, initExprNode); .)
    } 
    "]" 
    (. 
      arrayCreationNode.ArraySizeSpecifier.CloseSquareBracket = t;
      Terminate(arrayCreationNode.ArraySizeSpecifier); 
    .)
    
    { IF (IsDims()) 
      "["
      (.
        var rankSpecifier = new RankSpecifierNode(t);
        arrayCreationNode.RankSpecifiers.Add(rankSpecifier);
      .)
        { 
          ","                           
          (. rankSpecifier.Commas.Add(t); .)
        } 
      "]" 
      (.
        rankSpecifier.CloseSquareBracket = t;
        Terminate(rankSpecifier);
      .)
    }
    [            
      (. ArrayInitializerNode arrInitNode; .)                 
      ArrayInitializer<out arrInitNode> 
      (. arrayCreationNode.Initializer = arrInitNode; .)
    ] 
    (.
       Terminate(arrayCreationNode);
       exprNode = arrayCreationNode;
    .)
  )
.

// ------------------------------------------------------------------------------------------------
// Rank specifiers
// ------------------------------------------------------------------------------------------------
RankSpecifiers<ArrayCreationExpressionNode arrayCreationNode>
=
  "["
  (.
    var rankSpecifier = new RankSpecifierNode(t);
    arrayCreationNode.RankSpecifiers.Add(rankSpecifier);
  .)
    { 
      ","
      (. rankSpecifier.Commas.Add(t); .)
    } 
  "]"
  (.
    rankSpecifier.CloseSquareBracket = t;
    Terminate(rankSpecifier);
  .)
  
  {
    "["
    (.
      rankSpecifier = new RankSpecifierNode(t);
      arrayCreationNode.RankSpecifiers.Add(rankSpecifier);
    .)
      { 
        ","                           
        (. rankSpecifier.Commas.Add(t); .)
      } 
    "]" 
    (.
      rankSpecifier.CloseSquareBracket = t;
      Terminate(rankSpecifier);
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Declaration of an implicit array creation
// ------------------------------------------------------------------------------------------------
ImplicitArrayCreation<ArrayCreationExpressionNode impArrNode> 
=
  // --- new (here we stand) rank-specifier array-initializer
  "["
  (.
    var rankSpecifier = new RankSpecifierNode(t);
    impArrNode.RankSpecifiers.Add(rankSpecifier);
  .)
    { 
      ","                           
      (. rankSpecifier.Commas.Add(t); .)
    } 
  "]" 
  (. 
    rankSpecifier.CloseSquareBracket = t;
    Terminate(rankSpecifier);
    ArrayInitializerNode initNode; 
  .)                     
  ArrayInitializer<out initNode> 
  (. 
    impArrNode.Initializer = initNode;
    Terminate(impArrNode); 
  .)
.

// ------------------------------------------------------------------------------------------------
// Declares an object or collection initializer used with "new" operator
// ------------------------------------------------------------------------------------------------
ObjectOrCollectionInitializer<out ObjectOrCollectionInitializerNode oiNode>
=
  "{"
  (. 
     oiNode = new ObjectOrCollectionInitializerNode(t); 
     SetCommentOwner(oiNode);
  .)
  (
    //IF (IsEmptyMemberInitializer()) 
    "}"   
    (. Terminate(oiNode); .)
  |
    IF (IsMemberInitializer()) 
    MemberInitializerList<oiNode>
    [ 
      "," 
      (. oiNode.OrphanSeparator = t; .)
    ]
    "}"
    (. Terminate(oiNode); .)
  |
    ElementInitializerList<oiNode>
    [ 
      "," 
      (. oiNode.OrphanSeparator = t; .)
    ]
    "}"
    (. Terminate(oiNode); .)
  )
.

// ------------------------------------------------------------------------------------------------
// Declares an element initializer list of a collection used with "new" operator
// ------------------------------------------------------------------------------------------------
ElementInitializerList<ObjectOrCollectionInitializerNode ocNode>
=
  (. ElementInitializerNode eiNode; .)
  ElementInitializer<out eiNode>
  (. ocNode.ElementInitializers.Add(eiNode); .)
  {
    IF (NotFinalComma()) 
    ","
    (. var separator = t; .)
    ElementInitializer<out eiNode>
    (. ocNode.ElementInitializers.Add(separator, eiNode); .)
  } 
.

// ------------------------------------------------------------------------------------------------
// An element initializer
// ------------------------------------------------------------------------------------------------
ElementInitializer<out ElementInitializerNode eiNode>
=
  (. 
     eiNode = new ElementInitializerNode(la);
     SetCommentOwner(eiNode);
     ExpressionNode exprNode; 
  .)
  (
    //IF (IsValueInitializer())
    (. var savedToken = la; .)
    Expression<out exprNode>
    (. 
      if (exprNode is AssignmentExpressionNode) 
      { 
        Error0747(savedToken); 
      }
      else
      {
        eiNode.NonAssignmentExpression = exprNode; 
      }
    .)
  | 
    "{"
    (. eiNode.ExpressionList.StartToken = t; .)
      Expression<out exprNode>
      (. eiNode.ExpressionList.Add(exprNode); .)
      {
        ","
        (. var separator = t; .)
        Expression<out exprNode>
        (. eiNode.ExpressionList.Add(separator, exprNode); .)
      }
    "}"
    (. Terminate(eiNode.ExpressionList); .)
  )
  (. Terminate(eiNode);.)
.

// ------------------------------------------------------------------------------------------------
// A member initialization list declaration
// ------------------------------------------------------------------------------------------------
MemberInitializerList<ObjectOrCollectionInitializerNode ocNode>
=                  
  (. MemberInitializerNode miNode; .)   
  MemberInitializer<out miNode>
  (. ocNode.MemberInitializers.Add(miNode); .)
  {
    IF (NotFinalComma()) 
    ","
    (. var separator = t; .)
    MemberInitializer<out miNode>
    (. ocNode.MemberInitializers.Add(separator, miNode); .)
  } 
.

// ------------------------------------------------------------------------------------------------
// A member initialization declaration
// ------------------------------------------------------------------------------------------------
MemberInitializer<out MemberInitializerNode miNode>
=
  ident
  (. 
     miNode = new MemberInitializerNode(t); 
     SetCommentOwner(miNode);
  .)
  "="
  (. miNode.EqualToken = t; .)
  (
    //IF (IsValueInitializer())
    (. ExpressionNode exprNode; .)
    Expression<out exprNode>
    (. miNode.Expression = exprNode; .)
  |          
    (. ObjectOrCollectionInitializerNode initNode; .)                 
    ObjectOrCollectionInitializer<out initNode>
    (. miNode.Initializer = initNode; .)
  )
  (. Terminate(miNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declarares an anonymous delegate with its body.
// ------------------------------------------------------------------------------------------------
AnonymousDelegate<out ExpressionNode exprNode>  
= 
  "delegate"            
  (. 
     var adNode = new AnonymousMethodExpressionNode(t);
     SetCommentOwner(adNode);
     exprNode = adNode;
  .)
  [                     
    "("
    [ 
      (. FormalParameterNode parNode; .)
      AnonymousMethodParameter<out parNode>
      (. adNode.FormalParameters.Add(parNode); .)
      { 
        "," 
        (. var separator = t; .)
        AnonymousMethodParameter<out parNode>   
        (. adNode.FormalParameters.Add(separator, parNode); .)
      } 
    ] 
    ")" 
  ] 
  (. BlockStatementNode blockNode; .)
  Block<out blockNode>           
  (. 
    adNode.Body = blockNode;
    Terminate(exprNode); 
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of an anonymous method parameter.
// ------------------------------------------------------------------------------------------------
AnonymousMethodParameter<out FormalParameterNode parNode> 
=
  (. 
     var modifier = FormalParameterModifier.In; 
     Token start = null;
     parNode = null;
  .)
  [
    (
      "ref"         
      (. modifier = FormalParameterModifier.Ref; .) 
    | "out"                     
      (. modifier = FormalParameterModifier.Out; .) 
    )
    (. start = t; .)
  ]                             
  (. TypeNode typeNode; .)
  Type<out typeNode>      
  (. if (start == null) start = typeNode.StartToken; .)
  ident                         
  (. 
     parNode = new FormalParameterNode(start);
     SetCommentOwner(parNode);
     parNode.Modifier = modifier;
     parNode.IdentifierToken = t;
     parNode.Type = typeNode;
     Terminate(parNode);
  .)  
.

// ------------------------------------------------------------------------------------------------
// A list of expressions.
// ------------------------------------------------------------------------------------------------
ArrayIndexer<ExpressionNodeCollection exprList> 
= 
  (. 
     ExpressionNode exprNode; 
     Token separator = null;
  .) 
  Expression<out exprNode>
  (. 
     if (exprList != null)
     {
       exprList.Add(exprNode);
     }
  .)
  { 
    "," 
    (. separator = t; .)
    Expression<out exprNode>
    (. 
       if (exprList != null)
       {
         exprList.Add(separator, exprNode);
       }
    .)
  } 
.

// ------------------------------------------------------------------------------------------------
// Declaration of a field member variable.
// ------------------------------------------------------------------------------------------------
FieldMemberDeclarators<FieldDeclarationNode fiNode>
= 
  (. FieldTagNode tagNode; .)
  SingleFieldMember<out tagNode>
  (. fiNode.FieldTags.Add(tagNode); .)
  { 
    "," 
    (. var separator = t; .)
    SingleFieldMember<out tagNode>
    (. fiNode.FieldTags.Add(separator, tagNode); .)
  }
.

// ------------------------------------------------------------------------------------------------
// Declaration of a single field member.
// ------------------------------------------------------------------------------------------------
SingleFieldMember<out FieldTagNode fiNode>
= 
  ident                      
  (. 
     fiNode = new FieldTagNode(t); 
     SetCommentOwner(fiNode);
  .)
  [ 
    "="                      
    (. 
       fiNode.EqualToken = t;
       VariableInitializerNode varInitNode; 
    .)
    VariableInitializer<out varInitNode> 
    (. fiNode.Initializer = varInitNode; .) 
  ]                          
  (. Terminate(fiNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines the operators that can be overloaded.
// ------------------------------------------------------------------------------------------------
OverloadableOp<OperatorDeclarationNode opNode>
=  
  ( ">"
    (.
       opNode.KindToken = t;
       opNode.Kind = OverloadableOperatorType.GreaterThan;
    .)
    [                       
      (. if (la.pos > t.pos+1) Error("UNDEF", la, "no whitespace allowed in right shift operator"); .)
      ">"
      (.
         opNode.SecondKindToken = t;
         opNode.Kind = OverloadableOperatorType.RightShift;
      .)
    ]                        
  )   
  |
  ( 
    "+"                                     
    (. opNode.Kind = OverloadableOperatorType.Addition; .)
  | "-"
    (. opNode.Kind = OverloadableOperatorType.Subtraction; .)
  | "!"
    (. opNode.Kind = OverloadableOperatorType.Not; .)
  | "~"
    (. opNode.Kind = OverloadableOperatorType.BitwiseNot; .)
  | "++"
    (. opNode.Kind = OverloadableOperatorType.Increment; .)
  | "--"
    (. opNode.Kind = OverloadableOperatorType.Decrement; .)
  | "true"
    (. opNode.Kind = OverloadableOperatorType.True; .)
  | "false"
    (. opNode.Kind = OverloadableOperatorType.False; .)
  | "*"    
    (. opNode.Kind = OverloadableOperatorType.Multiplication; .)
  | "/"    
    (. opNode.Kind = OverloadableOperatorType.Division; .)
  | "%"
    (. opNode.Kind = OverloadableOperatorType.Modulo; .)
  | "&"
    (. opNode.Kind = OverloadableOperatorType.BitwiseAnd; .)
  | "|"
    (. opNode.Kind = OverloadableOperatorType.BitwiseOr; .)
  | "^"
    (. opNode.Kind = OverloadableOperatorType.BitwiseXor; .)
  | "<<"
    (. opNode.Kind = OverloadableOperatorType.LeftShift; .)
  | "=="
    (. opNode.Kind = OverloadableOperatorType.Equal; .)
  | "!="
    (. opNode.Kind = OverloadableOperatorType.NotEqual; .)
  | "<"                         
    (. opNode.Kind = OverloadableOperatorType.LessThan; .)
  | ">="                        
    (. opNode.Kind = OverloadableOperatorType.GreaterThanOrEqual; .)
  | "<="                        
    (. opNode.Kind = OverloadableOperatorType.LessThanOrEqual; .)
  )
  (. opNode.KindToken = t; .)
.

// ------------------------------------------------------------------------------------------------
// Type parameter declarations for generic types.
// ------------------------------------------------------------------------------------------------
TypeParameterList<ITypeParameterHolder paramNode>
=                            
  (. 
     Token identifier;
     AttributeDecorationNodeCollection attrNodes;
  .)
  "<" 
  (. Start(paramNode.TypeParameters); .)                      
  TypeParameter<out attrNodes, out identifier>      
  (. 
     var newParNode = new TypeParameterNode(identifier, attrNodes);
     SetCommentOwner(newParNode);
     paramNode.TypeParameters.Add(newParNode); 
  .)
  { 
    "," 
    (. var separator= t; .)
    TypeParameter<out attrNodes, out identifier>      
    (. 
       newParNode = new TypeParameterNode(identifier, attrNodes);
       SetCommentOwner(newParNode);
       paramNode.TypeParameters.Add(separator, newParNode); 
    .)
  } 
  ">"
  (. Terminate(paramNode.TypeParameters); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a type parameter.
// ------------------------------------------------------------------------------------------------
TypeParameter<out AttributeDecorationNodeCollection attrNodes, out Token identifier>
=                         
  (. attrNodes = new AttributeDecorationNodeCollection(); .)
  AttributeDecorations<attrNodes>
  ident
  (. identifier = t; .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a type argument list.
// ------------------------------------------------------------------------------------------------
TypeArgumentList<out TypeNodeCollection argList>  
= 
  (. argList = null; .) 
  // --- We are a bit sloppy here and allow the type arguments to be "empty" everywhere. This 
  // --- results in unbound-type-names. In fact this is only allowed in typeof statements, 
  // --- see ECMA-334: 14.5.11 and 25.5.
  "<"
  (. 
     argList = new TypeNodeCollection(); 
     SetCommentOwner(argList);
     Start(argList);
  
     TypeNode typeNode = null;
  .)
  [ 
    Type<out typeNode>
  ]                              
  (. 
    if (typeNode==null) { typeNode = TypeNode.CreateEmptyTypeNode(null); }
    argList.Add(typeNode); 
  .)          
  { 
    ","
    (. 
      typeNode = null;
    .)
    [ 
      Type<out typeNode>           
    ]
  (. 
    if (typeNode==null) { typeNode = TypeNode.CreateEmptyTypeNode(t); }
    argList.Add(typeNode); 
  .)          
  } 
  ">"
  (. Terminate(argList); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a type parameter constraint belonging to a type, a method or a delegate.
// ------------------------------------------------------------------------------------------------
TypeParameterConstraintsClause<out TypeParameterConstraintNode constrNode>   
=
  (. 
     Token start;
     Token identifier;
     constrNode = null;
  .)   
  // --- At this point ident is "where"  
  ident
  (. 
     if (t.val != "where") Error("SYNERR", t, "'where' token is expected", null);
     start = t; 
  .)
  ident                        
  (. identifier = t; .)
  ":"
  (. 
     constrNode = new TypeParameterConstraintNode(start, identifier, t);
     SetCommentOwner(constrNode);
     TypeParameterConstraintTagNode tag;
  .)
  TypeParameterConstraintTag<out tag>
  (. constrNode.ConstraintTags.Add(tag); .)
  {
    "," 
    (. var separator = t; .)
    TypeParameterConstraintTag<out tag>
    (. constrNode.ConstraintTags.Add(separator, tag); .)
  }
  (. Terminate(constrNode); .)
.

// ------------------------------------------------------------------------------------------------
// Obtains a type parameter constraint tag.
// ------------------------------------------------------------------------------------------------
TypeParameterConstraintTag<out TypeParameterConstraintTagNode tag> 
  (. tag = null; .)
=
  (
    "class"                    
    (. tag = new TypeParameterConstraintTagNode(t); .)
  |
    "struct"                   
    (. tag = new TypeParameterConstraintTagNode(t); .)
  |
    "new"                      
    (. var start = t; .)
    "(" 
    (. var openPar = t; .)
    ")" 
    (. tag = new TypeParameterConstraintTagNode(start, openPar, t); .)
  |
    (. TypeNode typeNode; .)
    ClassType<out typeNode>     
    (. tag = new TypeParameterConstraintTagNode(typeNode); .)
  )
  (. SetCommentOwner(tag); .)
.

END CS3.