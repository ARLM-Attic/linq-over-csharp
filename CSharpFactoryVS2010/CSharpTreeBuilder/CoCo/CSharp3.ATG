using System.Text;
using System.Collections;
using CSharpTreeBuilder.Ast;
using CSharpTreeBuilder.CSharpAstBuilder;

COMPILER CS3

// ================================================================================================
// Scanner description
// ================================================================================================

CHARACTERS

  tab                = '\u0009'. /*  9 = tabulator */
  eol                = '\u000a'. /* 10 = line feed */
  cr                 = '\u000d'. /* 13 = carriage return */
  newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */

  startLetter        = 'A' .. 'Z' + 'a' .. 'z' + '_' + '\u00aa' + '\u00b5' + '\u00ba' + '\u00c0' .. '\u00d6' + '\u00d8' .. '\u00f6' + '\u00f8' .. '\u00ff'.
  partLetter         = '0' .. '9' + 'A' .. 'Z' + 'a' .. 'z' + '_' + '\u00a0' + '\u00aa' + '\u00b5' + '\u00ba' + '\u00c0' .. '\u00d6' + '\u00d8' .. '\u00f6' + '\u00f8' .. '\u00ff'.

  digit              = "0123456789".  
  hexDigit           = digit + "ABCDEFabcdef".
  notDigit           = ANY - digit.

  char               = ANY - "'" - '\\' - newLine.
  verbatimStringChar = ANY - '"'.
  regularStringChar  = ANY - '"' - '\\' - newLine.
  notNewLine         = ANY - newLine .
  ws                 = " " + tab + '\u000b' + '\u000c'. /* Any character with Unicode class Zs */
  blockComCh         = ANY - '*' - '/'.

TOKENS

  // ----------------------------------------------------------------------------------------------

  ident =
    ['@']
    ( startLetter
    | '\\'
      ( 'u' hexDigit hexDigit hexDigit hexDigit
      | 'U' hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
      )
    )
    { partLetter
    | '\\'
      ( 'u' hexDigit hexDigit hexDigit hexDigit
      | 'U' hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
      )
    }.

  // ----------------------------------------------------------------------------------------------

  intCon =
    ( digit {digit} | digit {digit} CONTEXT ("." notDigit)
    | ("0x" | "0X") hexDigit {hexDigit}
    )
    ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"].

  // ----------------------------------------------------------------------------------------------

  realCon =
    "." digit {digit} 
    [("e" | "E") ["+" | "-"] digit {digit}] 
    ["F" | "f" | "D" | "d" | "M" | "m"]
  | digit {digit} 
    ( "." digit {digit} 
      [("e" | "E" ) ["+" | "-"] digit {digit} ] 
      ["F" | "f" | "D" | "d" | "M" | "m"]
    | ("e" | "E") ["+" | "-"] digit {digit}
      ["F" | "f" | "D" | "d" | "M" | "m"]
    | "F" | "f" | "D" | "d" | "M" | "m"
    ).

  // ----------------------------------------------------------------------------------------------

  charCon =
    "'" ( char
        | "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v"
        | "\\x" hexDigit [hexDigit] [hexDigit] [hexDigit]
        | "\\u" hexDigit hexDigit hexDigit hexDigit
        | "\\U" hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
        ) 
    "'".

  // ----------------------------------------------------------------------------------------------

  stringCon =
    "\""  { regularStringChar
          | "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v"
          | "\\x" hexDigit [hexDigit] [hexDigit] [hexDigit]
          | "\\u" hexDigit hexDigit hexDigit hexDigit
          | "\\U" hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
          } 
    "\""
  | "@\"" {verbatimStringChar | "\"\""} "\"".

  // ----------------------------------------------------------------------------------------------
  // Keyword names needed in LL(1) resolvers
  // ----------------------------------------------------------------------------------------------
  
  abstract   = "abstract".
  as         = "as".
  base       = "base".
  bool       = "bool".
  break      = "break".
  byte       = "byte".
  case       = "case".
  catch      = "catch".
  char       = "char".
  checked    = "checked".
  class      = "class".
  const      = "const".
  continue   = "continue".
  decimal    = "decimal".
  default    = "default".
  delegate   = "delegate".
  do         = "do".
  double     = "double".
  else       = "else".
  enum       = "enum".
  event      = "event".
  explicit   = "explicit".
  extern     = "extern".
  false      = "false".
  finally    = "finally".
  fixed      = "fixed".
  float      = "float".
  for        = "for".
  foreach    = "foreach".
  goto       = "goto".
  if         = "if".
  implicit   = "implicit".
  in         = "in".
  int        = "int".
  interface  = "interface".
  internal   = "internal".
  is         = "is".
  lock       = "lock".
  long       = "long".
  namespace  = "namespace".
  new        = "new".
  null       = "null".
  object     = "object".
  operator   = "operator".
  out        = "out".
  override   = "override".
  params     = "params".
  private    = "private".
  protected  = "protected".
  public     = "public".
  readonly   = "readonly".
  ref        = "ref".
  return     = "return".
  sbyte      = "sbyte".
  sealed     = "sealed".
  short      = "short".
  sizeof     = "sizeof".
  stackalloc = "stackalloc".
  static     = "static".
  string     = "string".
  struct     = "struct".
  switch     = "switch".
  this       = "this".
  throw      = "throw".
  true       = "true".
  try        = "try".
  typeof     = "typeof".
  uint       = "uint".
  ulong      = "ulong".
  unchecked  = "unchecked".
  unsafe     = "unsafe".
  ushort     = "ushort".
  usingKW    = "using".
  virtual    = "virtual".
  void       = "void".
  volatile   = "volatile".
  while      = "while".

  // ----------------------------------------------------------------------------------------------
  // Operators and special characters needed in LL(1) resolvers
  // ----------------------------------------------------------------------------------------------

  and        = "&".
  andassgn   = "&=".
  assgn      = "=".
  colon      = ":".
  comma      = ",".
  dec        = "--".
  divassgn   = "/=".
  dot        = ".".
  dblcolon   = "::".
  eq         = "==".
  gt         = ">".
  gteq       = ">=".
  inc        = "++".
  lbrace     = "{".
  lbrack     = "[".
  lpar       = "(".
  lshassgn   = "<<=".
  lt         = "<".
  ltlt       = "<<".
  minus      = "-".
  minusassgn = "-=".
  modassgn   = "%=".
  neq        = "!=".
  not        = "!".
  orassgn    = "|=".
  plus       = "+".
  plusassgn  = "+=".
  question   = "?".
  rbrace     = "}".
  rbrack     = "]".
  rpar       = ")".
  scolon     = ";".
  tilde      = "~".
  times      = "*".
  timesassgn = "*=".
  xorassgn   = "^=".
  larrow     = "=>".

PRAGMAS

  // ----------------------------------------------------------------------------------------------
  // Preprocessor directives.                                               
  // The exact parsing of their syntax is left for later processing.
  // ----------------------------------------------------------------------------------------------

  ppDefine  = "#" {ws} "define" {notNewLine} newLine.     (. AddConditionalDirective(la); .)
  ppUndef   = "#" {ws} "undef" {notNewLine} newLine.      (. RemoveConditionalDirective(la); .)
  ppIf      = "#" {ws} "if" {notNewLine} newLine.         (. IfPragma(la); .)
  ppElif    = "#" {ws} "elif" {notNewLine} newLine.       (. ElifPragma(la); .) 
  ppElse    = "#" {ws} "else" {notNewLine} newLine.       (. ElsePragma(la); .) 
  ppEndif   = "#" {ws} "endif" {notNewLine} newLine.      (. EndifPragma(la); .) 
  ppLine    = "#" {ws} "line" {notNewLine} newLine.       (. LinePragma(la); .) 
  ppError   = "#" {ws} "error" {notNewLine} newLine.      (. ErrorPragma(la); .) 
  ppWarning = "#" {ws} "warning" {notNewLine} newLine.    (. WarningPragma(la); .) 
  ppPragma  = "#" {ws} "pragma" {notNewLine} newLine.     (. PragmaPragma(la); .) 
  ppRegion  = "#" {ws} "region" {notNewLine} newLine.     (. RegionPragma(la); .) 
  ppEndReg  = "#" {ws} "endregion" {notNewLine} newLine.  (. EndRegionPragma(la); .) 

  // ----------------------------------------------------------------------------------------------
  // Comments are handled as special pragmas
  // ----------------------------------------------------------------------------------------------
  
  cBlockCom = "/*" { "/" | blockComCh | "*"{"*"} blockComCh } "*"{"*"}"/".  //(. CommentHandler.HandleBlockComment(la); .)
  cLineCom  = "//" { notNewLine } newLine.                                  //(. CommentHandler.HandleLineComment(la); .)

IGNORE eol + cr + tab

PRODUCTIONS

// ================================================================================================
// This is the definition of C# 3.0 grammar. The definition contains the grammar syntax definition 
// with the corresponding semantic actions. This is main entry point of the grammar parser.
// ================================================================================================
CS3
=                                                               
  { IF (IsExternAliasDirective()) ExternAliasDirective<SourceFileNode> }
  { UsingDirective<SourceFileNode> }
  { IF (IsGlobalAttrTarget()) GlobalAttributes }
  { NamespaceMemberDeclaration<SourceFileNode> }
.

// ------------------------------------------------------------------------------------------------
// "extern alias" directive that is used in conjunction with a file or with a namespace
// ------------------------------------------------------------------------------------------------
ExternAliasDirective<NamespaceScopeNode parentNode>
(.
   Token start;
   Token alias;
   Token identifier;
.)
=
  "extern"   
  (. 
     SignRealToken(); 
     start = t;
  .)
  ident
  (. 
     if (t.val != "alias") Error1003(t, "alias"); 
     alias = t;
  .)
  ident      
  (. identifier = t; .)
  ";"
  (. parentNode.AddExternAlias(start, alias, identifier, t); .)
.

// ------------------------------------------------------------------------------------------------
// "using" directive that is used in conjunction with a source file or a namespace.
// ------------------------------------------------------------------------------------------------
UsingDirective<NamespaceScopeNode parentNode>
(.
   Token alias = null;
   Token eq = null;
   TypeOrNamespaceNode nsNode = null;
.)                                     
=                           
  "using"
  (. 
     SignRealToken();
     Token start = t;
  .)
  [ IF (IsAssignment()) 
    ident                 
    (. alias = t; .)
    "="
    (. eq = t; .)
  ]
  TypeName<out nsNode> 
  ";"
  (. 
     var node = (alias == null)
       ? parentNode.AddUsing(start, nsNode, t)
       : parentNode.AddUsingWithAlias(start, alias, eq, nsNode, t);
     Terminate(node);
  .)
.

// ------------------------------------------------------------------------------------------------
// Global attributes belonging to a file. This element accepts only attributes with "assembly" or 
// "module" scope. All global attributes are assigned to the current source file node, so this
// production does not have any input parameter.
// ------------------------------------------------------------------------------------------------
GlobalAttributes
=
  (. AttributeDecorationNode globAttrNode = null; .)
  "["
  (. 
     SignRealToken();
     globAttrNode = new AttributeDecorationNode(t);
  .)
  ident                        
  (. globAttrNode.TargetToken = t; .) 
  ":"
  (. var separator = t; .)
  (. AttributeNode attrNode; .)
  Attribute<out attrNode>
  (. globAttrNode.Attributes.Add(separator, attrNode); .)
  { 
    IF (NotFinalComma()) ","   
    (. separator = t; .)
    Attribute<out attrNode> 
    (. globAttrNode.Attributes.Add(separator, attrNode); .)
  } 
  [ 
    ","
    (. globAttrNode.OrphanSeparator = t; .) 
  ]
  "]"                          
  (. 
     Terminate(globAttrNode);
     SourceFileNode.GlobalAttributes.Add(globAttrNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a namespace member (type or nested namespace).
// ------------------------------------------------------------------------------------------------
NamespaceMemberDeclaration<NamespaceScopeNode parentNode>  
=
  "namespace"    
  (. 
     SignRealToken();
     Token startToken = t; 
     var nsDecl = new NamespaceDeclarationNode(parentNode, t);
  .)
  ident
  (. nsDecl.NameTags.Add(t); .)
  {              
    "."
    (. var sepToken = t; .)
    ident
    (. nsDecl.NameTags.Add(sepToken, t); .)
  } 
  "{"
  (. nsDecl.OpenBracket = t; .)
  { IF (IsExternAliasDirective()) ExternAliasDirective<nsDecl> } 
  { UsingDirective<nsDecl> } 
  { NamespaceMemberDeclaration<nsDecl> } 
  "}"
  (. 
     nsDecl.CloseBracket = t;
     Terminate(nsDecl);
  .)
  [ 
    ";"
    (. Terminate(nsDecl); .)
  ]
  (.
     parentNode.NamespaceDeclarations.Add(nsDecl);
     parentNode.InScopeDeclarations.Add(nsDecl);
  .)
  | 
    (. 
       var mod = new ModifierNodeCollection();
       var attrNodes = new AttributeDecorationNodeCollection();
    .)  
    AttributeDecorations<attrNodes>
    ModifierList<mod> 
    (. TypeDeclarationNode typeDecl; .)
    TypeDeclaration<null, out typeDecl>
    (.
       typeDecl.AttributeDecorations = attrNodes;
       typeDecl.Modifiers = mod;
       typeDecl.DeclaringNamespace = parentNode;
       parentNode.TypeDeclarations.Add(typeDecl);
       parentNode.InScopeDeclarations.Add(typeDecl);
    .)
.

// ------------------------------------------------------------------------------------------------
// Type declaration within a file or a namespace.
// ------------------------------------------------------------------------------------------------
TypeDeclaration<TypeDeclarationNode declaringType, out TypeDeclarationNode typeDecl>            
= 
  (. 
     typeDecl = null; 
     Token partialToken = null;
  .)
  (                                                             
    [ 
      "partial"                                      
      (. partialToken = t; .)
    ]
    ( 
      ClassDeclaration<out typeDecl> |                                                           
      StructDeclaration<out typeDecl> |                                                           
      InterfaceDeclaration<out typeDecl>                                                           
    )                                                          
    | EnumDeclaration<out typeDecl> 
    | DelegateDeclaration<out typeDecl>
  )
  (. 
     if (typeDecl != null)
     {
       typeDecl.PartialToken = partialToken;
       typeDecl.DeclaringType = declaringType;
       Terminate(typeDecl);
     }
  .)                               
.

// ------------------------------------------------------------------------------------------------
// Class declaration within a file, a namespace or a type declaration.
// ------------------------------------------------------------------------------------------------
ClassDeclaration<out TypeDeclarationNode typeDecl>
=
  "class"                                            
  (. var start = t; .)
  ident    
  (. 
     var classDecl = new ClassDeclarationNode(start, t);
     typeDecl = classDecl;
  .)
  [ TypeParameterList<typeDecl> ] 
  [ BaseTypeList<typeDecl> ]
  {                                                  
    (. TypeParameterConstraintNode constrNode; .)
    TypeParameterConstraintsClause<out constrNode>   
    (. typeDecl.TypeParameterConstraints.Add(constrNode); .)
  } ClassBody<classDecl>
  (. Terminate(typeDecl); .)
  [ 
    ";" 
    (. Terminate(typeDecl); .)
  ]                                                       
.

// ------------------------------------------------------------------------------------------------
// Base type and interface declaration of a class, struct or interface.
// ------------------------------------------------------------------------------------------------
BaseTypeList<TypeDeclarationNode typeDecl>
=
  (. TypeOrNamespaceNode typeNode; .)
  ":"
  (. typeDecl.ColonToken = t; .)                        
  ClassType<out typeNode>     
  (. typeDecl.BaseTypes.Add(typeNode); .)
  { 
    ","  
    (. var separator = t; .)
    ClassType<out typeNode>    
    (. 
       typeNode.SeparatorToken = separator;
       typeDecl.BaseTypes.Add(typeNode); 
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Body declaration of a class.
// ------------------------------------------------------------------------------------------------
ClassBody<ClassDeclarationNode typeDecl>
=
  "{" 
  (. typeDecl.OpenBrace = t; .)
  {
    (. var attrNodes = new AttributeDecorationNodeCollection(); .)
    AttributeDecorations<attrNodes>
    (. var mod = new ModifierNodeCollection(); .)                          
    ModifierList<mod>
    (. MemberDeclarationNode memNode; .)
    ClassMemberDeclaration<attrNodes, mod, typeDecl, out memNode>
    (. 
       if (memNode != null) 
       {
         memNode.AttributeDecorations = attrNodes;
         memNode.Modifiers = mod;
         typeDecl.MemberDeclarations.Add(memNode); 
       }
    .)
  }
  "}"
  (. typeDecl.CloseBrace = t; .)
.

// ------------------------------------------------------------------------------------------------
// Structure declaration within a file, a namespace or a type declaration.
// ------------------------------------------------------------------------------------------------
StructDeclaration<out TypeDeclarationNode typeDecl>
=
  "struct"
  (. var start = t; .)
  ident
  (. 
     var structDecl = new StructDeclarationNode(start, t);
     typeDecl = structDecl;
  .)
  [ TypeParameterList<typeDecl> ]
  [ BaseTypeList<typeDecl> ]
  {                                                
    (. TypeParameterConstraintNode constrNode; .)
    TypeParameterConstraintsClause<out constrNode> 
    (. typeDecl.TypeParameterConstraints.Add(constrNode); .)
  } 
  StructBody<structDecl>
  (. Terminate(typeDecl); .)
  [ 
    ";" 
    (. Terminate(typeDecl); .)
  ]                                                       
.

// ------------------------------------------------------------------------------------------------
// Body declaration of a structure.
// ------------------------------------------------------------------------------------------------
StructBody<StructDeclarationNode typeDecl>
=
  "{" 
  (. typeDecl.OpenBrace = t; .)
  {
    (. var attrNodes = new AttributeDecorationNodeCollection(); .)
    AttributeDecorations<attrNodes>
    (. var mod = new ModifierNodeCollection(); .)                             
    ModifierList<mod>
    (. MemberDeclarationNode memNode; .)
    StructMemberDeclaration<attrNodes, mod, typeDecl, out memNode>
  }
  "}"   
  (. typeDecl.CloseBrace = t; .)
.

// ------------------------------------------------------------------------------------------------
// Enumerated type declaration within a file, a namespace or a type declaration.
// ------------------------------------------------------------------------------------------------
EnumDeclaration<out TypeDeclarationNode typeDecl>
=
  "enum"                         
  (. var start = t; .)
  ident                          
  (. 
     var enumDecl = new EnumDeclarationNode(start, t);
     typeDecl = enumDecl;
  .)
  [ 
    ":"                          
    (. TypeOrNamespaceNode typeNode = null; .)
    ( ClassType<out typeNode> | IntegralType<out typeNode> )
    (. enumDecl.EnumBase = typeNode; .)
  ] 
  EnumBody<enumDecl>                   
  (. Terminate(typeDecl); .)
  [ 
    ";"                          
    (. Terminate(typeDecl); .)
  ]                                                       
.

// ------------------------------------------------------------------------------------------------
// Body declaration of an enumerated type.
// ------------------------------------------------------------------------------------------------
EnumBody<EnumDeclarationNode typeDecl>
=
  "{" 
  (. typeDecl.OpenBrace = t; .)
  [ 
    (. EnumValueNode valNode; .)
    EnumMemberDeclaration<out valNode> 
    (. typeDecl.Values.Add(valNode); .)
    { 
      IF (NotFinalComma())  
      "," 
      (. var separator = t; .)
      SYNC EnumMemberDeclaration<out valNode>
      (. typeDecl.Values.Add(separator, valNode); .)
    } 
    [ 
      "," 
      (. typeDecl.OrphanSeparator = t; .)
    ] 
  ] 
  SYNC "}"
  (. 
     typeDecl.CloseBrace = t; 
     Terminate(typeDecl);
  .)
.

// ------------------------------------------------------------------------------------------------
// Enumeration value declaration within an enumeration type.
// ------------------------------------------------------------------------------------------------
EnumMemberDeclaration<out EnumValueNode valNode>  
=                             
  (. 
     valNode = null;
     var attrNodes = new AttributeDecorationNodeCollection();
  .)
  AttributeDecorations<attrNodes>
  ident                      
  (. 
     valNode = new EnumValueNode(t);
     valNode.AttributeDecorations = attrNodes;
  .)
  [ 
    "=" 
    (.
       valNode.EqualToken = t;
       ExpressionNode exprNode;
    .)
    Expression<out exprNode> 
    (. valNode.Expression = exprNode; .)
  ]     
  (. Terminate(valNode); .)
.

// ------------------------------------------------------------------------------------------------
// Delegate type declaration within a file, a namespace or a type declaration.
// ------------------------------------------------------------------------------------------------
DelegateDeclaration<out TypeDeclarationNode typeDecl>
=
  "delegate"                                       
  (. 
     var start = t;
     TypeOrNamespaceNode typeNode;
  .)
  Type<out typeNode>
  ident
  (. 
     var ddNode = new DelegateDeclarationNode(start, t);
     typeDecl = ddNode;
     ddNode.TypeName = typeNode;
  .)
  [ TypeParameterList<typeDecl> ]
  "(" 
  (. var parList = new FormalParameterListNode(t); .)
  [ FormalParameterList<parList> ] 
  ")"
  (. Terminate(parList); .)
  {                                                
    (. TypeParameterConstraintNode constrNode; .)
    TypeParameterConstraintsClause<out constrNode> 
    (. typeDecl.TypeParameterConstraints.Add(constrNode); .)
  } 
  ";"                                                         
  (. Terminate(typeDecl); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a class member.
// ------------------------------------------------------------------------------------------------
ClassMemberDeclaration<AttributeDecorationNodeCollection attrNodes, ModifierNodeCollection mod,
  TypeDeclarationNode typeDecl, out MemberDeclarationNode memNode>
  (. memNode = null; .)
=
  StructMemberDeclaration<attrNodes, mod, typeDecl, out memNode>
  | 
    "~" 
    (. 
       var finNode = new FinalizerDeclarationNode(t);
       memNode = finNode;
    .)
    ident   
    (. finNode.IdentifierToken = t; .)
    "(" 
    (. finNode.FormalParameters = new FormalParameterListNode(t); .)
    ")" 
    (. Terminate(finNode.FormalParameters); .)
    ( 
      (. BlockStatementNode blockNode; .)
      Block<out blockNode> 
      (. finNode.Body = blockNode; .)
    | ";"
      (. finNode.ClosingSemicolon = t; .) 
    )
    (. Terminate(memNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a structure member.
// ------------------------------------------------------------------------------------------------
StructMemberDeclaration<AttributeDecorationNodeCollection attrNodes, ModifierNodeCollection mod,
  TypeDeclarationNode typeDecl, out MemberDeclarationNode memNode>        
=                                             
  (. memNode = null; .)
  (                                                                          
    ConstMemberDeclaration<out memNode> 
  | EventDeclaration<out memNode> 
  | IF (la.kind == _ident && Peek(1).kind == _lpar)                         
      ConstructorDeclaration<out memNode> 
  | 
    // --- Partial method declaration
    IF (IsPartialMethod())
    "partial"
    (. 
       var partialToken = t;
       TypeOrNamespaceNode typeNode; 
    .)
    Type<out typeNode>
    (. TypeOrNamespaceNode nameNode; .)
    MemberName<out nameNode>
    (.
       var metNode = new MethodDeclarationNode(partialToken);
       metNode.TypeName = typeNode;
       metNode.MemberName = nameNode;
       memNode = metNode;
    .)
    MethodDeclaration<metNode>
  | 
    (. TypeOrNamespaceNode typeNode; .)
    Type<out typeNode>
    ( 
        // --- Overloadable operator declaration
        (. 
           var opNode = new OperatorDeclarationNode(typeNode.StartToken); 
           opNode.TypeName = typeNode;
           memNode = opNode;
        .)
        OperatorDeclaration<opNode>
      | 
        // --- Field declaration
        IF (IsFieldDecl()) 
        (. 
           var fiNode = new FieldDeclarationNode(typeNode.StartToken); 
           fiNode.TypeName = typeNode;
           memNode = fiNode;
        .)
        FieldMemberDeclarators<fiNode> 
        ";"
        (. Terminate(memNode); .)
      |                                  
        // --- Members than can be used in explicit interface implementations:
        // --- Property declaration        
        (. TypeOrNamespaceNode nameNode; .)
        MemberName<out nameNode>
        ( 
          (. 
             var propNode = new PropertyDeclarationNode(typeNode.StartToken);
             propNode.TypeName = typeNode; 
             propNode.MemberName = nameNode;
             memNode = propNode;
          .)
          PropertyDeclaration<propNode>
        | 
          // --- Explicit indexer declaration
          (.
             var indNode = new IndexerDeclarationNode(typeNode.StartToken);
             indNode.TypeName = typeNode;
             indNode.MemberName = nameNode;
             memNode = indNode;
          .)
          "."
          (. indNode.MemberNameSeparator = t; .)
          IndexerDeclaration<indNode>
        |
          // --- Method declaration 
          (.
             var metNode = new MethodDeclarationNode(typeNode.StartToken);
             metNode.TypeName = typeNode;
             metNode.MemberName = nameNode;
             memNode = metNode;
          .)
          MethodDeclaration<metNode>
        )
      | 
        // --- Simple indexer declaration
        (. 
           var indNode = new IndexerDeclarationNode(typeNode.StartToken);
           indNode.TypeName = typeNode;
        .)
        IndexerDeclaration<indNode>
    )
    | CastOperatorDeclaration<out memNode>
    |                                           
      // --- Nested type declaration    
      (. TypeDeclarationNode nestedTypeNode; .)
      TypeDeclaration<typeDecl, out nestedTypeNode> 
      (. 
         nestedTypeNode.AttributeDecorations = attrNodes;
         nestedTypeNode.Modifiers = mod;
         nestedTypeNode.DeclaringNamespace = typeDecl.DeclaringNamespace;
         nestedTypeNode.DeclaringType = typeDecl;
         typeDecl.NestedDeclarations.Add(nestedTypeNode);
         typeDecl.NestedTypes.Add(nestedTypeNode);
      .)
  )
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "const" member.
// ------------------------------------------------------------------------------------------------
ConstMemberDeclaration<out MemberDeclarationNode memNode>
=                                    
  (. memNode = null; .)
  "const"
  (. 
     var constNode = new ConstDeclarationNode(t);
     memNode = constNode;
     TypeOrNamespaceNode typeNode;
  .)
  Type<out typeNode>
  (. 
     memNode.TypeName = typeNode; 
     ConstTagNode tagNode;
  .)
  SingleConstMember<out tagNode>
  (. constNode.ConstTags.Add(tagNode); .)
  {
    "," 
    (. var separator = t; .)
    SingleConstMember<out tagNode> 
    (. constNode.ConstTags.Add(separator, tagNode); .)
  } 
  ";"
  (. Terminate(memNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a single "const" member.
// ------------------------------------------------------------------------------------------------
SingleConstMember<out ConstTagNode tagNode>
=
  ident
  (. tagNode = new ConstTagNode(t); .)
  "="
  (. 
     tagNode.EqualToken = t;
     ExpressionNode exprNode;
  .)
  Expression<out exprNode>
  (. 
     tagNode.Expression = exprNode;
     Terminate(tagNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a event member.
// ------------------------------------------------------------------------------------------------
EventDeclaration<out MemberDeclarationNode memNode>
  (. memNode = null; .)
=
  (. TypeOrNamespaceNode typeNode; .)
  "event"
  (. var eventToken = t; .)
  Type<out typeNode>
  ( 
    IF (IsFieldDecl()) 
    (. 
       var fiNode = new FieldDeclarationNode(eventToken); 
       memNode = fiNode;
       fiNode.TypeName = typeNode;
    .)
    FieldMemberDeclarators<fiNode> 
    ";"
    (. Terminate(fiNode); .)
  |                              
    (. 
       var evpNode = new EventPropertyDeclarationNode(t) ;
       memNode = evpNode;
    .)
    TypeName<out typeNode> 
    (. evpNode.TypeName = typeNode; .)
    "{"
    (. evpNode.OpenBrace = t; .)
    EventAccessorDeclarations<evpNode>
    "}"
    (. 
       evpNode.CloseBrace = t;
       Terminate(evpNode);
    .)
  )
.

// ------------------------------------------------------------------------------------------------
// Declaration of a constructor member.
// ------------------------------------------------------------------------------------------------
ConstructorDeclaration<out MemberDeclarationNode memNode>
= 
  (. memNode = null; .)
  ident
  (. 
     var cstNode = new ConstructorDeclarationNode(t);
     memNode = cstNode;
  .)
  "(" 
  (. cstNode.FormalParameters = new FormalParameterListNode(t); .)
  [                                    
    FormalParameterList<cstNode.FormalParameters>
  ] 
  ")" 
  (. Terminate(cstNode.FormalParameters); .)
  [                                        
    ":" 
    (. 
       cstNode.Colon = t; 
       ExpressionNode scopeNode = null;
    .)
    ( "base"          
      (. scopeNode = new BaseNode(t); .)
    | "this"              
      (. scopeNode = new ThisNode(t); .)
    ) 
    "("
    (.
       var invNode = new MethodInvocationOperatorNode(t);
       invNode.ScopeOperand = scopeNode;
    .)
    CurrentArgumentList<invNode.Arguments>
    ")"
    (.
       Terminate(invNode);
       cstNode.Initializer = invNode;
    .)
  ] 
  ( 
    (. BlockStatementNode blockNode; .)
    Block<out blockNode>
    (. cstNode.Body = blockNode; .) 
  | ";" 
    (. cstNode.ClosingSemicolon = t; .)
  )   
  (. Terminate(memNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a property member.
// ------------------------------------------------------------------------------------------------
PropertyDeclaration<PropertyDeclarationNodeBase propNode>
=                  
  "{" 
  (. propNode.OpenBrace = t; .)
  AccessorDeclarations<propNode> 
  "}"             
  (. 
     propNode.CloseBrace = t;
     Terminate(propNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of an indexer member.
// ------------------------------------------------------------------------------------------------
IndexerDeclaration<IndexerDeclarationNode indNode>
=
  "this"
  (. indNode.ThisToken = t; .)
  "[" 
  (. indNode.FormalParameters = new FormalParameterListNode(t); .)
  [ FormalParameterList<indNode.FormalParameters> ] 
  "]" 
  (. Terminate(indNode.FormalParameters); .)
  "{" 
  (. indNode.OpenBrace = t; .)
      AccessorDeclarations<indNode> 
  "}"
  (. indNode.CloseBrace = t; .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a method member.
// ------------------------------------------------------------------------------------------------
MethodDeclaration<MethodDeclarationNode metNode>
=                                                    
  [ TypeParameterList<metNode> ]
  "(" 
  (. metNode.FormalParameters = new FormalParameterListNode(t); .)
  [ FormalParameterList<metNode.FormalParameters> ] 
  ")"
  (. Terminate(metNode.FormalParameters); .)
  {                                                 
    (. TypeParameterConstraintNode constrNode; .)
    TypeParameterConstraintsClause<out constrNode>  
    (. metNode.TypeParameterConstraints.Add(constrNode); .)
  } 
  ( 
    (. BlockStatementNode blockNode; .)
    Block<out blockNode>
    (. metNode.Body = blockNode; .)
  | ";"
    (. metNode.ClosingSemicolon = t; .)
  )
  (. Terminate(metNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a cast operator member.
// ------------------------------------------------------------------------------------------------
CastOperatorDeclaration<out MemberDeclarationNode memNode>
  (. memNode = null; .)
=
  ( 
    "implicit"                        
  | "explicit"
  )
  (. 
     var copNode = new CastOperatorDeclarationNode(t); 
     memNode = copNode;
  .)
  "operator"                        
  (. 
     copNode.OperatorToken = t; 
     TypeOrNamespaceNode typeNode; 
  .)
  Type<out typeNode>
  (. copNode.TypeName = typeNode; .)
  "("   
  (. copNode.FormalParameters = new FormalParameterListNode(t); .)
  [ FormalParameterList<copNode.FormalParameters> ]   
  ")"
  (. Terminate(copNode.FormalParameters); .)
  ( 
    (. BlockStatementNode blockNode; .)
    Block<out blockNode>
    (. copNode.Body = blockNode; .)
  | 
    ";" 
    (. copNode.ClosingSemicolon = t; .)
  )
  (. Terminate(memNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of an overloaded operator member.
// ------------------------------------------------------------------------------------------------
OperatorDeclaration<OperatorDeclarationNode opNode>
=
  "operator" 
  (. opNode.OperatorToken = t; .)
  OverloadableOp<opNode>
  "("
  (. opNode.FormalParameters = new FormalParameterListNode(t); .)
  [ FormalParameterList<opNode.FormalParameters> ]
  ")"
  (. Terminate(opNode.FormalParameters); .)
  ( 
    (. BlockStatementNode blockNode; .)
    Block<out blockNode>
    (. opNode.Body = blockNode; .)
  | 
    ";" 
    (. opNode.ClosingSemicolon = t; .)
  )
.

// ------------------------------------------------------------------------------------------------
// Interface declaration within a file, a namespace or a type declaration.
// ------------------------------------------------------------------------------------------------
InterfaceDeclaration<out TypeDeclarationNode typeDecl>
=
  "interface"       
  (. var start = t; .)
  ident            
  (. 
     var intfDecl = new InterfaceDeclarationNode(start, t);
     typeDecl = intfDecl;
  .)
  [ TypeParameterList<typeDecl> ]
  [ BaseTypeList<typeDecl> ]
  {                                                   
    (. TypeParameterConstraintNode constrNode; .)
    TypeParameterConstraintsClause<out constrNode>    
    (. typeDecl.TypeParameterConstraints.Add(constrNode); .)
  }
  "{" 
  (. intfDecl.OpenBrace = t; .)
  { InterfaceMemberDeclaration<intfDecl> } 
  "}" 
  (. 
     intfDecl.CloseBrace = t;
     Terminate(typeDecl);
  .)
  [ 
    ";" 
    (. Terminate(typeDecl); .)
  ]                                                       
.

// ------------------------------------------------------------------------------------------------
// Declaration of an interface member.
// ------------------------------------------------------------------------------------------------
InterfaceMemberDeclaration<InterfaceDeclarationNode typeDecl>
=                              
  (. 
     var mod = new ModifierNodeCollection();
     var attrNodes = new AttributeDecorationNodeCollection();
     Token identifier;
     MemberDeclarationNode memNode = null;
  .)
  AttributeDecorations<attrNodes>
  ModifierList<mod>
  ( 
    (. TypeOrNamespaceNode typeNode; .)
    Type<out typeNode>
    (                          
      ident                   
      (. identifier = t; .)
      ( 
        (.
           var metNode = new MethodDeclarationNode(typeNode.StartToken);
           metNode.TypeName = typeNode;
           metNode.MemberName = TypeOrNamespaceNode.CreateTypeNode(identifier);
           memNode = metNode;
        .)
        MethodDeclaration<metNode>        
      | // --- Interface property
        (. 
           var propNode = new PropertyDeclarationNode(typeNode.StartToken);
           propNode.TypeName = typeNode;
           propNode.MemberName = TypeOrNamespaceNode.CreateTypeNode(identifier);
           memNode = propNode;
        .)
        "{" 
        (. propNode.OpenBrace = t; .)
        InterfaceAccessors<propNode>
        "}" 
        (. 
           propNode.CloseBrace = t; 
           Terminate(memNode);
        .)
      )
    |  
      "this" 
      (. 
         var indNode = new IndexerDeclarationNode(typeNode.StartToken);
         indNode.TypeName = typeNode;
         indNode.ThisToken = t;
         memNode = indNode;
      .)
      "[" 
      (. indNode.FormalParameters = new FormalParameterListNode(t); .)
      [ FormalParameterList<indNode.FormalParameters> ] 
      "]" 
      (. Terminate(indNode.FormalParameters); .)
      "{" 
      (. indNode.OpenBrace = t; .)
      InterfaceAccessors<indNode>
      "}" 
      (. 
         indNode.CloseBrace = t; 
         Terminate(indNode);
      .)
    )
  | InterfaceEventDeclaration<out memNode>
  ) 
  (.
     if (memNode != null) 
     {
       memNode.AttributeDecorations = attrNodes;
       memNode.Modifiers = mod;
       typeDecl.MemberDeclarations.Add(memNode);
     }
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of an interface event member.
// ------------------------------------------------------------------------------------------------
InterfaceEventDeclaration<out MemberDeclarationNode memNode>
=
  "event" 
  (. 
     var ieNode = new InterfaceEventDeclarationNode(t);
     memNode = ieNode;
  .)
  (. TypeOrNamespaceNode typeNode; .)
  Type<out typeNode>
  (. ieNode.TypeName = typeNode; .)
  ident 
  (. ieNode.IdentifierToken = t; .)
  ";"
  (. Terminate(memNode); .)
.

// ------------------------------------------------------------------------------------------------
// Local variable declaration within a block.
// ------------------------------------------------------------------------------------------------
LocalVariableDeclaration<out LocalVariableNode varNode> 
=
  (. 
     TypeOrNamespaceNode typeNode = null;
     varNode = null;
  .)
  (
    IF (IsVar())
    ident
    (. typeNode = TypeOrNamespaceNode.CreateTypeNode(t); .)
  |
    Type<out typeNode>
  )
  (. 
     if (typeNode != null) varNode = new LocalVariableNode(typeNode); 
     LocalVariableTagNode varTagNode;
  .)
  LocalVariableDeclarator<out varTagNode>
  (. if (varNode != null) varNode.VariableTags.Add(varTagNode); .)
  { 
    "," 
    (. var separator = t; .)
    LocalVariableDeclarator<out varTagNode> 
    (. 
       if (varNode != null) varNode.VariableTags.Add(separator, varTagNode); 
    .)
  }
  (. Terminate(varNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declares a local variable within a block with the specified type.
// ------------------------------------------------------------------------------------------------
LocalVariableDeclarator<out LocalVariableTagNode varDeclNode>
= 
  ident 
  (. varDeclNode = new LocalVariableTagNode(t); .)       
  [
    "="
    (. var start = t; .) 
    (   
      (. VariableInitializerNode varInitNode; .)
      VariableInitializer<out varInitNode> 
      (. varDeclNode.Initializer = varInitNode; .)
    | 
      "stackalloc" 
      (. 
         var stcInitNode = new StackAllocInitializerNode(start);
         varDeclNode.Initializer = stcInitNode;
         stcInitNode.StackAllocToken = t;
      .)
      (. TypeOrNamespaceNode typeNode; .)
      Type<out typeNode> 
      (. stcInitNode.TypeName = typeNode; .)
      "[" 
      (. 
         stcInitNode.OpenSquareToken = t;
         ExpressionNode exprNode; 
      .)
      Expression<out exprNode> 
      (. stcInitNode.Expression = exprNode; .)
      "]" 
      (. 
         stcInitNode.CloseSquareToken = t;
         Terminate(stcInitNode);
      .)
    )
  ]
  (. Terminate(varDeclNode); .)
. 

// ------------------------------------------------------------------------------------------------
// Creates an initializer.
// ------------------------------------------------------------------------------------------------
VariableInitializer<out VariableInitializerNode initNode> 
  (. 
     initNode = null; 
     ExpressionNode exprNode; 
  .)
= 
    Expression<out exprNode>  
    (. 
       var exprInitNode = new ExpressionInitializerNode(exprNode);
       initNode = exprInitNode;
    .)
  | 
    (. ArrayInitializerNode arrInitNode; .)
    ArrayInitializer<out arrInitNode> 
    (. initNode = arrInitNode; .)
.

// -----------------------------------------------------------------------------------------------
// Creates an array initializer.
// -----------------------------------------------------------------------------------------------
ArrayInitializer<out ArrayInitializerNode initNode> 
= 
  (. initNode = null; .)
  "{"
  (. initNode = new ArrayInitializerNode(t); .)
  [ 
    (. VariableInitializerNode varInitNode; .)
    VariableInitializer<out varInitNode> 
    (. 
       var initItem = new ArrayItemInitializerNode(varInitNode);
       initNode.Items.Add(initItem);
    .)
    {
      IF (NotFinalComma()) 
      ","
      (. initItem.Separator = t; .)
      VariableInitializer<out varInitNode> 
      (. 
         initItem = new ArrayItemInitializerNode(varInitNode);
         initNode.Items.Add(initItem);
    .)
    } 
    [ 
      ","
      (. initItem.Separator = t; .)
    ] 
  ] 
  "}" 
  (. Terminate(initNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines an item on the list of formal parameters.
// ------------------------------------------------------------------------------------------------
FormalParameterTag<out FormalParameterNode parNode>
=
  (. 
     var attrNodes = new AttributeDecorationNodeCollection();
     parNode = null;
     var modifier = FormalParameterModifier.In;
     Token start = null;
  .)
  AttributeDecorations<attrNodes>                                       
  [ 
    (
      "ref"                            
      (. modifier = FormalParameterModifier.Ref; .) 
    | "out"                          
      (. modifier = FormalParameterModifier.Out; .)
    | "this"                         
      (. modifier = FormalParameterModifier.This; .)
    | "params"                    
      (. modifier = FormalParameterModifier.Params; .)
    )
    (. start = t; .)
  ] 
  (. TypeOrNamespaceNode typeNode; .)
  Type<out typeNode>
  (. if (start == null) start = typeNode.StartToken; .)
  ident                              
  (. 
     parNode = new FormalParameterNode(start);
     parNode.Modifier = modifier;
     parNode.IdentifierToken = t;
     parNode.TypeName = typeNode;
     Terminate(parNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a formal parameter list
//   parsNode List holding the formal parameter declarations.
// ------------------------------------------------------------------------------------------------
FormalParameterList<FormalParameterListNode parsNode>  
  (. FormalParameterNode node; .)                                                
=                                    
  FormalParameterTag<out node>
  (. if (parsNode != null && node != null) parsNode.Items.Add(node); .)
  {
    ","
    (. var separator = t; .)
    FormalParameterTag<out node>
    (. 
       if (parsNode != null && node != null) 
         parsNode.Items.Add(separator, node); 
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Declaration of a current parameter list
// ------------------------------------------------------------------------------------------------
CurrentArgumentList<ArgumentNodeCollection argNodes> 
=
  [
    (. ArgumentNode argNode; .)
    CurrentArgumentItem<out argNode>
    (. if (argNodes != null) argNodes.Add(argNode); .)
    {
      ","
      (. var separator = t; .)
      CurrentArgumentItem<out argNode>
      (. if (argNodes != null) argNodes.Add(separator, argNode); .)
    }
  ]
.

// ------------------------------------------------------------------------------------------------
// Declaration of an item of the current parameter list
// ------------------------------------------------------------------------------------------------
CurrentArgumentItem<out ArgumentNode argNode> 
=
  (. 
     ExpressionNode exprNode; 
     Token argKind = null;
  .)
  [           
    ( "ref" | "out" )
    (. argKind = t; .)
  ]           
  Expression<out exprNode>
  (. 
     argNode = new ArgumentNode(argKind == null ? 
       (exprNode == null ? t : exprNode.StartToken) : argKind);
     argNode.KindToken = argKind;
     argNode.Expression = exprNode;
     Terminate(argNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of property accessors.
// ------------------------------------------------------------------------------------------------
AccessorDeclarations<PropertyDeclarationNodeBase propNode>
= 
  (. var attrNodes = new AttributeDecorationNodeCollection(); .)
  AttributeDecorations<attrNodes>
  (. var mod = new ModifierNodeCollection(); .)
  ModifierList<mod>                    
  ident   
  (.
     var accNode = new AccessorNode(t);
     accNode.AttributeDecorations = attrNodes;
     accNode.Modifiers = mod;
     propNode.FirstAccessor = accNode;
     BlockStatementNode blockNode;
  .)
  (
    Block<out blockNode>
    (. accNode.Body = blockNode; .)
  | ";"                               
    (. accNode.ClosingSemicolon = t; .)
  )                                   
  (. Terminate(accNode); .)
  [                                   
    (. attrNodes = new AttributeDecorationNodeCollection(); .)
    AttributeDecorations<attrNodes>
    (. mod = new ModifierNodeCollection(); .)
    ModifierList<mod>                  
    ident 
    (.
       accNode = new AccessorNode(t);
       accNode.AttributeDecorations = attrNodes;
       accNode.Modifiers = mod;
       propNode.SecondAccessor = accNode;
    .)
    (
      Block<out blockNode>
      (. accNode.Body = blockNode; .)
    | ";"
      (. accNode.ClosingSemicolon = t; .)
    ) 
    (. Terminate(accNode); .)
  ]
.

// ------------------------------------------------------------------------------------------------
// Declaration of event property accessors.
// ------------------------------------------------------------------------------------------------
EventAccessorDeclarations<PropertyDeclarationNodeBase propNode>                                                 
= 
  (. var attrNodes = new AttributeDecorationNodeCollection(); .)
  AttributeDecorations<attrNodes>
  (. var mod = new ModifierNodeCollection(); .)
  ModifierList<mod>                    
  ident       
  (. 
     var accNode = new AccessorNode(t);
     accNode.AttributeDecorations = attrNodes;
     accNode.Modifiers = mod;
     BlockStatementNode blockNode; 
  .)
  Block<out blockNode>
  (. 
     accNode.Body = blockNode;
     Terminate(accNode);
     propNode.FirstAccessor = accNode;
  .)
  [
    (. attrNodes = new AttributeDecorationNodeCollection(); .)
    AttributeDecorations<attrNodes>
    (. mod = new ModifierNodeCollection(); .)
    ModifierList<mod>                      
    ident     
    (. 
       accNode = new AccessorNode(t);
       accNode.AttributeDecorations = attrNodes;
       accNode.Modifiers = mod;
    .)
    Block<out blockNode>
    (. 
       accNode.Body = blockNode;
       Terminate(accNode);
       propNode.SecondAccessor = accNode;
    .)
  ]
.

// ------------------------------------------------------------------------------------------------
// Declaration of interface property/indexer accessors.
// ------------------------------------------------------------------------------------------------
InterfaceAccessors<PropertyDeclarationNodeBase propNode>
= 
  (. var attrNodes = new AttributeDecorationNodeCollection(); .)
  AttributeDecorations<attrNodes>
  (. var mod = new ModifierNodeCollection(); .)
  ModifierList<mod>                    
  ident
  (.
     var accNode = new AccessorNode(t);
     accNode.AttributeDecorations = attrNodes;
     accNode.Modifiers = mod;
     propNode.FirstAccessor = accNode;
  .)
  ";"
  (. 
     accNode.ClosingSemicolon = t; 
     Terminate(accNode);
  .)
  [
    (. attrNodes = new AttributeDecorationNodeCollection(); .)
    AttributeDecorations<attrNodes>
    (. mod = new ModifierNodeCollection(); .)
    ModifierList<mod>                    
    ident
    (.
       accNode = new AccessorNode(t);
       accNode.AttributeDecorations = attrNodes;
       accNode.Modifiers = mod;
       propNode.SecondAccessor = accNode;
    .)
    ";"
    (. 
       accNode.ClosingSemicolon = t; 
       Terminate(accNode);
    .)
  ]
.

// ------------------------------------------------------------------------------------------------
// Declaration of attributes.
// ------------------------------------------------------------------------------------------------
Attributes<out AttributeDecorationNode attrNode>
  (. 
     AttributeNode attributeNode;
     Token separator = null;
  .)
=
  "["
  (. attrNode = new AttributeDecorationNode(t); .)
  [ IF (IsAttrTargSpec()) 
    ( ident | Keyword )       
    (. attrNode.TargetToken = t; .)
    ":"
    (. separator = t; .)
  ] 
  Attribute<out attributeNode>
  (. attrNode.Attributes.Add(separator, attributeNode); .)
  { 
    IF (la.kind == _comma && Peek(1).kind != _rbrack) 
    ","
    (. separator = t; .)
    Attribute<out attributeNode>
    (. attrNode.Attributes.Add(separator, attributeNode); .)
  } 
  [ 
    ","
    (. attrNode.OrphanSeparator = t; .)
  ] 
  "]"                          
  (. Terminate(attrNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of attribute decorations.
// ------------------------------------------------------------------------------------------------
AttributeDecorations<AttributeDecorationNodeCollection attrNodes>
  (.  AttributeDecorationNode attrNode; .)
=
  {
    Attributes<out attrNode>
    (. attrNodes.Add(attrNode); .)
  }
.

// ------------------------------------------------------------------------------------------------
// Declarations tokens that function as keywords.
// ------------------------------------------------------------------------------------------------
Keyword
=
  "abstract" | "as" | "base" | "bool" | "break" | "byte" | "case" | "catch"
  | "char" | "checked" | "class" | "const" | "continue" | "decimal" | "default"
  | "delegate" | "do" | "double" | "else" | "enum" | "event" | "explicit"
  | "extern" | "false" | "finally" | "fixed" | "float" | "for" | "foreach"
  | "goto" | "if" | "implicit" | "in" | "int" | "interface" | "internal" | "is"
  | "lock" | "long" | "namespace" | "new" | "null" | "object" | "operator"
  | "out" | "override" | "params" | "private" | "protected" | "public"
  | "readonly" | "ref" | "return" | "sbyte" | "sealed" | "short" | "sizeof"
  | "stackalloc" | "static" | "string" | "struct" | "switch" | "this" | "throw"
  | "true" | "try" | "typeof" | "uint" | "ulong" | "unchecked" | "unsafe"
  | "ushort" | "using" | "virtual" | "void" | "volatile" | "while"
.

// ------------------------------------------------------------------------------------------------
// Declaration of an attribute.
//   attrNode: Attribute declaration syntax node.
// ------------------------------------------------------------------------------------------------
Attribute<out AttributeNode attrNode> 
= 
  (. 
     attrNode = new AttributeNode(la);
     TypeOrNamespaceNode nsNode = null;
  .)
  TypeName<out nsNode>      
  (. attrNode.TypeName = nsNode; .)
  [ AttributeArguments<attrNode> ]
  (. Terminate(attrNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declares the list of attribute arguments.
// ------------------------------------------------------------------------------------------------
AttributeArguments<AttributeNode argsNode> 
=                           
  (.  
     Token identifier = null;
     Token equal = null;
     ExpressionNode exprNode;
  .)
  "("                          
  (.  Start(argsNode.Arguments); .)
    [                          
      [ IF (IsAssignment()) ident
        (. identifier = t; .)
        "="
        (. equal = t; .)
      ]
      Expression<out exprNode>           
      (. argsNode.Arguments.Add(new AttributeArgumentNode(identifier, equal, exprNode)); .)
      { 
        ","
        (. var separator = t; .)
        ( IF (IsAssignment()) ident
          (. identifier = t; .)
          "="
          (. equal = t; .)
        |                    
        ) 
        Expression<out exprNode> 
        (. argsNode.Arguments.Add(separator, new AttributeArgumentNode(identifier, equal, exprNode)); .)
      }
    ]
  ")"   
  (. Terminate(argsNode.Arguments); .)
.

// ------------------------------------------------------------------------------------------------
// Modifiers that can be assigned to types and members.
// ------------------------------------------------------------------------------------------------
ModifierList<ModifierNodeCollection mods>
=
{
  (
      "new"
    | "public"
    | "protected"
    | "internal" 
    | "private"  
    | "unsafe"   
    | "static"   
    | "readonly" 
    | "volatile" 
    | "virtual"  
    | "sealed"   
    | "override" 
    | "abstract" 
    | "extern"   
  )                                  
  (. mods.Add(t); .)
}
.

// ------------------------------------------------------------------------------------------------
// Gets a reference to a type name with optional type parameters.
// ------------------------------------------------------------------------------------------------
Type<out TypeOrNamespaceNode typeNode>    
=                                                    
  (. typeNode = null; .)      
  ( 
     PrimitiveType<out typeNode>
  |  ClassType<out typeNode>                                               
  |  "void"                                           
     (. typeNode = TypeOrNamespaceNode.CreateTypeNode(t); .)
  )
  [ 
    "?"                                              
    (. typeNode.NullableToken = t; .)                                              
  ]
  PointerOrArray<typeNode>
  (. Terminate(typeNode); .)
.

// ------------------------------------------------------------------------------------------------
// Gets a reference for a non-array type.
// ------------------------------------------------------------------------------------------------
NonArrayType<out TypeOrNamespaceNode typeNode>    
=                                                    
  (. typeNode = null; .)      
  ( 
    PrimitiveType<out typeNode>
  | 
    ClassType<out typeNode>
  )
  [ 
    "?"
    (. typeNode.NullableToken = t; .)                                              
  ]
  [
    "*"                         
    (. typeNode.TypeModifiers.Add(new PointerModifierNode(t)); .)
  ]
  (. Terminate(typeNode); .)
.

// ------------------------------------------------------------------------------------------------
// Gets a reference for a type that can be used in a relational expression
// ------------------------------------------------------------------------------------------------
TypeInRelExpr<out TypeOrNamespaceNode typeNode>    
=                                                    
  (. typeNode = null; .)      
  ( PrimitiveType<out typeNode>
  | ClassType<out typeNode>                                               
  | "void"                                           
    (. typeNode = TypeOrNamespaceNode.CreateTypeNode(t); .)
  )
  [ IF (IsNullableTypeMark())
    "?" 
    (. typeNode.NullableToken = t; .)                                             
  ]
  PointerOrArray<typeNode>
  (. Terminate(typeNode); .)
.

// ------------------------------------------------------------------------------------------------
// Sets the appropriate flags of a type reference if the declaration shows it is a pointer or array.
// ------------------------------------------------------------------------------------------------
PointerOrArray<TypeOrNamespaceNode typeNode>
=
  { IF (IsPointerOrDims())
    ( 
      "*"
      (. if (typeNode != null) typeNode.TypeModifiers.Add(new PointerModifierNode(t)); .)  
    | 
      "["                     
      (. var arrNode = new ArrayModifierNode(t); .)
      { 
        ","                 
        (. arrNode.AddSeparator(t); .)
      } 
      "]"                     
      (. Terminate(arrNode); .)
    )
  }
.

// ------------------------------------------------------------------------------------------------
// Types that are taken into account as primitive types.
// ------------------------------------------------------------------------------------------------
PredefinedType<out TypeOrNamespaceNode typeNode> 
  (. typeNode = null; .)
=
    PrimitiveType<out typeNode> 
  | 
    ( "object" | "string" )                                    
    (. typeNode = TypeOrNamespaceNode.CreateTypeNode(t); .)                                 
.

// ------------------------------------------------------------------------------------------------
// Types that are taken into account as primitive types.
// ------------------------------------------------------------------------------------------------
PrimitiveType<out TypeOrNamespaceNode typeNode> 
  (. typeNode = null; .)
=
    IntegralType<out typeNode> 
  | 
    ( "float" | "double" | "decimal" | "bool" )
    (. typeNode = TypeOrNamespaceNode.CreateTypeNode(t); .)
.

// ------------------------------------------------------------------------------------------------
// Types that are taken into account as integral types.
// ------------------------------------------------------------------------------------------------
IntegralType<out TypeOrNamespaceNode typeNode> 
= 
  (
    "sbyte"       
  | "byte"
  | "short" 
  | "ushort"
  | "int"
  | "uint"
  | "long"    
  | "ulong"     
  | "char"     
  )               
  (. typeNode = TypeOrNamespaceNode.CreateTypeNode(t); .)
.

// ------------------------------------------------------------------------------------------------
// Types that are taken into account as class types.
// ------------------------------------------------------------------------------------------------
ClassType<out TypeOrNamespaceNode typeNode>   
  (. typeNode = null; .)
=                 
    TypeName<out typeNode> 
  |               
    ( "object" | "string" )                                    
    (. typeNode = TypeOrNamespaceNode.CreateTypeNode(t); .)                                 
.

// ------------------------------------------------------------------------------------------------
// Declaration of a compound member name
// ------------------------------------------------------------------------------------------------
MemberName<out TypeOrNamespaceNode resultNode>                                              
  (.
     resultNode = null;
     Token separator = null;
     Token identifier = null;
     TypeOrNamespaceNodeCollection argList = null;
  .)
=                                         
  ident
  (. 
     resultNode = new TypeOrNamespaceNode(t);
     identifier = t; 
  .)
  [ 
    "::"
    (. 
       resultNode.QualifierToken = identifier;
       separator = t; 
    .)
    ident                           
    (. identifier = t; .)
  ]
  [ IF (la.kind == _lt && IsPartOfMemberName()) TypeArgumentList<out argList> ]
  (. resultNode.TypeTags.Add(separator, new TypeTagNode(identifier, argList)); .)
  { 
    IF (la.kind == _dot && Peek(1).kind == _ident)
    "." 
    (.
       separator = t;
       argList = null;
    .)
    ident
    (. identifier = t; .)
    [ IF (la.kind == _lt && IsPartOfMemberName()) TypeArgumentList<out argList> ]
    (. resultNode.TypeTags.Add(separator, new TypeTagNode(identifier, argList)); .)                                    
  }
  (. Terminate(resultNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a compound type name
// ------------------------------------------------------------------------------------------------
TypeName<out TypeOrNamespaceNode resultNode>                             
=               
  (.
     resultNode = null;
     Token separator = null;
     Token identifier = null;
     TypeOrNamespaceNodeCollection argList = null;
  .)
  ident
  (. 
     resultNode = new TypeOrNamespaceNode(t);
     identifier = t; 
  .)
  [ 
    "::"
    (. 
       resultNode.QualifierToken = identifier;
       separator = t; 
    .)
    ident
    (. identifier = t; .)
  ]
  [ TypeArgumentList<out argList> ]
  (. resultNode.TypeTags.Add(separator, new TypeTagNode(identifier, argList)); .)
  {
    "."
    (.
       separator = t;
       argList = null;
    .)
    ident 
    (. identifier = t; .)
    [ TypeArgumentList<out argList> ]   
    (. resultNode.TypeTags.Add(separator, new TypeTagNode(identifier, argList)); .)                                    
  }
  (. Terminate(resultNode); .)
.

// ------------------------------------------------------------------------------------------------
// Statement declaration.
// ------------------------------------------------------------------------------------------------
Statement<out StatementNode stmtNode>
  (. stmtNode = null; .)
= 
    IF (la.kind == _ident && Peek(1).kind == _colon) 
    (. Token identifier; .)
    ident 
    (. identifier = t; .)
    ":" 
    (. var label = new LabelNode(identifier, t); .)
    Statement<out stmtNode>
    (. if (stmtNode != null) stmtNode.Labels.AddLabel(label); .)
  | ConstStatement<out stmtNode>
  | IF (IsLocalVarDecl()) 
    (. LocalVariableNode varNode; .)
    LocalVariableDeclaration<out varNode>
    (. 
       var varDecl = new VariableDeclarationStatementNode(varNode.StartToken);
       stmtNode = varDecl;
       varDecl.Declaration = varNode;
    .)
    ";"
    (. Terminate(varDecl); .)
  | EmbeddedStatement<out stmtNode>
.

// ------------------------------------------------------------------------------------------------
// Defines statements that can be nested in other statements.
// ------------------------------------------------------------------------------------------------
EmbeddedStatement<out StatementNode stmtNode>
  (. stmtNode = null; .)
=   
    (. BlockStatementNode blockNode; .)
    Block<out blockNode> 
    (. stmtNode = blockNode; .)
  | EmptyStatement<out stmtNode>
  | CheckedBlock<out stmtNode>
  | UncheckedBlock<out stmtNode>
  | UnsafeBlock<out stmtNode>
  | 
    (. ExpressionNode exprNode; .)
    (. var eNode = new ExpressionStatementNode(la); .)
    StatementExpression<out exprNode> 
    (. eNode.Expression = exprNode; .)
    ";"
    (.
       stmtNode = eNode;
       Terminate(eNode); 
    .) 
  | IfStatement<out stmtNode>
  | SwitchStatement<out stmtNode>
  | WhileStatement<out stmtNode>
  | DoWhileStatement<out stmtNode>
  | ForStatement<out stmtNode>
  | ForEachStatement<out stmtNode>
  | BreakStatement<out stmtNode>
  | ContinueStatement<out stmtNode>
  | GotoStatement<out stmtNode>
  | ReturnStatement<out stmtNode>
  | ThrowStatement<out stmtNode>
  | TryFinallyBlock<out stmtNode>
  | LockStatement<out stmtNode>
  | UsingStatement<out stmtNode>
  | "yield" ( YieldReturnStatement<out stmtNode> | YieldBreakStatement<out stmtNode> )
  | FixedStatement<out stmtNode>
.

// ------------------------------------------------------------------------------------------------
// Defines a block of statements.
// ------------------------------------------------------------------------------------------------
Block<out BlockStatementNode blockNode> 
=
  (. 
     StatementNode stmtNode;
     blockNode = null;
  .)
  "{" 
  (. blockNode = new BlockStatementNode(t); .)
  { 
    Statement<out stmtNode> 
    (. if (stmtNode != null) blockNode.Statements.Add(stmtNode); .)
  } 
  "}"
  (. Terminate(blockNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "switch" statement.
// ------------------------------------------------------------------------------------------------
SwitchStatement<out StatementNode stmtNode>
=
  "switch"
  (.
     var swcNode = new SwitchStatementNode(t);
     stmtNode = swcNode; 
  .)
  "("
  (. 
     swcNode.OpenParenthesis = t; 
     ExpressionNode exprNode; 
  .)
  Expression<out exprNode>    
  (. swcNode.Expression = exprNode; .)
  ")" 
  (. swcNode.CloseParenthesis = t; .)
  "{"
  (. swcNode.SwitchSections.StartToken = t; .)
  { 
    SwitchSection<swcNode>
  } 
  "}"
  (. 
     Terminate(swcNode.SwitchSections); 
     Terminate(stmtNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "const" statement.
// ------------------------------------------------------------------------------------------------
ConstStatement<out StatementNode stmtNode>
  (. ExpressionNode exprNode; .)
=
  "const"                
  (. 
     var csNode = new ConstStatementNode(t);
     stmtNode = csNode;
     TypeOrNamespaceNode typeNode;
  .)
  Type<out typeNode> 
  (. csNode.TypeName = typeNode; .)
  ident
  (. var cmTag = new ConstTagNode(t); .)
  "="                    
  (. cmTag.EqualToken = t; .)
  Expression<out exprNode>   
  (. 
     cmTag.Expression = exprNode;
     Terminate(cmTag);
     csNode.ConstTags.Add(cmTag);
  .)
  { 
    ","
    (. var separator = t; .)
    ident                
    (. var cmcTag = new ConstTagNode(t); .)
    "=" 
    (. cmcTag.EqualToken = t; .)
    Expression<out exprNode> 
    (. 
       cmcTag.Expression = exprNode;
       Terminate(cmcTag);
       csNode.ConstTags.Add(separator, cmTag);
    .)
  } 
  ";"
  (. Terminate(csNode); .)
.                 

// ------------------------------------------------------------------------------------------------
// Defines an empty statement (";").
// ------------------------------------------------------------------------------------------------
EmptyStatement<out StatementNode stmtNode>
=
  ";"
  (. stmtNode = new EmptyStatementNode(t); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "checked" block
// ------------------------------------------------------------------------------------------------
CheckedBlock<out StatementNode stmtNode>
=
  (
    IF (la.kind == _checked && Peek(1).kind == _lbrace) 
    "checked"
    (. 
       var start = t; 
       BlockStatementNode blockNode;
    .)
    Block<out blockNode>
    (. stmtNode = new CheckedStatementNode(t, blockNode); .)
  )
.

// ------------------------------------------------------------------------------------------------
// Defines an "unchecked" block
// ------------------------------------------------------------------------------------------------
UncheckedBlock<out StatementNode stmtNode>
=
  (
    IF (la.kind == _unchecked && Peek(1).kind == _lbrace) 
    "unchecked"
    (. 
       var start = t; 
       BlockStatementNode blockNode;
    .)
    Block<out blockNode>
    (. stmtNode = new UncheckedStatementNode(t, blockNode); .)
  )
.

// ------------------------------------------------------------------------------------------------
// Defines an "unsafe" block
// ------------------------------------------------------------------------------------------------
UnsafeBlock<out StatementNode stmtNode>
=
  "unsafe" 
    (. 
       var start = t; 
       BlockStatementNode blockNode;
    .)
   Block<out blockNode>
   (. stmtNode = new UnsafeStatementNode(t, blockNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines an "if" statement
// ------------------------------------------------------------------------------------------------
IfStatement<out StatementNode stmtNode>
=   
  "if"
  (. 
     var ifNode = new IfStatementNode(t);
     stmtNode = ifNode;
  .)
  "("
  (. 
     ifNode.OpenParenthesis = t;
     ExpressionNode exprNode; 
  .)
  Expression<out exprNode> 
  (. ifNode.Condition = exprNode; .)
  ")"
  (. 
     ifNode.CloseParenthesis = t;
     StatementNode branchNode; 
  .)
  EmbeddedStatement<out branchNode>
  (. ifNode.ThenStatement = branchNode; .)
  [ 
    "else"
    (. ifNode.ElseToken = t; .)
    EmbeddedStatement<out stmtNode>
    (. ifNode.ThenStatement = branchNode; .)
  ]
  (. Terminate(stmtNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "while" statement
// ------------------------------------------------------------------------------------------------
WhileStatement<out StatementNode stmtNode>
= 
  "while"
  (. 
     var whNode = new WhileStatementNode(t); 
     stmtNode = whNode;
  .)
  "("
  (. 
     whNode.OpenParenthesis = t;
     ExpressionNode exprNode; 
  .)
  Expression<out exprNode>  
  ")" 
  (. 
     whNode.CloseParenthesis = t;
     StatementNode bodyNode; 
  .)
  EmbeddedStatement<out bodyNode>
  (.
     whNode.Statement = bodyNode;
     Terminate(whNode);
  .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "do...while" statement
// ------------------------------------------------------------------------------------------------
DoWhileStatement<out StatementNode stmtNode>
=   
  "do"
  (. 
     var dwhNode = new DoWhileStatementNode(t); 
     stmtNode = dwhNode;
     StatementNode bodyNode; 
  .)
  EmbeddedStatement<out bodyNode>
  (. dwhNode.Statement = bodyNode; .)
  "while" 
  (. dwhNode.WhileToken = t; .)
  "("
  (. 
     ExpressionNode exprNode;
     dwhNode.OpenParenthesis = t; 
  .)
  Expression<out exprNode>
  (. dwhNode.Condition = exprNode; .)    
  ")" 
  (. dwhNode.CloseParenthesis = t; .)
  ";"
  (. Terminate(stmtNode); .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "for" statement
// ------------------------------------------------------------------------------------------------
ForStatement<out StatementNode stmtNode>
= 
  "for"
  (.
     var forNode = new ForStatementNode(t);
     stmtNode = forNode;
  .)
  "("
  (. forNode.OpenParenthesis = t; .)
  [
    ForInitializer<forNode>
  ] 
  ";" 
  (. forNode.InitSeparator = t; .)
  [
    (. ExpressionNode exprNode; .)
    Expression<out exprNode>    
  ] 
  ";" 
  (. forNode.ConditionSeparator = t; .)
  [ 
    ForIterator<forNode>
  ] 
  ")"
  (. 
     forNode.CloseParenthesis = t; 
     StatementNode bodyNode; 
  .)
  EmbeddedStatement<out bodyNode>
  (.
     forNode.Statement = bodyNode;
     Terminate(forNode); 
  .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "foreach" statement
// ------------------------------------------------------------------------------------------------
ForEachStatement<out StatementNode stmtNode>
=
  "foreach"
  (. 
     var feNode = new ForeachStatementNode(t); 
     stmtNode = feNode;
  .)
  "("
  (. 
     feNode.OpenParenthesis = t; 
     TypeOrNamespaceNode typeNode = null; 
  .)
  ( 
    IF (IsVar())
    ident
    (. typeNode = TypeOrNamespaceNode.CreateTypeNode(t); .)
  |        
    Type<out typeNode>
  )
  (. feNode.TypeName = typeNode; .)
  ident
  (. feNode.IdentifierToken = t; .)
  "in"
  (. 
     feNode.InToken = t; 
     ExpressionNode exprNode;
  .)
  Expression<out exprNode>
  (. feNode.Collection = exprNode; .)
  ")"
  (.
     feNode.CloseParenthesis = t; 
     StatementNode bodyNode; 
  .)
  EmbeddedStatement<out bodyNode>
  (.
     feNode.Statement = bodyNode;
     Terminate(stmtNode); 
  .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "break" statement
// ------------------------------------------------------------------------------------------------
BreakStatement<out StatementNode stmtNode>
=
  "break"
  (. stmtNode = new BreakStatementNode(t); .)
  ";"
  (. Terminate(stmtNode); .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "goto" statement
// ------------------------------------------------------------------------------------------------
GotoStatement<out StatementNode stmtNode>
=
  "goto"
  (. var gotoNode = new GotoStatementNode(t); .)
  ( 
    ident
    (. gotoNode.IdentifierToken = t; .)
  | 
    "case"
    (. 
       gotoNode.IdentifierToken = t;
       ExpressionNode exprNode; 
    .)
    Expression<out exprNode>  
    (. gotoNode.Expression = exprNode; .)
  | 
    "default"
    (. gotoNode.IdentifierToken = t; .)
  ) 
  (. stmtNode = gotoNode; .)
  ";"
  (. Terminate(stmtNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "continue" statement
// ------------------------------------------------------------------------------------------------
ContinueStatement<out StatementNode stmtNode>
=
  "continue" 
  (. stmtNode = new ContinueStatementNode(t); .)
  ";"
  (. Terminate(stmtNode); .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "try...catch...finally" statement
// ------------------------------------------------------------------------------------------------
TryFinallyBlock<out StatementNode stmtNode>
=
  "try"
  (. 
     var tryNode = new TryStatementNode(t);
     stmtNode = tryNode;
     BlockStatementNode blockNode; 
  .)
  Block<out blockNode>
  (. tryNode.TryBlock = blockNode; .) 
  ( 
    CatchClauses<tryNode>
    [ 
      "finally" 
      (. tryNode.FinallyToken = t; .)
      Block<out blockNode>
      (. tryNode.FinallyBlock = blockNode; .) 
    ] 
  | "finally"
    (. tryNode.FinallyToken = t; .)
    Block<out blockNode>
    (. tryNode.FinallyBlock = blockNode; .) 
  )
.    

// ------------------------------------------------------------------------------------------------
// Defines a "lock" statement
// ------------------------------------------------------------------------------------------------
LockStatement<out StatementNode stmtNode>
=   
  "lock"
  (. 
     var lckNode = new LockStatementNode(t); 
     stmtNode = lckNode;
  .)
  "("
  (. 
     lckNode.OpenParenthesis = t;
     ExpressionNode exprNode;
  .)
  Expression<out exprNode>  
  (. lckNode.Expression = exprNode; .)
  ")" 
  (. 
     lckNode.CloseParenthesis = t;
     StatementNode bodyNode;;
  .)
  EmbeddedStatement<out bodyNode>
  (.
     lckNode.Statement = bodyNode;
     Terminate(stmtNode);
  .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "using" statement
// ------------------------------------------------------------------------------------------------
UsingStatement<out StatementNode stmtNode>
=
  "using"
  (. 
     var usNode = new UsingStatementNode(t); 
     stmtNode = usNode;
  .)
  "(" 
  (. usNode.OpenParenthesis = t; .)
  (
    IF (IsLocalVarDecl()) 
    (. LocalVariableNode varNode; .)
    LocalVariableDeclaration<out varNode>  
    (. usNode.Initializer = varNode; .)
  |
    (. ExpressionNode exprNode; .)
    Expression<out exprNode>      
    (. usNode.Expression = exprNode; .)  
  ) 
  ")" 
  (. 
     usNode.CloseParenthesis = t;   
     StatementNode bodyNode; 
  .)
  EmbeddedStatement<out bodyNode>
  (.
     usNode.Statement = bodyNode;
     Terminate(stmtNode); 
  .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a "return" statement.
// ------------------------------------------------------------------------------------------------
ReturnStatement<out StatementNode stmtNode>
=
  (. ExpressionNode exprNode = null; .)
  "return"
  (. var start = t; .)
  [
    Expression<out exprNode>     
  ]
  (. stmtNode = new ReturnStatementNode(t, exprNode); .)
  ";"
  (. Terminate(stmtNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "throw" statement.
// ------------------------------------------------------------------------------------------------
ThrowStatement<out StatementNode stmtNode>
=
  (. ExpressionNode exprNode = null; .)
  "throw"
  (. var start = t; .)
  [
    Expression<out exprNode>
  ] 
  (. stmtNode = new ThrowStatementNode(t, exprNode); .)
  ";"
  (. Terminate(stmtNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "yield return" statement.
// ------------------------------------------------------------------------------------------------
YieldReturnStatement<out StatementNode stmtNode>
=
  (. ExpressionNode exprNode; .)
  "return"
  (. var start = t; .)
  Expression<out exprNode>
  (. stmtNode = new YieldReturnStatementNode(t, exprNode); .)
  ";"
  (. Terminate(stmtNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "yield break" statement.
// ------------------------------------------------------------------------------------------------
YieldBreakStatement<out StatementNode stmtNode>
=
  "break"
  (. stmtNode = new YieldBreakStatementNode(t); .)
  ";"
  (. Terminate(stmtNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a "fixed" statement
// ------------------------------------------------------------------------------------------------
FixedStatement<out StatementNode stmtNode>
= 
  "fixed"
  (.
     var fixNode = new FixedStatementNode(t);
     stmtNode = fixNode;
  .)
  "("
  (.
     fixNode.OpenParenthesis = t; 
     TypeOrNamespaceNode typeNode; 
  .)
  Type<out typeNode>
  (. fixNode.TypeName = typeNode; .)
  ident
  (. var fiNode = new FixedInitializerNode(t); .)
  "="
  (. 
     fiNode.EqualToken = t; 
     ExpressionNode exprNode; 
  .)
  Expression<out exprNode>
  (. 
     fiNode.Expression = exprNode; 
     Terminate(fiNode);
     fixNode.Initializers.Add(fiNode);
  .)
  { 
    ","
    (. var separator = t; .)
    ident
    (. fiNode = new FixedInitializerNode(t); .)
    "=" 
    (. fiNode.EqualToken = t; .)
    Expression<out exprNode>
    (. 
       fiNode.Expression = exprNode; 
       Terminate(fiNode);
       fixNode.Initializers.Add(separator, fiNode);
    .)
  }
  ")" 
  (. 
     fixNode.CloseParenthesis = t;
     StatementNode bodyNode; 
  .)
  EmbeddedStatement<out bodyNode>
  (.
     fixNode.Statement = bodyNode;
     Terminate(fixNode); 
  .)
.    

// ------------------------------------------------------------------------------------------------
// Defines a statement expression
// ------------------------------------------------------------------------------------------------
StatementExpression<out ExpressionNode exprNode>
  (. 
     bool isAssignment = assnStartOp[la.kind] || IsTypeCast(); 
     exprNode = null;
  .)
=
  (. ExpressionNode unaryNode; .)
  Unary<out unaryNode>
  (. exprNode = unaryNode; .)
  ( 
    (. BinaryOperatorNode asgnNode; .)
    AssignmentOperator<out asgnNode>
    (. 
       asgnNode.LeftOperand = unaryNode;
       exprNode = asgnNode;
       ExpressionNode rightNode; 
    .)
    Expression<out rightNode>
    (. asgnNode.RightOperand = rightNode; .)
  | (. if (isAssignment) Error("UNDEF", la, "error in assignment."); .)
  )
.

// ------------------------------------------------------------------------------------------------
// Defines an assignment operator.
// ------------------------------------------------------------------------------------------------
AssignmentOperator<out BinaryOperatorNode opNode> 
  (. opNode = null; .)
=
    "="     
    (. opNode = new AssignmentOperatorNode(t); .)
  | "+="    
    (. opNode = new PlusAssignmentOperatorNode(t); .)
  | "-="    
    (. opNode = new MinusAssignmentOperatorNode(t); .)
  | "*="    
    (. opNode = new MultiplyAssignmentOperatorNode(t); .)
  | "/="    
    (. opNode = new DivideAssignmentOperatorNode(t); .)
  | "%="    
    (. opNode = new ModuloAssignmentOperatorNode(t); .)
  | "&="    
    (. opNode = new AndAssignmentOperatorNode(t); .)
  | "|="    
    (. opNode = new OrAssignmentOperatorNode(t); .)
  | "^="    
    (. opNode = new XorAssignmentOperatorNode(t); .)
  | "<<="   
    (. opNode = new LeftShiftAssignmentOperatorNode(t); .)
  | ">"     
    (. 
       int pos = t.pos; 
       var start = t;
    .)
    ">="    
    (. 
       if (pos+1 < t.pos) Error("UNDEF", la, "no whitespace allowed in right shift assignment");
       opNode = new RightShiftAssignmentOperatorNode(start, t); 
    .)
.

// ------------------------------------------------------------------------------------------------
// Represents a section of a switch statement.
// ------------------------------------------------------------------------------------------------
SwitchSection<SwitchStatementNode swcNode>
=
  (. 
     var ssNode = new SwitchSectionNode(la); 
     SwitchLabelNode slNode;
  .)
  SwitchLabel<out slNode>
  (. ssNode.Labels.Add(slNode); .)
  { 
    IF (la.kind == _case || (la.kind == _default && Peek(1).kind == _colon)) 
    SwitchLabel<out slNode>
    (. ssNode.Labels.Add(slNode); .)
  }
  (. StatementNode stmtNode; .)
  Statement<out stmtNode>
  (. ssNode.Statements.Add(stmtNode); .)
  { 
    IF (IsNoSwitchLabelOrRBrace()) 
    Statement<out stmtNode> 
    (. ssNode.Statements.Add(stmtNode); .)
  }
  (. swcNode.SwitchSections.Add(ssNode); .)
.

// ------------------------------------------------------------------------------------------------
// Represents a label of a switch statement.
// ------------------------------------------------------------------------------------------------
SwitchLabel<out SwitchLabelNode slNode>
  (. slNode = new SwitchLabelNode(la); .)
= 
  (
    "case" 
    (. ExpressionNode exprNode; .)
    Expression<out exprNode> 
    (. slNode.Expression = exprNode; .)
  | 
    "default" 
  )
  ":"
  (. Terminate(slNode); .)
.

// ------------------------------------------------------------------------------------------------
// Represents the initializer of a for statement.
// ------------------------------------------------------------------------------------------------
ForInitializer<ForStatementNode forNode>
=
    IF (IsLocalVarDecl()) 
    (. LocalVariableNode varNode; .)
    LocalVariableDeclaration<out varNode>
    (. forNode.Initializer = varNode; .)
  | 
    (. ExpressionNode exprNode; .)
    StatementExpression<out exprNode>
    (. if (exprNode != null) forNode.Initializers.Add(exprNode); .)
    { 
      "," 
      (. var separator = t; .)
      StatementExpression<out exprNode>
      (. if (exprNode != null) forNode.Initializers.Add(separator, exprNode); .)
    }
.

// ------------------------------------------------------------------------------------------------
// Represents the iterator of a for statement.
// ------------------------------------------------------------------------------------------------
ForIterator<ForStatementNode forNode>
=
  (. ExpressionNode exprNode; .)
  StatementExpression<out exprNode>
  (. if (exprNode != null) forNode.Iterators.Add(exprNode); .)
  { 
    "," 
    (. var separator = t; .)
    StatementExpression<out exprNode>
    (. if (exprNode != null) forNode.Iterators.Add(separator, exprNode); .)
  }
.

// ------------------------------------------------------------------------------------------------
// Represents catch clauses in a "try..catch..finally" statement.
// ------------------------------------------------------------------------------------------------
CatchClauses<TryStatementNode tryNode>
=                                                     
  "catch"
  (. 
     var ccNode = new CatchClauseNode(t); 
     BlockStatementNode blockNode;
  .)
  (                         
    Block<out blockNode>
    (. 
       ccNode.Block = blockNode; 
       Terminate(ccNode);
       tryNode.CatchClauses.Add(ccNode);
    .)
  | 
    "("
    (. 
       ccNode.OpenParenthesis = t; 
       TypeOrNamespaceNode typeNode;
    .)
    ClassType<out typeNode>
    (. ccNode.TypeName = typeNode; .)
    [ 
      ident
      (. ccNode.IdentifierToken = t; .)
    ] 
    ")" 
    (. ccNode.CloseParenthesis = t; .)
    Block<out blockNode>
    (. 
       ccNode.Block = blockNode; 
       Terminate(ccNode);
       tryNode.CatchClauses.Add(ccNode);
    .)
    [ 
      CatchClauses<tryNode>
    ]
  )
.

// ------------------------------------------------------------------------------------------------
// Gets the signature of the specified lambda expression.
// ------------------------------------------------------------------------------------------------
LambdaFunctionSignature<LambdaExpressionNode lambdaNode>
=
  (
    IF (la.kind == _ident)
    ident
    (.
       var fpNode = new FormalParameterNode(t);
       fpNode.IdentifierToken = t;
       Terminate(fpNode);
       lambdaNode.FormalParameters.Add(fpNode);
    .)
  |
    "("
    (. 
       lambdaNode.OpenParenthesis = t;
       FormalParameterNode parNode; 
    .)
    (
      IF (IsExplicitLambdaParameter(la))
      ExplicitLambdaParameter<out parNode>
      (. lambdaNode.FormalParameters.Add(parNode); .)
      {
        ","
        (. var separator = t; .)
        ExplicitLambdaParameter<out parNode>
        (. lambdaNode.FormalParameters.Add(separator, parNode); .)
      }
    |
      IF (la.kind != _rpar)
      ident
      (.
         parNode = new FormalParameterNode(t);
         parNode.IdentifierToken = t;
         Terminate(parNode);
         lambdaNode.FormalParameters.Add(parNode);
      .)
      {
        ","
        (. var separator = t; .)
        ident
        (.
           parNode = new FormalParameterNode(t);
           parNode.IdentifierToken = t;
           Terminate(parNode);
           lambdaNode.FormalParameters.Add(separator, parNode);
        .)
      }
    |
    )
    ")"
    (. lambdaNode.OpenParenthesis = t; .)
  )
.

// ------------------------------------------------------------------------------------------------
// Gets the explicit parameter list of the specified lambda expression.
// ------------------------------------------------------------------------------------------------
ExplicitLambdaParameter<out FormalParameterNode fpNode>
=
  (. fpNode = new FormalParameterNode(la); .)
  [
    "ref" 
    (. fpNode.Modifier = FormalParameterModifier.Ref; .)
  | "out"
    (. fpNode.Modifier = FormalParameterModifier.Out; .)
  ]
  (. TypeOrNamespaceNode typeNode; .)
  Type<out typeNode>
  (. fpNode.TypeName = typeNode; .)
  ident
  (. 
     fpNode.IdentifierToken = t; 
     Terminate(fpNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Gets the body of a lambda expression.
// ------------------------------------------------------------------------------------------------
LambdaFunctionBody<LambdaExpressionNode lambdaNode>
=
  (
    (. ExpressionNode exprNode; .)
    Expression<out exprNode>
    (. lambdaNode.Expression = exprNode; .)
  |
    (. BlockStatementNode blockNode; .)
    Block<out blockNode>
    (. lambdaNode.Block = blockNode; .)
  )
.

// ------------------------------------------------------------------------------------------------
// Gets a "from" clause for a query expression
// ------------------------------------------------------------------------------------------------
FromClause<out FromClauseNode fromNode>
=
  // --- At this point ident is "from"
  ident 
  (. 
     fromNode = new FromClauseNode(t); 
     var typeToken = la;
  .)
  (                             
    IF (IsType(ref typeToken) && typeToken.val != "in")
    (. TypeOrNamespaceNode typeNode; .)
    Type<out typeNode>
    (. fromNode.TypeName = typeNode; .)
  |
  )                             
  ident
  (. fromNode.IdentifierToken = t; .)
  "in"
  (. 
     fromNode.InToken = t; 
     ExpressionNode exprNode;
  .)
  Expression<out exprNode>
  (. 
     fromNode.Expression = exprNode;
     Terminate(fromNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Gets the body of a query expression.
// ------------------------------------------------------------------------------------------------
QueryBody<out QueryBodyNode bodyNode>
=
  (. bodyNode = new QueryBodyNode(la); .)
  { QueryBodyClause<bodyNode> }
.

// ------------------------------------------------------------------------------------------------
// Gets a query body clause
// ------------------------------------------------------------------------------------------------
QueryBodyClause<QueryBodyNode bodyNode>
=
  (
    IF (la.kind == _ident && la.val == "from")
    (. FromClauseNode fromNode; .)
    FromClause<out fromNode>
    (. bodyNode.BodyClauses.Add(fromNode); .)
  | 
    IF (la.kind == _ident && la.val == "let")
    (. LetClauseNode letNode; .)
    LetClause<out letNode>
    (. bodyNode.BodyClauses.Add(letNode); .)
  | 
    IF (la.kind == _ident && la.val == "join")
    (. JoinClauseNode joinNode; .)
    JoinClause<out joinNode>
    (. bodyNode.BodyClauses.Add(joinNode); .)
  | 
    IF (la.kind == _ident && la.val == "orderby")
    (. OrderByClauseNode orderNode; .)
    OrderByClause<out orderNode>
    (. bodyNode.BodyClauses.Add(orderNode); .)
  | 
    IF (la.kind == _ident && la.val == "into")
    (. IntoClauseNode intoNode; .)
    IntoClause<out intoNode>
    (. bodyNode.BodyClauses.Add(intoNode); .)
  | 
    IF (la.kind == _ident && la.val == "select")
    (. SelectClauseNode selectNode; .)
    SelectClause<out selectNode>
    (. bodyNode.BodyClauses.Add(selectNode); .)
  | 
    IF (la.kind == _ident && la.val == "group")
    (. GroupByClauseNode groupNode; .)
    GroupClause<out groupNode>
    (. bodyNode.BodyClauses.Add(groupNode); .)
  |
    (. WhereClauseNode whereNode; .)
    WhereClause<out whereNode>
    (. bodyNode.BodyClauses.Add(whereNode); .)
  |
    ident
    // --- At this point we have faced an identifier that would cause an infinite parsing loop
    (. Error("SYNERR", t, "invalid identifier in query expression", null); .)
  )
.

// ------------------------------------------------------------------------------------------------
// Gets a "let" clause
// ------------------------------------------------------------------------------------------------
LetClause<out LetClauseNode letNode>
=
  (. ExpressionNode exprNode; .)
  // --- At this point ident is "let"
  ident
  (. letNode = new LetClauseNode(t); .)
  ident
  (. letNode.IdentifierToken = t; .)
  "="  
  (. letNode.EqualToken = t; .)
  Expression<out exprNode>
  (. 
     letNode.Expression = exprNode; 
     Terminate(letNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Gets a "where" clause
// ------------------------------------------------------------------------------------------------
WhereClause<out WhereClauseNode whereNode>
=
  (. ExpressionNode exprNode; .)
  "where"
  (. whereNode = new WhereClauseNode(t); .)
  Expression<out exprNode>
  (. 
     whereNode.Expression = exprNode; 
     Terminate(whereNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Gets an "into" clause
// ------------------------------------------------------------------------------------------------
IntoClause<out IntoClauseNode intoNode>
=
  // --- At this point ident is "into"
  ident
  (. intoNode = new IntoClauseNode(t); .)
  ident
  (. 
     intoNode.IdentifierToken = t; 
     Terminate(intoNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Gets a "join" clause
// ------------------------------------------------------------------------------------------------
JoinClause<out JoinClauseNode joinNode>
=
  (. ExpressionNode exprNode; .)
  // --- At this point ident is "join"
  ident
  (. 
     joinNode = new JoinClauseNode(t);
     Token typeToken = la; 
  .)
  (                     
    IF (IsType(ref typeToken) && typeToken.val != "in")
    (. TypeOrNamespaceNode typeNode; .)
    Type<out typeNode>
    (. joinNode.TypeName = typeNode; .)
  |
  )
  ident
  (. joinNode.IdentifierToken = t; .)
  "in" 
  (. joinNode.InToken = t; .)
  Expression<out exprNode>
  (. joinNode.InExpression = exprNode; .)
  // CHECKTHIS: In the syntax tree you should check that this token is "on".
  ident
  (. joinNode.OnToken = t; .)
  Expression<out exprNode>
  (. joinNode.OnExpression = exprNode; .)
  // CHECKTHIS: In the syntax tree you should check that this token is "equals".
  ident
  (. joinNode.EqualsToken = t; .)
  Expression<out exprNode>
  (. joinNode.EqualsExpression = exprNode; .)
  [ 
    IF (la.kind == _ident && la.val == "into")
    ident
    (. joinNode.IntoToken = t; .)
    ident
    (. joinNode.IntoIdentifierToken = t; .)
    |
  ]
  (. Terminate(joinNode); .)
.

// ------------------------------------------------------------------------------------------------
// Gets an "orderby" clause
// ------------------------------------------------------------------------------------------------
OrderByClause<out OrderByClauseNode obNode>
=
  (. OrderingClauseNode ordNode; .)
  // --- At this point ident is "orderby"
  ident
  (. obNode = new OrderByClauseNode(t); .)
  OrderingClause<out ordNode>
  (. obNode.Orderings.Add(ordNode); .)
  { 
    "," 
    (. var separator = t; .)
    OrderingClause<out ordNode>
    (. obNode.Orderings.Add(separator, ordNode); .)
  }
  (. Terminate(obNode); .)
.

// ------------------------------------------------------------------------------------------------
// Gets an ordering clause
// ------------------------------------------------------------------------------------------------
OrderingClause<out OrderingClauseNode ordNode>
=
  (. 
     ordNode = new OrderingClauseNode(la);
     ExpressionNode exprNode;
  .)
  Expression<out exprNode>
  (. ordNode.Expression = exprNode; .)
  [                             
    ( "ascending" | "descending" )
    (. ordNode.Direction = t; .)
  ]               
.

// ------------------------------------------------------------------------------------------------
// Gets a "select" clause
// ------------------------------------------------------------------------------------------------
SelectClause<out SelectClauseNode selNode>
=
  // --- At this point ident is "select"
  ident
  (. 
     selNode = new SelectClauseNode(t);
     ExpressionNode exprNode; 
  .)
  Expression<out exprNode>  
  (. 
     selNode.Expression = exprNode;
     Terminate(selNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Gets a "group..by" clause
// ------------------------------------------------------------------------------------------------
GroupClause<out GroupByClauseNode groupNode>
  (. groupNode = null; .)
=
  (. ExpressionNode exprNode; .)
  // --- At this point ident is "group"
  ident
  (. groupNode = new GroupByClauseNode(t); .)
  Expression<out exprNode>
  (. groupNode.GroupExpression = exprNode; .)
  "by"
  (. groupNode.ByToken = t; .)
  Expression<out exprNode>
  (. 
     groupNode.ByExpression = exprNode; 
     Terminate(groupNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Retrieves an expression.
// ------------------------------------------------------------------------------------------------
Expression<out ExpressionNode exprNode>   
  (. 
     exprNode = null;
     ExpressionNode leftExprNode;
  .)
=
  (
    IF (IsQueryExpression())
    (.
       var qNode = new QueryExpressionNode(la);    
       FromClauseNode fromNode; 
       exprNode = qNode;
    .)
    FromClause<out fromNode>
    (. 
       qNode.FromClause = fromNode; 
       QueryBodyNode bodyNode;
    .)
    QueryBody<out bodyNode>
  |
    IF (IsLambda()) 
    (.
       var lambdaNode = new LambdaExpressionNode(t);
       exprNode = lambdaNode;
    .)              
    LambdaFunctionSignature<lambdaNode>
    "=>"
    (. lambdaNode.LambdaToken = t; .)
    LambdaFunctionBody<lambdaNode>
    (. Terminate(lambdaNode); .)
  |
  Unary<out leftExprNode>
  (
    IF (assgnOps[la.kind] || (la.kind == _gt && Peek(1).kind == _gteq))
    (. BinaryOperatorNode asgnNode; .)
    AssignmentOperator<out asgnNode>  
    (. ExpressionNode rightExprNode; .)
    Expression<out rightExprNode>
    (. 
       asgnNode.RightOperand = rightExprNode;
       asgnNode.LeftOperand = leftExprNode;
       exprNode = asgnNode;
    .)
  | (. BinaryOperatorNode ncNode; .)
    NullCoalescingExpr<out ncNode> 
    (. 
       if (ncNode == null)
       {
         exprNode = leftExprNode;
       }
       else
       {
         ncNode.LeftmostNonNull.LeftOperand = leftExprNode;
         exprNode = ncNode;
       }
    .)
    [ 
      "?"                            
      (. 
         ConditionalOperatorNode condNode = null;
         if (exprNode != null) condNode = new ConditionalOperatorNode(exprNode);
         exprNode = condNode;
         ExpressionNode trueNode;
      .)
      Expression<out trueNode>
      (. if (condNode != null) condNode.TrueExpression = trueNode; .)
      ":"                         
      (. ExpressionNode falseNode; .)
      Expression<out falseNode>
      (. 
         if (condNode != null) 
         {
           condNode.FalseExpression = falseNode; 
           Terminate(condNode);
         }
      .)
    ]
  )
  )                               
  (. if (exprNode != null) Terminate(exprNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines a null coalescing operator.
// ------------------------------------------------------------------------------------------------
NullCoalescingExpr<out BinaryOperatorNode exprNode>
=                     
  (. exprNode = null; .)
  OrExpr<out exprNode>    
  { 
    "??"                  
    (. 
       var opNode = new NullCoalescingOperatorNode(t);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>
    (. BinaryOperatorNode rgNode; .) 
    OrExpr<out rgNode> 
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines a "logical or" operator.
// ------------------------------------------------------------------------------------------------
OrExpr<out BinaryOperatorNode exprNode>
= 
  (. exprNode = null; .)
  AndExpr<out exprNode>    
  { 
    "||"                  
    (. 
       var opNode = new LogicalOrOperatorNode(t);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryOperatorNode rgNode; .) 
    AndExpr<out rgNode> 
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines a "logical and" operator.
// ------------------------------------------------------------------------------------------------
AndExpr<out BinaryOperatorNode exprNode>
= 
  (. exprNode = null; .)
  BitOrExpr<out exprNode>    
  { 
    "&&"                  
    (. 
       var opNode = new LogicalAndOperatorNode(t);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryOperatorNode rgNode; .) 
    BitOrExpr<out rgNode> 
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines a "bitwise or" operator.
// ------------------------------------------------------------------------------------------------
BitOrExpr<out BinaryOperatorNode exprNode>
= 
  (. exprNode = null; .)
  BitXorExpr<out exprNode>    
  { 
    "|"
    (. 
       var opNode = new BitwiseOrOperatorNode(t);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryOperatorNode rgNode; .) 
    BitXorExpr<out rgNode> 
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines a "bitwise xor" operator.
// ------------------------------------------------------------------------------------------------
BitXorExpr<out BinaryOperatorNode exprNode> 
= 
  (. exprNode = null; .)
  BitAndExpr<out exprNode>    
  { 
    "^"                   
    (. 
       var opNode = new BitwiseXorOperatorNode(t);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryOperatorNode rgNode; .) 
    BitAndExpr<out rgNode> 
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines a "bitwise and" operator.
// ------------------------------------------------------------------------------------------------
BitAndExpr<out BinaryOperatorNode exprNode> 
= 
  (. exprNode = null; .)
  EqlExpr<out exprNode>    
  { 
    "&"                   
    (. 
       var opNode = new BitwiseAndOperatorNode(t);
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryOperatorNode rgNode; .) 
    EqlExpr<out rgNode> 
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines an "==" or "!=" operator.
// ------------------------------------------------------------------------------------------------
EqlExpr<out BinaryOperatorNode exprNode>
= 
  (. exprNode = null; .)
  RelExpr<out exprNode>       
  (. BinaryOperatorNode opNode = null; .)
  {           
    (                     
      "!="                
      (. opNode = new EqualOperatorNode(t); .)
    | "=="              
      (. opNode = new EqualOperatorNode(t); .)
    )
    (. 
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryOperatorNode rgNode; .) 
    RelExpr<out rgNode> 
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines relational and typecheck operators.
// ------------------------------------------------------------------------------------------------
RelExpr<out BinaryOperatorNode exprNode> 
= 
  (. exprNode = null; .)
  ShiftExpr<out exprNode>  
  (. BinaryOperatorNode opNode = null; .)
  { 
    (
      "<"                 
      (. opNode = new LessThanOperatorNode(t); .)
    | ">"               
      (. opNode = new GreaterThanOperatorNode(t); .)
    | "<="              
      (. opNode = new LessThanOrEqualOperatorNode(t); .)
    | ">="              
      (. opNode = new GreaterThanOrEqualOperatorNode(t); .)
    )
    (. 
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryOperatorNode rgNode; .) 
    ShiftExpr<out rgNode>             
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
    |
      (
        "is"            
        (. opNode = new IsOperatorNode(t); .)
      | "as"            
        (. opNode = new AsOperatorNode(t); .)
      )                   
      (. TypeOrNamespaceNode typeNode; .)
      TypeInRelExpr<out typeNode>
      (. 
         opNode.RightOperand = new TypeOperatorNode(typeNode);
         exprNode = opNode;
         Terminate(opNode); 
      .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines shift operators.
// ------------------------------------------------------------------------------------------------
ShiftExpr<out BinaryOperatorNode exprNode> 
= 
  (. 
     exprNode = null;
     Token start;
  .)
  AddExpr<out exprNode>       
  (. BinaryOperatorNode opNode = null; .)
  { IF (IsShift())
    (
      "<<"
      (. opNode = new LeftShiftOperatorNode(t); .)
    | ">" 
      (. start = t; .)
      ">"           
      (. opNode = new RightShiftOperatorNode(start, t); .)
    )                     
    (. 
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryOperatorNode rgNode; .) 
    AddExpr<out rgNode>
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines addition operators.
// ------------------------------------------------------------------------------------------------
AddExpr<out BinaryOperatorNode exprNode> 
= 
  (. exprNode = null; .)
  MulExpr<out exprNode>       
  (. BinaryOperatorNode opNode = null; .)
  {
    ( 
      "+"                 
      (. opNode = new AddOperatorNode(t); .)
    | "-"               
      (. opNode = new SubtractOperatorNode(t); .)
    )                     
    (. 
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. BinaryOperatorNode rgNode; .) 
    MulExpr<out rgNode>
    (. 
       BindBinaryOperator(opNode, unaryNode, rgNode);
       exprNode = opNode;
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Defines multiplication operators.
// ------------------------------------------------------------------------------------------------
MulExpr<out BinaryOperatorNode exprNode> 
=                          
  (. 
     exprNode = null;
     BinaryOperatorNode opNode = null;
  .)
  {
    (
      "*"                 
      (. opNode = new MultiplyOperatorNode(t); .)
    | "/"               
      (. opNode = new DivideOperatorNode(t); .)
    | "%"               
      (. opNode = new ModuloOperatorNode(t); .)
    )                     
    (. 
       opNode.LeftOperand = exprNode;
       ExpressionNode unaryNode;
    .)
    Unary<out unaryNode>     
    (. 
       opNode.RightOperand = unaryNode;
       exprNode = opNode;
       Terminate(opNode);
    .)
  }
.

// ------------------------------------------------------------------------------------------------
// Retrieves an unary expression.
// ------------------------------------------------------------------------------------------------
Unary<out ExpressionNode exprNode>   
  (. 
     exprNode = null;  
     UnaryOperatorNode unaryOp = null;
  .)
=
  (
    IF (unaryHead[la.kind] || IsTypeCast())
    ( 
      "+"     
      (. unaryOp = new UnaryPlusOperatorNode(t); .)
    | "-"   
      (. unaryOp = new UnaryMinusOperatorNode(t);.)
    | "!"   
      (. unaryOp = new UnaryNotOperatorNode(t); .)
    | "~"   
      (. unaryOp = new BitwiseNotOperatorNode(t); .)
    | "++"  
      (. unaryOp = new PreIncrementOperatorNode(t); .)
    | "--"  
      (. unaryOp = new PreDecrementOperatorNode(t); .)
    | "*"   
      (. unaryOp = new PointerOperatorNode(t); .)
    | "&"   
      (. unaryOp = new ReferenceOperatorNode(t); .)
    | "("   
      (. 
         TypeOrNamespaceNode typeNode; 
         var tcNode = new TypecastOperatorNode(t);
         unaryOp = tcNode;
      .)
      Type<out typeNode> 
      (. tcNode.TypeName = typeNode; .)
      ")"
      (. Terminate(tcNode); .)
    )
  )
  (. ExpressionNode unaryNode; .)
  Unary<out unaryNode>
  (. 
     if (unaryOp == null) exprNode = unaryNode;
     else
     {
       unaryOp.Operand = unaryNode;
       exprNode = unaryOp;
     }
     Terminate(unaryOp);
  .)
  | 
    Primary<out exprNode>
.

// ------------------------------------------------------------------------------------------------
// Retrieves a primary expression.
// ------------------------------------------------------------------------------------------------
Primary<out ExpressionNode exprNode>
=
  (. 
     ExpressionNode innerNode = null;
     exprNode = null;
  .)
  ( 
    Literal<out innerNode>             
  | 
    "("
    (. var pExprNode = new ParenthesisExpressionNode(t); .) 
    Expression<out innerNode>
    (. 
       pExprNode.Expression = innerNode;
       innerNode = pExprNode;
    .)
    ")"  
    (. Terminate(pExprNode); .)
  | PrimitiveNamedLiteral<out innerNode>
  | NamedLiteral<out innerNode>
  | "this" 
    (. innerNode = new ThisNode(t); .)
  | "base" 
    (. innerNode = new BaseNode(t); .)
  | NewOperator<out innerNode>
  | TypeOfOperator<out innerNode>
  | CheckedOperator<out innerNode>
  | UncheckedOperator<out innerNode>
  | DefaultOperator<out innerNode>
  | AnonymousDelegate<out innerNode>
  | SizeOfOperator<out innerNode>
  )
  (. var curExprNode = innerNode; .)
  { 
  (
      "++"  
      (. 
         var incNode = new PostIncrementOperatorNode(t);
         incNode.Operand = curExprNode;
         curExprNode = incNode;
      .) 
    | "--"  
      (. 
         var decNode = new PostDecrementOperatorNode(t);
         decNode.Operand = curExprNode;
         curExprNode = decNode;
      .) 
    | "->"  
      (. 
         SimpleNameNode snlNode;
         var ctypeNode = new CTypeMemberAccessOperatorNode(t);
      .)
      SimpleNamedLiteral<out snlNode>
      (. 
         ctypeNode.ScopeOperand = curExprNode;
         ctypeNode.MemberName = snlNode;
         curExprNode = ctypeNode;
      .)
    | "."   
      (. 
         SimpleNameNode snlNode;
         var maNode = new MemberAccessOperatorNode(t);
      .)
      SimpleNamedLiteral<out snlNode>
      (. 
         maNode.ScopeOperand = curExprNode;
         maNode.MemberName = snlNode;
         curExprNode = maNode;
      .)
    | "("   
      (. 
         var invNode = new MethodInvocationOperatorNode(t);
         invNode.ScopeOperand = curExprNode;
      .)
      CurrentArgumentList<invNode.Arguments>
      ")"   
      (. 
         Terminate(invNode);
         curExprNode = invNode;
      .)
    |       
      "["
      (. 
         var indNode = new ArrayIndexerInvocationOperatorNode(t);
         indNode.ScopeOperand = curExprNode;
      .)
      ArrayIndexer<indNode.Arguments> 
      "]"
      (. Terminate(indNode); .)
  )         
  }
  (. exprNode = curExprNode; .)
.

// ------------------------------------------------------------------------------------
// Declaration of a literal expression.
// ------------------------------------------------------------------------------------
Literal<out ExpressionNode valNode>
  (. valNode = null; .)
= 
    intCon        
    (. valNode = IntegerConstantNode.Create(t); .)
  | realCon     
    (. valNode = RealConstantNode.Create(t); .)
  | charCon     
    (. valNode = new CharNode(t); .)
  | stringCon   
    (. valNode = new StringNode(t); .)
  | "true"
    (. valNode = new TrueNode(t); .)
  | "false"     
    (. valNode = new FalseNode(t); .)
  | "null"      
    (. valNode = new NullNode(t); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a primitive named literal expression.
// ------------------------------------------------------------------------------------------------
PrimitiveNamedLiteral<out ExpressionNode exprNode>  
=            
  (. exprNode = null; .)
  (   "bool"
    | "byte"
    | "char"
    | "decimal"
    | "double"
    | "float"
    | "int"
    | "long"
    | "object"
    | "sbyte"
    | "short"
    | "string"
    | "uint"
    | "ulong"
    | "ushort"
  )               
  (. 
     var pnNode = new PrimitiveNamedNode(t);
     exprNode = pnNode;
  .)
  "." 
  (. pnNode.SeparatorToken = t; .)
  ident           
  (. 
     pnNode.IdentifierToken = t;
     Terminate(pnNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a named literal expression.
// ------------------------------------------------------------------------------------------------
NamedLiteral<out ExpressionNode exprNode>  
=              
  (. exprNode = null; .)
  ident        
  (. 
     var nlNode = new ScopedNameNode(t);
     exprNode = nlNode;
  .)
  [ 
    "::"       
    (. 
       nlNode.QualifierSeparatorToken = t;
       nlNode.QualifierToken = nlNode.IdentifierToken;
    .)
    ident      
    (. nlNode.IdentifierToken = t; .)
  ] 
  (. TypeOrNamespaceNodeCollection argList; .)
  [ 
    IF (IsGeneric()) TypeArgumentList<out argList>
    (. nlNode.Arguments = argList; .)
  ]
  (. Terminate(nlNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a simple named literal expression.
// ------------------------------------------------------------------------------------------------
SimpleNamedLiteral<out SimpleNameNode snlNode> 
=
  ident        
  (. snlNode = new SimpleNameNode(t); .)
  (. TypeOrNamespaceNodeCollection argList; .)
  [ 
    IF (IsGeneric()) TypeArgumentList<out argList>
    (. snlNode.Arguments = argList; .)
  ]
  (. Terminate(snlNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "typeof" operator.
// ------------------------------------------------------------------------------------------------
TypeOfOperator<out ExpressionNode exprNode>
= 
  "typeof"                   
  (. 
     var topNode = new TypeofOperatorNode(t);
     exprNode = topNode;
  .)
  "("                        
  (. 
     topNode.OpenParenthesis = t;
     TypeOrNamespaceNode typeNode;
  .)
  Type<out typeNode>
  (. topNode.TypeName = typeNode; .)
  ")"
  (. 
     topNode.CloseParenthesis = t;
     Terminate(exprNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "sizeof" operator.
// ------------------------------------------------------------------------------------------------
SizeOfOperator<out ExpressionNode exprNode>
= 
  "sizeof"                   
  (. 
     var sopNode = new SizeofOperatorNode(t);
     exprNode = sopNode;
  .)
  "("                        
  (. 
     sopNode.OpenParenthesis = t;
     TypeOrNamespaceNode typeNode;
  .)
  Type<out typeNode>  
  (. sopNode.TypeName = typeNode; .)
  ")"                        
  (. 
     sopNode.CloseParenthesis = t;
     Terminate(exprNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "checked" operator.
// ------------------------------------------------------------------------------------------------
CheckedOperator<out ExpressionNode exprNode>
= 
  "checked"                     
  (. 
     var copNode = new CheckedOperatorNode(t);
     exprNode = copNode;
  .)
  "("                           
  (. 
     copNode.OpenParenthesis = t;
     ExpressionNode innerNode;
  .)
  Expression<out innerNode>   
  (. copNode.Expression = innerNode; .)
  ")"
  (. 
     copNode.CloseParenthesis = t;
     Terminate(exprNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of an "unchecked" operator.
// ------------------------------------------------------------------------------------------------
UncheckedOperator<out ExpressionNode exprNode>
= 
  "unchecked"                   
  (. 
     var uopNode = new UncheckedOperatorNode(t);
     exprNode = uopNode;
  .)
  "("                           
  (. 
     uopNode.OpenParenthesis = t;
     ExpressionNode innerNode;
  .)
  Expression<out innerNode>
  (. uopNode.Expression = innerNode; .)
  ")"                           
  (. 
     uopNode.CloseParenthesis = t;
     Terminate(exprNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "default" operator.
// ------------------------------------------------------------------------------------------------
DefaultOperator<out ExpressionNode exprNode>
= 
  "default"                 
  (. 
     var defNode = new DefaultOperatorNode(t);
     exprNode = defNode;
  .)
  "("                       
    (. 
       defNode.OpenParenthesis = t;
       ExpressionNode primNode;
    .)
    Primary<out primNode>  
    (. defNode.Expression = primNode; .)
  ")"                       
  (. 
     defNode.CloseParenthesis = t;
     Terminate(defNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "new" operator.
// ------------------------------------------------------------------------------------------------
NewOperator<out ExpressionNode exprNode>  
= 
  (. exprNode = null; .)
  "new"
  (. var newToken = t; .)
  (
    (. var anonNode = new NewOperatorWithAnonymousTypeNode(t); .)
    AnonymousObjectInitializer<anonNode>
    (. exprNode = anonNode; .)
  |
    (. TypeOrNamespaceNode typeNode; .)
    NonArrayType<out typeNode>
    NewOperatorWithType<newToken, typeNode, out exprNode>
  |
    (. var impArrNode = new NewOperatorWithArrayNode(t); .)
    ImplicitArrayCreation<impArrNode>
    (. exprNode = impArrNode; .)
  )
  (. Terminate(exprNode); .)
.

// ------------------------------------------------------------------------------------------------
// Represents an anonymous object initializer
// ------------------------------------------------------------------------------------------------
AnonymousObjectInitializer<NewOperatorWithAnonymousTypeNode anonNode>
=
  "{"                                   
  (. anonNode.OpenBrace = t; .)
  (
    IF (!IsEmptyMemberInitializer()) 
    MemberDeclaratorList<anonNode> 
    [ 
      "," 
      (. anonNode.OrphanComma = t; .)
    ]
  )
  "}"
  (. 
     anonNode.CloseBrace = t; 
     Terminate(anonNode);
  .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of "new" operator member declaration list.
// ------------------------------------------------------------------------------------------------
MemberDeclaratorList<NewOperatorWithAnonymousTypeNode initNode>  
=                     
  (. MemberDeclaratorNode mdNode; .)
  MemberDeclarator<out mdNode>     
  (. initNode.Declarators.Add(mdNode); .)
  {
    IF (NotFinalComma()) 
    ","
    (. var separator = t; .)
    MemberDeclarator<out mdNode>   
    (. initNode.Declarators.Add(separator, mdNode); .)
  } 
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "new" operator declaration member.
// ------------------------------------------------------------------------------------------------
MemberDeclarator<out MemberDeclaratorNode mdNode> 
=
  (. 
     ExpressionNode exprNode;
     mdNode = null;
  .)
  (
    IF (IsMemberInitializer())
    ident                         
    (. 
       Token start = t; 
       mdNode = new MemberDeclaratorNode(t);
       mdNode.Kind = MemberDeclaratorNode.DeclaratorKind.Expression;
    .)
    "=" 
    (. mdNode.EqualToken = t; .)
    Expression<out exprNode>
    (. mdNode.Expression = exprNode; .)
  | 
    (. 
       Token start = la; 
       ExpressionNode primNode;
    .)
    Primary<out primNode>
    (. 
       mdNode = new MemberDeclaratorNode(primNode == null ? t : primNode.StartToken);
       mdNode.Kind = MemberDeclaratorNode.DeclaratorKind.SimpleName;
       mdNode.Expression = primNode;
    .)
  |
    (. TypeOrNamespaceNode typeNode; .)
    PredefinedType<out typeNode>
    (. 
       mdNode = new MemberDeclaratorNode(typeNode.StartToken);
       mdNode.Kind = MemberDeclaratorNode.DeclaratorKind.MemberAccess;
       mdNode.TypeName = typeNode;
    .)
    "."
    (. mdNode.DotSeparator = t; .)
    ident                         
    (. mdNode.IdentifierToken = t; .)
  )
  (. Terminate(mdNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a "new" operator with explicit type.
// ------------------------------------------------------------------------------------------------
NewOperatorWithType<Token newToken, TypeOrNamespaceNode typeNode, out ExpressionNode exprNode>
  (. exprNode = null; .)
=
  (. ObjectOrCollectionInitializerNode initNode; .)                 
  (
    // --- Simple constructor call
    (. 
       var scNode = new NewOperatorWithConstructorNode(newToken); 
       scNode.TypeName = typeNode;
       exprNode = scNode;
    .)
    "("
    (.
       var invNode = new MethodInvocationOperatorNode(t);
       invNode.ScopeOperand = scNode;
    .)
    CurrentArgumentList<invNode.Arguments>
    ")"
    (.
       Terminate(invNode);
       scNode.Initializer = invNode;
    .)
    // --- Optional initializer list
    [         
      ObjectOrCollectionInitializer<out initNode>
      (. scNode.ObjectInitializer = initNode; .)
    ]
    (. Terminate(scNode); .)
    
  | // --- Implicit default constructor call
    (. 
       var scNode = new NewOperatorWithConstructorNode(newToken); 
       scNode.TypeName = typeNode;
       exprNode = scNode;
    .)
    ObjectOrCollectionInitializer<out initNode>
    (. 
       scNode.ObjectInitializer = initNode; 
       Terminate(scNode);
    .)
    
  | // --- Array initialization
    IF (IsDims())                 
    (. 
       var newOpNode = new NewOperatorWithArrayNode(t); 
       newOpNode.TypeName = typeNode;
       exprNode = newOpNode;
    .)
    ImplicitArrayCreation<newOpNode>
    (. Terminate(newOpNode); .)
    
  | // --- New array creation
    (. 
       var newOpNode = new NewOperatorWithArrayNode(newToken); 
       newOpNode.TypeName = typeNode;
       exprNode = newOpNode;
       ExpressionNode initExprNode; 
    .)
    "["
    (. newOpNode.SizedDimensions.StartToken = t; .)
    Expression<out initExprNode>
    (. newOpNode.SizedDimensions.Add(initExprNode); .)
    { 
      ","
      (. var separator = t; .)
      Expression<out initExprNode>
      (. newOpNode.SizedDimensions.Add(separator, initExprNode); .)
    } 
    "]" 
    (. Terminate(newOpNode.SizedDimensions); .)
    { IF (IsDims()) 
      "["
       (. newOpNode.OpenSquareBracket = t; .)
        { 
          ","
          (. newOpNode.Commas.Add(t); .)
        } 
      "]" 
      (. newOpNode.CloseSquareBracket = t; .)
    }
    [            
      (. ArrayInitializerNode arrInitNode; .)                 
      ArrayInitializer<out arrInitNode> 
      (. newOpNode.Initializer = arrInitNode; .)
    ] 
    (.
       Terminate(newOpNode);
       exprNode = newOpNode;
    .)
  )
.

// ------------------------------------------------------------------------------------------------
// Declaration of an implicit array creation
// ------------------------------------------------------------------------------------------------
ImplicitArrayCreation<NewOperatorWithArrayNode impArrNode> 
=
  "["
  (. impArrNode.OpenSquareBracket = t; .)
    { 
      ","                           
      (. impArrNode.Commas.Add(t); .)
    } 
  "]" 
  (. impArrNode.CloseSquareBracket = t; .)
  [        
    (. ArrayInitializerNode initNode; .)                     
    ArrayInitializer<out initNode> 
    (. impArrNode.Initializer = initNode; .)
  ]
  (. Terminate(impArrNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declares an object or collection initializer used with "new" operator
// ------------------------------------------------------------------------------------------------
ObjectOrCollectionInitializer<out ObjectOrCollectionInitializerNode oiNode>
=
  "{"
  (. oiNode = new ObjectOrCollectionInitializerNode(t); .)
  (
    IF (IsEmptyMemberInitializer()) 
    "}"   
    (. Terminate(oiNode); .)
  |
    IF (IsMemberInitializer()) 
    MemberInitializerList<oiNode>
    [ 
      "," 
      (. oiNode.OrphanSeparator = t; .)
    ]
    "}"
    (. Terminate(oiNode); .)
  |
    ElementInitializerList<oiNode>
    [ 
      "," 
      (. oiNode.OrphanSeparator = t; .)
    ]
    "}"
    (. Terminate(oiNode); .)
  )
.

// ------------------------------------------------------------------------------------------------
// Declares an element initializer list of a collection used with "new" operator
// ------------------------------------------------------------------------------------------------
ElementInitializerList<ObjectOrCollectionInitializerNode ocNode>
=
  (. ElementInitializerNode eiNode; .)
  ElementInitializer<out eiNode>
  (. ocNode.ElementInitializers.Add(eiNode); .)
  {
    IF (NotFinalComma()) 
    ","
    (. var separator = t; .)
    ElementInitializer<out eiNode>
    (. ocNode.ElementInitializers.Add(separator, eiNode); .)
  } 
.

// ------------------------------------------------------------------------------------------------
// Declares an element initializer of a collection used with "new" operator
// ------------------------------------------------------------------------------------------------
ElementInitializer<out ElementInitializerNode eiNode>
=
  (. 
     eiNode = new ElementInitializerNode(la);
     ExpressionNode exprNode; 
  .)
  (
    IF (IsValueInitializer())
    Expression<out exprNode>
    (. eiNode.Expression = exprNode; .)
  | 
    "{"
    (. eiNode.ExpressionList.StartToken = t; .)
      Expression<out exprNode>
      (. eiNode.ExpressionList.Add(exprNode); .)
      {
        ","
        (. var separator = t; .)
        Expression<out exprNode>
        (. eiNode.ExpressionList.Add(separator, exprNode); .)
      }
    "}"
    (. Terminate(eiNode.ExpressionList); .)
  )
  (. Terminate(eiNode);.)
.

// ------------------------------------------------------------------------------------------------
// A member initialization list declaration
// ------------------------------------------------------------------------------------------------
MemberInitializerList<ObjectOrCollectionInitializerNode ocNode>
=                  
  (. MemberInitializerNode miNode; .)   
  MemberInitializer<out miNode>
  (. ocNode.MemberInitializers.Add(miNode); .)
  {
    IF (NotFinalComma()) 
    ","
    (. var separator = t; .)
    MemberInitializer<out miNode>
    (. ocNode.MemberInitializers.Add(separator, miNode); .)
  } 
.

// ------------------------------------------------------------------------------------------------
// A member initialization declaration
// ------------------------------------------------------------------------------------------------
MemberInitializer<out MemberInitializerNode miNode>
=
  ident
  (. miNode = new MemberInitializerNode(t); .)
  "="
  (. miNode.EqualToken = t; .)
  (
    IF (IsValueInitializer())
    (. ExpressionNode exprNode; .)
    Expression<out exprNode>
    (. miNode.Expression = exprNode; .)
  |          
    (. ObjectOrCollectionInitializerNode initNode; .)                 
    ObjectOrCollectionInitializer<out initNode>
    (. miNode.Initializer = initNode; .)
  )
  (. Terminate(miNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declarares an anonymous delegate with its body.
// ------------------------------------------------------------------------------------------------
AnonymousDelegate<out ExpressionNode exprNode>  
= 
  "delegate"            
  (. 
     var adNode = new AnonymousDelegateNode(t);
     exprNode = adNode;
  .)
  [                     
    "("
    (. 
       var parsNode = new FormalParameterListNode(t); 
       adNode.ParameterList = parsNode;
    .)
    [ 
      (. FormalParameterNode parNode; .)
      AnonymousMethodParameter<out parNode>
      (. parsNode.Items.Add(parNode); .)
      { 
        "," 
        (. var separator = t; .)
        AnonymousMethodParameter<out parNode>   
        (. parsNode.Items.Add(separator, parNode); .)
      } 
    ] 
    ")" 
    (. Terminate(parsNode); .)
  ] 
  (. BlockStatementNode blockNode; .)
  Block<out blockNode>           
  (. Terminate(exprNode); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of an anonymous method parameter.
// ------------------------------------------------------------------------------------------------
AnonymousMethodParameter<out FormalParameterNode parNode> 
=
  (. 
     var modifier = FormalParameterModifier.In; 
     Token start = null;
     parNode = null;
  .)
  [
    (
      "ref"         
      (. modifier = FormalParameterModifier.Ref; .) 
    | "out"                     
      (. modifier = FormalParameterModifier.Out; .) 
    )
    (. start = t; .)
  ]                             
  (. TypeOrNamespaceNode typeNode; .)
  Type<out typeNode>      
  (. if (start == null) start = typeNode.StartToken; .)
  ident                         
  (. 
     parNode = new FormalParameterNode(start);
     parNode.Modifier = modifier;
     parNode.IdentifierToken = t;
     parNode.TypeName = typeNode;
     Terminate(parNode);
  .)  
.

// ------------------------------------------------------------------------------------------------
// Declaration of an array indexer operator.
// ------------------------------------------------------------------------------------------------
ArrayIndexer<ArgumentNodeCollection argNodes> 
= 
  (. 
     ExpressionNode exprNode; 
     Token separator = null;
  .) 
  Expression<out exprNode>
  (. 
     if (argNodes != null)
     {
       var argNode = new ArgumentNode(exprNode == null ? t : exprNode.StartToken);
       argNode.Expression = exprNode;
       Terminate(argNode);
       argNodes.Add(argNode);
     }
  .)
  { 
    "," 
    (. separator = t; .)
    Expression<out exprNode>
    (. 
       if (argNodes != null)
       {
         var argNode = new ArgumentNode(exprNode == null ? t : exprNode.StartToken);
         argNode.Expression = exprNode;
         Terminate(argNode);
         argNodes.Add(separator, argNode);
       }
    .)
  } 
.

// ------------------------------------------------------------------------------------------------
// Declaration of a field member variable.
// ------------------------------------------------------------------------------------------------
FieldMemberDeclarators<FieldDeclarationNode fiNode>
= 
  (. FieldTagNode tagNode; .)
  SingleFieldMember<out tagNode>
  (. fiNode.FieldTags.Add(tagNode); .)
  { 
    "," 
    (. var separator = t; .)
    SingleFieldMember<out tagNode>
    (. fiNode.FieldTags.Add(separator, tagNode); .)
  }
.

// ------------------------------------------------------------------------------------------------
// Declaration of a single field member.
// ------------------------------------------------------------------------------------------------
SingleFieldMember<out FieldTagNode fiNode>
= 
  ident                      
  (. fiNode = new FieldTagNode(t); .)
  [ 
    "="                      
    (. 
       fiNode.EqualToken = t;
       VariableInitializerNode varInitNode; 
    .)
    VariableInitializer<out varInitNode> 
    (. fiNode.Initializer = varInitNode; .) 
  ]                          
  (. Terminate(fiNode); .)
.

// ------------------------------------------------------------------------------------------------
// Defines the operators that can be overloaded.
// ------------------------------------------------------------------------------------------------
OverloadableOp<OperatorDeclarationNode opNode>
=  
  ( ">"
    (.
       opNode.KindToken = t;
       opNode.Kind = OverloadableOperatorType.GreaterThan;
    .)
    [                       
      (. if (la.pos > t.pos+1) Error("UNDEF", la, "no whitespace allowed in right shift operator"); .)
      ">"
      (.
         opNode.SecondKindToken = t;
         opNode.Kind = OverloadableOperatorType.RightShift;
      .)
    ]                        
  )   
  |
  ( 
    "+"                                     
    (. opNode.Kind = OverloadableOperatorType.Addition; .)
  | "-"
    (. opNode.Kind = OverloadableOperatorType.Subtraction; .)
  | "!"
    (. opNode.Kind = OverloadableOperatorType.Not; .)
  | "~"
    (. opNode.Kind = OverloadableOperatorType.BitwiseNot; .)
  | "++"
    (. opNode.Kind = OverloadableOperatorType.Increment; .)
  | "--"
    (. opNode.Kind = OverloadableOperatorType.Decrement; .)
  | "true"
    (. opNode.Kind = OverloadableOperatorType.True; .)
  | "false"
    (. opNode.Kind = OverloadableOperatorType.False; .)
  | "*"    
    (. opNode.Kind = OverloadableOperatorType.Multiplication; .)
  | "/"    
    (. opNode.Kind = OverloadableOperatorType.Division; .)
  | "%"
    (. opNode.Kind = OverloadableOperatorType.Modulo; .)
  | "&"
    (. opNode.Kind = OverloadableOperatorType.BitwiseAnd; .)
  | "|"
    (. opNode.Kind = OverloadableOperatorType.BitwiseOr; .)
  | "^"
    (. opNode.Kind = OverloadableOperatorType.BitwiseXor; .)
  | "<<"
    (. opNode.Kind = OverloadableOperatorType.LeftShift; .)
  | "=="
    (. opNode.Kind = OverloadableOperatorType.Equal; .)
  | "!="
    (. opNode.Kind = OverloadableOperatorType.NotEqual; .)
  | "<"                         
    (. opNode.Kind = OverloadableOperatorType.LessThan; .)
  | ">="                        
    (. opNode.Kind = OverloadableOperatorType.GreaterThanOrEqual; .)
  | "<="                        
    (. opNode.Kind = OverloadableOperatorType.LessThanOrEqual; .)
  )
  (. opNode.KindToken = t; .)
.

// ------------------------------------------------------------------------------------------------
// Type parameter declarations for generic types.
// ------------------------------------------------------------------------------------------------
TypeParameterList<ITypeParameterHolder paramNode>
=                            
  (. 
     Token identifier;
     AttributeDecorationNodeCollection attrNodes;
  .)
  "<" 
  (. Start(paramNode.TypeParameters); .)                      
  TypeParameter<out attrNodes, out identifier>      
  (. paramNode.TypeParameters.Add(new TypeParameterNode(identifier, attrNodes)); .)
  { 
    "," 
    (. var separator= t; .)
    TypeParameter<out attrNodes, out identifier>      
    (. paramNode.TypeParameters.Add(new TypeParameterNode(separator, identifier, attrNodes)); .)
  } 
  ">"
  (. Terminate(paramNode.TypeParameters); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a type parameter.
// ------------------------------------------------------------------------------------------------
TypeParameter<out AttributeDecorationNodeCollection attrNodes, out Token identifier>
=                         
  (. attrNodes = new AttributeDecorationNodeCollection(); .)
  AttributeDecorations<attrNodes>
  ident
  (. identifier = t; .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a type argument list.
// ------------------------------------------------------------------------------------------------
TypeArgumentList<out TypeOrNamespaceNodeCollection argList>  
= 
  (. argList = null; .) 
  // --- We are a bit sloppy here and allow the type arguments to be "empty" everywhere. This 
  // --- results in unbound-type-names. In fact this is only allowed in typeof statements, 
  // --- see ECMA-334: 14.5.11 and 25.5.
  "<"
  (. 
     argList = new TypeOrNamespaceNodeCollection(); 
     Start(argList);
  .)
  [ 
    (. TypeOrNamespaceNode typeNode; .)
    Type<out typeNode>
    (. argList.Add(typeNode); .)          
  ]                              
  { 
    ","
    (. var separator = t; .)
    [ 
      (. TypeOrNamespaceNode typeNode; .)
      Type<out typeNode>           
      (. argList.Add(separator, typeNode); .)          
    ]
  } 
  ">"
  (. Terminate(argList); .)
.

// ------------------------------------------------------------------------------------------------
// Declaration of a type parameter constraint belonging to a type, a method or a delegate.
// ------------------------------------------------------------------------------------------------
TypeParameterConstraintsClause<out TypeParameterConstraintNode constrNode>   
=
  (. 
     Token start;
     Token identifier;
  .)      
  "where"
  (. start = t; .)
  ident                        
  (. identifier = t; .)
  ":"
  (. 
     constrNode = new TypeParameterConstraintNode(start, identifier, t);
     TypeParameterConstraintTagNode tag;
  .)
  TypeParameterConstraintTag<out tag>
  (. constrNode.ConstraintTags.Add(tag); .)
  {
    "," 
    (. var separator = t; .)
    TypeParameterConstraintTag<out tag>
    (. constrNode.ConstraintTags.Add(separator, tag); .)
  }
  (. Terminate(constrNode); .)
.

// ------------------------------------------------------------------------------------------------
// Obtains a type parameter constraint tag.
// ------------------------------------------------------------------------------------------------
TypeParameterConstraintTag<out TypeParameterConstraintTagNode tag> 
  (. tag = null; .)
=
  "class"                    
  (. tag = new TypeParameterConstraintTagNode(t); .)
  |
  "struct"                   
  (. tag = new TypeParameterConstraintTagNode(t); .)
  |
  "new"                      
  (. var start = t; .)
  "(" 
  (. var openPar = t; .)
  ")" 
  (. tag = new TypeParameterConstraintTagNode(start, openPar, t); .)
  |
  (. TypeOrNamespaceNode typeNode; .)
  ClassType<out typeNode>     
  (. tag = new TypeParameterConstraintTagNode(typeNode); .)
.

END CS3.