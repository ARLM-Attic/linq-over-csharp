/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/
-->begin
using System;
using System.Collections.Generic;

-->namespace

// disable warnings about missing XML comments
#pragma warning disable 1591 

  // ==============================================================================================
  /// <summary>
  /// This part of the class is generated by CoCo.
  /// </summary>
  // ==============================================================================================
  public partial class Scanner
  {
    #region Constant declarations generated by CoCo

-->declarations
    #endregion

	static Scanner() {
		start = new Dictionary<int, int>(128);
-->initialization
	}
	
    //-----------------------------------------------------------------------------------
    /// <summary>
    /// Gets the next character from the stream.
    /// </summary>
    //-----------------------------------------------------------------------------------
    public void NextCh()
    {
      if (oldEols > 0) { ch = EOL; oldEols--; }
      else
      {
        pos = buffer.Pos;
        ch = buffer.Read(); col++;
        if (!_EOFFound && ch == Buffer.EOF)
        {
          _EOFFound = true;
          ch = EOL;
        }
        // replace isolated '\r' by '\n' in order to make
        // eol handling uniform across Windows, Unix and Mac
        if (ch == '\r' && buffer.Peek() != '\n') ch = EOL;
        if (ch == EOL)
        {
          line++; 
          col = 0;
        }
      }
-->casing1
  	}

    //-----------------------------------------------------------------------------------
    /// <summary>
    /// Adds a character to the currently scanned token.
    /// </summary>
    //-----------------------------------------------------------------------------------
    void AddCh()
    {
      if (tlen >= tval.Length)
      {
        var newBuf = new char[2 * tval.Length];
        Array.Copy(tval, 0, newBuf, 0, tval.Length);
        tval = newBuf;
      }
-->casing2
  		NextCh();
	  }

-->comments

    //-----------------------------------------------------------------------------------
    /// <summary>
    /// Adds a character to the currently scanned token.
    /// </summary>
    //-----------------------------------------------------------------------------------
    void CheckLiteral()
    {
-->literals
  	}

    //-----------------------------------------------------------------------------------
    /// <summary>
    /// Adds a character to the currently scanned token.
    /// </summary>
    //-----------------------------------------------------------------------------------
    Token NextToken()
    {
		  while (ch == ' ' ||
-->scan1
		  ) NextCh();
-->scan2
      // Handle skip mode
      if (ch != Buffer.EOF && _SkipMode)
      {
        // Skip "/*" block comment begin token
        if (ch == '/') NextCh();
        if (ch != Buffer.EOF && ch == '*') NextCh();
      }
      t = new Token {pos = pos, col = col, line = line};
      int state;
      try { state = start[ch]; }
      catch (KeyNotFoundException) { state = 0; }
      tlen = 0; AddCh();

      switch (state)
      {
        case -1: { t.kind = eofSym; break; } // NextCh already done
        case 0: { t.kind = noSym; break; }   // NextCh already done
-->scan3
  		}
	  	t.val = new String(tval, 0, tlen);
		  return t;
	  }
	
  }

#pragma warning restore 1591

$$$
