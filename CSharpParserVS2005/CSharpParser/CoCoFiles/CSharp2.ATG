using System.Text;
using System.Collections;
using System.Collections.Generic;
using CSharpParser.ProjectModel;
using CSharpParser.Collections;

COMPILER CS2

    #region Project Model extension

    private CSharpProject _Project;
    private ProjectFile _File;

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Gets or sets the instance representing the project being parsed
    /// </summary>
    // --------------------------------------------------------------------------------
    public CSharpProject Project
    {
      get { return _Project; }
      set { _Project = value; }
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Gets or sets the instance representing the file being parsed
    /// </summary>
    // --------------------------------------------------------------------------------
    public ProjectFile File
    {
      get { return _File; }
      set { _File = value; }
    }

    #endregion

    #region Error handling

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Creates a new error instance.
    /// </summary>
    /// <param name="code">Error code.</param>
    /// <param name="errorPoint">Token describing the error position.</param>
    /// <param name="description">Detailed error description.</param>
    // --------------------------------------------------------------------------------
    public void Error(string code, Token errorPoint, string description)
    {
      Error error = new Error(code, errorPoint, _File.Name, description);
      _Project.Errors.Add(error);
      Error(description);
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Creates a new error instance.
    /// </summary>
    /// <param name="code">Error code.</param>
    /// <param name="errorPoint">Token describing the error position.</param>
    /// <param name="description">Detailed error description.</param>
    /// <param name="parameters">Error parameters.</param>
    // --------------------------------------------------------------------------------
    public void Error(string code, Token errorPoint, string description,
      params object[] parameters)
    {
      Error error = new Error(code, errorPoint, _File.Name, description, parameters);
      _Project.Errors.Add(error);
      Error(description);
    }

    #endregion

    #region Common parser methods

    /// <summary>List of conditional symbols</summary>
    List<string> _ConditionalSymbols = new List<string>();

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Adds a list of symbol to the list of existing symbols.
    /// </summary>
    /// <param name="symbols">Array of symbols to add.</param>
    // --------------------------------------------------------------------------------
    public void AddConditionalCompilationSymbols(String[] symbols)
    {
      if (symbols != null)
      {
        for (int i = 0; i < symbols.Length; ++i)
        {
          symbols[i] = symbols[i].Trim();
          if (symbols[i].Length > 0 && !_ConditionalSymbols.Contains(symbols[i]))
          {
            _ConditionalSymbols.Add(symbols[i]);
          }
        }
      }
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Gets the end of the whitespaces in the given string.
    /// </summary>
    /// <param name="symbol">Symbol to search for white spaces</param>
    /// <param name="start">Startinf index of the string representing the symbol</param>
    /// <param name="whitespaces">
    /// Flag indicating if we look for whitespace or non-whitespace
    /// </param>
    /// <returns>
    /// The end of the whitespaces in the given string if whitespaces is true;
    /// otherwise returns the end of the non-whitespaces.
    /// </returns>
    // --------------------------------------------------------------------------------
    int EndOf(String symbol, int start, bool whitespaces)
    {
      while ((start < symbol.Length) && (Char.IsWhiteSpace(symbol[start]) ^ !whitespaces))
      {
        ++start;
      }

      return start;
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Removes preprocessor directive.
    /// </summary>
    /// <param name="symbol">Symbol representing the preprocessor directive</param>
    /// <returns>
    /// Preprocessor tag
    /// </returns>
    /// <remarks>
    /// input:        "#" {ws} directive ws {ws} {not-newline} {newline}
    /// valid input:  "#" {ws} directive ws {ws} {non-ws} {ws} {newline}
    /// output:       {non-ws}
    /// </remarks>
    // --------------------------------------------------------------------------------
    String RemovePreprocessorDirective(String symbol)
    {
      int start = 1;
      int end;

      // skip {ws}
      start = EndOf(symbol, start, true);
      // skip directive  
      start = EndOf(symbol, start, false);
      // skip ws {ws}
      start = EndOf(symbol, start, true);
      // search end of symbol
      end = EndOf(symbol, start, false);

      return symbol.Substring(start, end - start);
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Adds a conditional directive to the list of existing conditionals
    /// </summary>
    /// <param name="symbol">Conditional directive</param>
    // --------------------------------------------------------------------------------
    void AddConditionalDirective(String symbol)
    {
      symbol = RemovePreprocessorDirective(symbol);
      if (!_ConditionalSymbols.Contains(symbol))
      {
        _ConditionalSymbols.Add(symbol);
      }
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Removes a conditional directive from the list of existing conditionals
    /// </summary>
    /// <param name="symbol">Conditional directive</param>
    // --------------------------------------------------------------------------------
    void RemoveConditionalDirective(String symbol)
    {
      _ConditionalSymbols.Remove(RemovePreprocessorDirective(symbol));
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Checks if the specified symbol is a conditional symbol or not.
    /// </summary>
    /// <param name="symbol">Symbol to check.</param>
    /// <returns>
    /// True, if the symbol is a conditional symbol; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsConditionalSymbol(String symbol)
    {
      return _ConditionalSymbols.Contains(RemovePreprocessorDirective(symbol));
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Handles the specified conditional symbol within the #if pragma
    /// </summary>
    /// <param name="symbol">Symbol to handle as conditional</param>
    /// <remarks>
    /// Search for the correct alternative and enter. Drop everything before the 
    /// correct alternative.
    /// </remarks>
    // --------------------------------------------------------------------------------
    void IfPragma(String symbol)
    {
      if (!IsConditionalSymbol(symbol))
      {
        int state = 0;
        Token cur = scanner.Scan();

        for (; ; )
        {
          switch (cur.kind)
          {
            case _ppIf: ++state; break;
            case _ppEndif:
              if (state == 0) { return; }
              --state;
              break;
            case _ppElif:
              if (state == 0 && IsConditionalSymbol(cur.val)) { return; }
              break;
            case _ppElse:
              if (state == 0) { return; }
              break;
            case _EOF: Error("Incomplete file."); return;
            default: break;
          }
          cur = scanner.Scan();
        }
      }
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Handles the #elseif or #else pragma.
    /// </summary>
    /// <remarks>
    /// Drops everything until the end of this if, elif, else directive.
    /// </remarks>
    // --------------------------------------------------------------------------------
    void ElifOrElsePragma()
    {
      int state = 0;
      Token cur = scanner.Scan();

      for (; ; )
      {
        switch (cur.kind)
        {
          case _ppIf: ++state; break;
          case _ppEndif:
            if (state == 0) { return; }
            --state;
            break;
          default: break;
        }
        cur = scanner.Scan();
      }
    }

    #endregion

    #region Token sets

    const int maxTerminals = 160;  // set size

    static BitArray NewSet(params int[] values)
    {
      BitArray a = new BitArray(maxTerminals);
      foreach (int item in values) a[item] = true;
      return a;
    }

    /// <summary>Tokens representing unary operators</summary>
    private static BitArray unaryOp =
      NewSet(_plus, _minus, _not, _tilde, _inc, _dec, _true, _false);

    /// <summary>Tokens representing type shortcuts</summary>
    private static BitArray typeKW =
      NewSet(_char, _bool, _object, _string, _sbyte, _byte, _short,
             _ushort, _int, _uint, _long, _ulong, _float, _double, _decimal);

    /// <summary>
    /// Tokens representing unary header tokens
    /// </summary>
    private static BitArray
      unaryHead = NewSet(_plus, _minus, _not, _tilde, _times, _inc, _dec, _and);

    /// <summary>
    /// Tokens representing assignment start tokens
    /// </summary>
    private static BitArray
      assnStartOp = NewSet(_plus, _minus, _not, _tilde, _times);

    /// <summary>Tokens that can follow a cast operation</summary>
    private static BitArray
      castFollower = NewSet(_tilde, _not, _lpar, _ident,
                            /* literals */
                            _intCon, _realCon, _charCon, _stringCon,
                            /* any keyword expect as and is */
                            _abstract, _base, _bool, _break, _byte, _case, _catch,
                            _char, _checked, _class, _const, _continue, _decimal, _default,
                            _delegate, _do, _double, _else, _enum, _event, _explicit,
                            _extern, _false, _finally, _fixed, _float, _for, _foreach,
                            _goto, _if, _implicit, _in, _int, _interface, _internal,
                            _lock, _long, _namespace, _new, _null, _object, _operator,
                            _out, _override, _params, _private, _protected, _public,
                            _readonly, _ref, _return, _sbyte, _sealed, _short, _sizeof,
                            _stackalloc, _static, _string, _struct, _switch, _this, _throw,
                            _true, _try, _typeof, _uint, _ulong, _unchecked, _unsafe,
                            _ushort, _usingKW, _virtual, _void, _volatile, _while
        );

    /// <summary>Tokens that can follow argument lists</summary>
    private static BitArray
      typArgLstFol = NewSet(_lpar, _rpar, _rbrack, _colon, _scolon, _comma, _dot,
                            _question, _eq, _neq);

    /// <summary>Reserved C# keywords</summary>
    private static BitArray
      keyword = NewSet(_abstract, _as, _base, _bool, _break, _byte, _case, _catch,
                       _char, _checked, _class, _const, _continue, _decimal, _default,
                       _delegate, _do, _double, _else, _enum, _event, _explicit,
                       _extern, _false, _finally, _fixed, _float, _for, _foreach,
                       _goto, _if, _implicit, _in, _int, _interface, _internal,
                       _is, _lock, _long, _namespace, _new, _null, _object, _operator,
                       _out, _override, _params, _private, _protected, _public,
                       _readonly, _ref, _return, _sbyte, _sealed, _short, _sizeof,
                       _stackalloc, _static, _string, _struct, _switch, _this, _throw,
                       _true, _try, _typeof, _uint, _ulong, _unchecked, _unsafe,
                       _ushort, _usingKW, _virtual, _void, _volatile, _while);

    /// <summary>Assignment operators</summary>
    private static BitArray
      assgnOps = NewSet(_assgn, _plusassgn, _minusassgn, _timesassgn, _divassgn,
                     _modassgn, _andassgn, _orassgn, _xorassgn, _lshassgn) 
      /* rshassgn: ">" ">="  no whitespace allowed*/
                     ;

    #endregion

    /*---------------------------- auxiliary methods ------------------------*/

    public void Error(string s)
    {
      if (errDist >= minErrDist) errors.SemErr(la.line, la.col, s);
      errDist = 0;
    }

    // Return the n-th token after the current lookahead token
    Token Peek(int n)
    {
      scanner.ResetPeek();
      Token x = la;
      while (n > 0) { x = scanner.Peek(); n--; }
      return x;
    }

    // ident "="
    bool IsAssignment()
    {
      return la.kind == _ident && Peek(1).kind == _assgn;
    }

    /* True, if the comma is not a trailing one, *
     * like the last one in: a, b, c,            */
    bool NotFinalComma()
    {
      int peek = Peek(1).kind;
      return la.kind == _comma && peek != _rbrace && peek != _rbrack;
    }

    /* Checks whether the next sequence of tokens is a qualident *
     * and returns the qualident string                          *
     * !!! Proceeds from current peek position !!!               */
    bool IsQualident(ref Token pt, out string qualident)
    {
      qualident = "";
      if (pt.kind == _ident)
      {
        qualident = pt.val;
        pt = scanner.Peek();
        while (pt.kind == _dot)
        {
          pt = scanner.Peek();
          if (pt.kind != _ident) return false;
          qualident += "." + pt.val;
          pt = scanner.Peek();
        }
        return true;
      }
      else return false;
    }

    bool IsGeneric()
    {
      scanner.ResetPeek();
      Token pt = la;
      if (!IsTypeArgumentList(ref pt))
      {
        return false;
      }
      return typArgLstFol[pt.kind];
    }

    bool IsTypeArgumentList(ref Token pt)
    {
      if (pt.kind == _lt)
      {
        pt = scanner.Peek();
        while (true)
        {
          if (!IsType(ref pt))
          {
            return false;
          }
          if (pt.kind == _gt)
          {
            // list recognized
            pt = scanner.Peek();
            break;
          }
          else if (pt.kind == _comma)
          {
            // another argument
            pt = scanner.Peek();
          }
          else
          {
            // error in type argument list
            return false;
          }
        }
      }
      else
      {
        return false;
      }
      return true;
    }

    // Type
    bool IsType(ref Token pt)
    {
      String dummyId;

      if (typeKW[pt.kind])
      {
        pt = scanner.Peek();
      }
      else if (pt.kind == _void)
      {
        pt = scanner.Peek();
        if (pt.kind != _times)
        {
          return false;
        }
        pt = scanner.Peek();
      }
      else if (pt.kind == _ident)
      {
        pt = scanner.Peek();
        if (pt.kind == _dblcolon || pt.kind == _dot)
        {
          // either namespace alias qualifier "::" or first
          // part of the qualident
          pt = scanner.Peek();
          if (!IsQualident(ref pt, out dummyId))
          {
            return false;
          }
        }
        if (pt.kind == _lt && !IsTypeArgumentList(ref pt))
        {
          return false;
        }
      }
      else
      {
        return false;
      }
      if (pt.kind == _question)
      {
        pt = scanner.Peek();
      }
      return SkipPointerOrDims(ref pt);
    }

    // Type ident
    // (Type can be void*)
    bool IsLocalVarDecl()
    {
      Token pt = la;
      scanner.ResetPeek();
      return IsType(ref pt) && pt.kind == _ident;
    }

    // "[" ("," | "]")
    bool IsDims()
    {
      int peek = Peek(1).kind;
      return la.kind == _lbrack && (peek == _comma || peek == _rbrack);
    }

    // "*" | "[" ("," | "]")
    bool IsPointerOrDims()
    {
      return la.kind == _times || IsDims();
    }

    /* skip: { "[" { "," } "]" | "*" }             */
    /* !!! Proceeds from current peek position !!! */
    bool SkipPointerOrDims(ref Token pt)
    {
      for (; ; )
      {
        if (pt.kind == _lbrack)
        {
          do pt = scanner.Peek();
          while (pt.kind == _comma);
          if (pt.kind != _rbrack) return false;
        }
        else if (pt.kind != _times) break;
        pt = scanner.Peek();
      }
      return true;
    }

    // Is attribute target specifier
    // (ident | keyword) ":"
    bool IsAttrTargSpec()
    {
      return (la.kind == _ident || keyword[la.kind]) && Peek(1).kind == _colon;
    }

    // ident ("," | "=" | ";")
    bool IsFieldDecl()
    {
      int peek = Peek(1).kind;
      return la.kind == _ident &&
             (peek == _comma || peek == _assgn || peek == _scolon);
    }

    bool IsTypeCast()
    {
      if (la.kind != _lpar) { return false; }
      if (IsSimpleTypeCast()) { return true; }
      return GuessTypeCast();
    }

    // "(" typeKW ")"
    bool IsSimpleTypeCast()
    {
      // assert: la.kind == _lpar
      scanner.ResetPeek();
      Token pt1 = scanner.Peek();
      Token pt2 = scanner.Peek();
      return typeKW[pt1.kind] &&
              (pt2.kind == _rpar ||
              (pt2.kind == _question && scanner.Peek().kind == _rpar));
    }

    // "(" Type ")" castFollower
    bool GuessTypeCast()
    {
      // assert: la.kind == _lpar
      scanner.ResetPeek();
      Token pt = scanner.Peek();
      if (!IsType(ref pt))
      {
        return false;
      }
      if (pt.kind != _rpar)
      {
        return false;
      }
      pt = scanner.Peek();
      return castFollower[pt.kind];
    }

    // "[" "assembly"
    bool IsGlobalAttrTarget()
    {
      Token pt = Peek(1);
      return la.kind == _lbrack && pt.kind == _ident && ("assembly".Equals(pt.val) || "module".Equals(pt.val));
    }

    // "extern"
    bool IsExternAliasDirective()
    {
      return la.kind == _extern;
    }

    // true: anyToken"<"
    // no whitespace between the token and the "<" allowed
    // anything else will return false.
    bool IsLtNoWs()
    {
      return (la.kind == _lt) && ((t.pos + t.val.Length) == la.pos);
    }

    bool IsNoSwitchLabelOrRBrace()
    {
      return (la.kind != _case && la.kind != _default && la.kind != _rbrace) ||
             (la.kind == _default && Peek(1).kind != _colon);
    }

    bool IsShift()
    {
      Token pt = Peek(1);
      return (la.kind == _ltlt) ||
             (la.kind == _gt &&
               pt.kind == _gt &&
               (la.pos + la.val.Length == pt.pos)
             );
    }

    // true: TypeArgumentList followed by anything but "("
    bool IsPartOfMemberName()
    {
      scanner.ResetPeek();
      Token pt = la;
      if (!IsTypeArgumentList(ref pt))
      {
        return false;
      }
      return pt.kind != _lpar;
    }

/*------------------------------------------------------------------------*
 *----- SCANNER DESCRIPTION ----------------------------------------------*
 *------------------------------------------------------------------------*/

CHARACTERS

  tab                = '\u0009'. /*  9 = tabulator */
  eol                = '\u000a'. /* 10 = line feed */
  cr                 = '\u000d'. /* 13 = carriage return */
  newLine            = cr + eol. /* Line separator character (U+2028) + Paragraph separator character (U+2029) */

  startLetter        = 'A' .. 'Z' + 'a' .. 'z' + '_' + '\u00aa' + '\u00b5' + '\u00ba' + '\u00c0' .. '\u00d6' + '\u00d8' .. '\u00f6' + '\u00f8' .. '\u00ff'.
  partLetter         = '0' .. '9' + 'A' .. 'Z' + 'a' .. 'z' + '_' + '\u00a0' + '\u00aa' + '\u00b5' + '\u00ba' + '\u00c0' .. '\u00d6' + '\u00d8' .. '\u00f6' + '\u00f8' .. '\u00ff'.

  digit              = "0123456789".  
  hexDigit           = digit + "ABCDEFabcdef".
  notDigit           = ANY - digit.

  char               = ANY - "'" - '\\' - newLine.
  verbatimStringChar = ANY - '"'.
  regularStringChar  = ANY - '"' - '\\' - newLine.
  notNewLine         = ANY - newLine .
  ws                 = " " + tab + '\u000b' + '\u000c'. /* Any character with Unicode class Zs */

TOKENS

  ident =
    ['@']
    ( startLetter
    | '\\'
      ( 'u' hexDigit hexDigit hexDigit hexDigit
      | 'U' hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
      )
    )
    { partLetter
    | '\\'
      ( 'u' hexDigit hexDigit hexDigit hexDigit
      | 'U' hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
      )
    }.
  /*--------------------------------------------------------------------------------*/
  intCon =
    ( digit {digit} | digit {digit} CONTEXT ("." notDigit)
    | ("0x" | "0X") hexDigit {hexDigit}
    )
    ["U" | "u" | "L" | "l" | "UL" | "Ul" | "uL" | "ul" | "LU" | "Lu" | "lU" | "lu"].
  /*--------------------------------------------------------------------------------*/
  realCon =
    "." digit {digit} 
    [("e" | "E") ["+" | "-"] digit {digit}] 
    ["F" | "f" | "D" | "d" | "M" | "m"]
  | digit {digit} 
    ( "." digit {digit} 
      [("e" | "E" ) ["+" | "-"] digit {digit} ] 
      ["F" | "f" | "D" | "d" | "M" | "m"]
    | ("e" | "E") ["+" | "-"] digit {digit}
      ["F" | "f" | "D" | "d" | "M" | "m"]
    | "F" | "f" | "D" | "d" | "M" | "m"
    ).
  /*--------------------------------------------------------------------------------*/
  charCon =
    "'" ( char
        | "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v"
        | "\\x" hexDigit [hexDigit] [hexDigit] [hexDigit]
        | "\\u" hexDigit hexDigit hexDigit hexDigit
        | "\\U" hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
        ) 
    "'".
  /*--------------------------------------------------------------------------------*/
  stringCon =
    "\""  { regularStringChar
          | "\\\'" | "\\\"" | "\\\\" | "\\0" | "\\a" | "\\b" | "\\f" | "\\n" | "\\r" | "\\t" | "\\v"
          | "\\x" hexDigit [hexDigit] [hexDigit] [hexDigit]
          | "\\u" hexDigit hexDigit hexDigit hexDigit
          | "\\U" hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit hexDigit
          } 
    "\""
  | "@\"" {verbatimStringChar | "\"\""} "\"".


  /*----- keyword names needed in LL(1) resolvers -----*/
  
  abstract   = "abstract".
  as         = "as".
  base       = "base".
  bool       = "bool".
  break      = "break".
  byte       = "byte".
  case       = "case".
  catch      = "catch".
  char       = "char".
  checked    = "checked".
  class      = "class".
  const      = "const".
  continue   = "continue".
  decimal    = "decimal".
  default    = "default".
  delegate   = "delegate".
  do         = "do".
  double     = "double".
  else       = "else".
  enum       = "enum".
  event      = "event".
  explicit   = "explicit".
  extern     = "extern".
  false      = "false".
  finally    = "finally".
  fixed      = "fixed".
  float      = "float".
  for        = "for".
  foreach    = "foreach".
  goto       = "goto".
  if         = "if".
  implicit   = "implicit".
  in         = "in".
  int        = "int".
  interface  = "interface".
  internal   = "internal".
  is         = "is".
  lock       = "lock".
  long       = "long".
  namespace  = "namespace".
  new        = "new".
  null       = "null".
  object     = "object".
  operator   = "operator".
  out        = "out".
  override   = "override".
  params     = "params".
  private    = "private".
  protected  = "protected".
  public     = "public".
  readonly   = "readonly".
  ref        = "ref".
  return     = "return".
  sbyte      = "sbyte".
  sealed     = "sealed".
  short      = "short".
  sizeof     = "sizeof".
  stackalloc = "stackalloc".
  static     = "static".
  string     = "string".
  struct     = "struct".
  switch     = "switch".
  this       = "this".
  throw      = "throw".
  true       = "true".
  try        = "try".
  typeof     = "typeof".
  uint       = "uint".
  ulong      = "ulong".
  unchecked  = "unchecked".
  unsafe     = "unsafe".
  ushort     = "ushort".
  usingKW    = "using".
  virtual    = "virtual".
  void       = "void".
  volatile   = "volatile".
  while      = "while".
  

  /*----- operators and special characters needed in LL(1) resolvers --------------*/
  and        = "&".
  andassgn   = "&=".
  assgn      = "=".
  colon      = ":".
  comma      = ",".
  dec        = "--".
  divassgn   = "/=".
  dot        = ".".
  dblcolon   = "::".
  eq         = "==".
  gt         = ">".
  gteq       = ">=".
  inc        = "++".
  lbrace     = "{".
  lbrack     = "[".
  lpar       = "(".
  lshassgn   = "<<=".
  lt         = "<".
  ltlt       = "<<".
  minus      = "-".
  minusassgn = "-=".
  modassgn   = "%=".
  neq        = "!=".
  not        = "!".
  orassgn    = "|=".
  plus       = "+".
  plusassgn  = "+=".
  question   = "?".
  rbrace     = "}".
  rbrack     = "]".
  rpar       = ")".
  scolon     = ";".
  tilde      = "~".
  times      = "*".
  timesassgn = "*=".
  xorassgn   = "^=".


PRAGMAS

  /* Preprocessor directives.                                               *
   * The exact parsing of their syntax is left for later processing         */

  ppDefine  = "#" {ws} "define" {notNewLine} newLine. (. AddConditionalDirective(la.val); .)
  ppUndef   = "#" {ws} "undef" {notNewLine} newLine.  (. RemoveConditionalDirective(la.val); .)
  ppIf      = "#" {ws} "if" {notNewLine} newLine.     (. IfPragma(la.val); .)
  ppElif    = "#" {ws} "elif" {notNewLine} newLine.   (. ElifOrElsePragma(); .)
  ppElse    = "#" {ws} "else" {notNewLine} newLine.   (. ElifOrElsePragma(); .)
  ppEndif   = "#" {ws} "endif" {notNewLine} newLine.
  ppLine    = "#" {ws} "line" {notNewLine} newLine.
  ppError   = "#" {ws} "error" {notNewLine} newLine.
  ppWarning = "#" {ws} "warning" {notNewLine} newLine.
  ppRegion  = "#" {ws} "region" {notNewLine} newLine.
  ppEndReg  = "#" {ws} "endregion" {notNewLine} newLine.


// ****************************************************************************
// If you would like to use C# comments in your grammar, use
// pragmas for that purpose and remove the COMMENTS.
//
// The pragma for the block comment looks like this:
//     cBlockCom = "/*" { "/" | blockComCh | "*"{"*"} blockComCh } "*"{"*"}"/".
// where blockComCh is a character set (CHARACTERS section) defined as:
//     blockComCh = ANY - '*' - '/'.
//
// The line comment is simpler:
//     cLineCom = "//" { notNewLine } newLine.
// where newLine and notNewLine are character sets (already defined in the
// CHARACTERS section).
// ****************************************************************************

COMMENTS FROM "/*" TO "*/"
COMMENTS FROM "//" TO eol

IGNORE eol + cr + tab


PRODUCTIONS

// ====================================================================================
// This is the definition of C# 2.0 grammar. The definition contains the grammar syntax 
// definition with the corresponding semantic actions.
// This is main entry point of the grammar parser.
// ====================================================================================
CS2
=                                                               
  {IF (IsExternAliasDirective()) ExternAliasDirective<null>}
  {UsingDirective<null>}
  {IF (IsGlobalAttrTarget()) GlobalAttributes}
  {NamespaceMemberDeclaration<null, _File>}
.

// ------------------------------------------------------------------------------------
// "extern alias" directive that is used in conjunction with a file or with a namespace
// +parent: Parent namespace of the "extern alias" directive. If this parameter is
//   null, the directive belongs to the file and not to the specified namespace.
// ------------------------------------------------------------------------------------
ExternAliasDirective<NamespaceFragment parent>
=
  "extern"   (. Token token = t; .)
  ident      (. 
                if (t.val != "alias") 
                  Error("CS1003", t, "Syntax error, 'alias' expected"); 
             .)
  ident      (. 
               ExternalAlias externAlias = new ExternalAlias(token, t.val);
               if (parent == null) _File.AddExternAlias(externAlias); 
               else parent.AddExternAlias(externAlias); 
             .)
  ";"
.

// ------------------------------------------------------------------------------------
// "using" directive that is used in conjunction with a files or a namespace.
// +parent: Parent namespace of the "using" directive. If this parameter is null, 
//   the directive belongs to the file and not to the specified namespace.
// ------------------------------------------------------------------------------------
UsingDirective<NamespaceFragment parent>
=                                                               
  "using"                  (. 
                              Token token = t;
                              string name = String.Empty; 
                              TypeReference typeUsed = null;
                           .)
  [ IF (IsAssignment()) 
    ident                  (. name = t.val; .)
    "=" ]
  TypeName<out typeUsed> 
  ";"                      (. 
                              UsingClause uc = new UsingClause(token, name, typeUsed);
                              if (parent == null) _File.AddUsingClause(uc);
                              else parent.AddUsingClause(uc); 
                           .)
.

// ------------------------------------------------------------------------------------
// Global attributes belonging to a file.
// This element accepts only attributes with "assembly" or "module" scope.
// ------------------------------------------------------------------------------------
GlobalAttributes
=
  "[" ident                    (.
                                  // We accept module because csc does (even if it is against 
                                  // the specification).
                                  if (!"assembly".Equals(t.val) && !"module".Equals(t.val)) 
                                    Error("global attribute target specifier \"assembly\" or \"module\" expected");
                                  string scope = t.val;
                                  AttributeDeclaration attr;
                               .) 
  ":" Attribute<out attr>      (. 
                                  attr.Scope = scope; 
                                  _File.GlobalAttributes.Add(attr);
                               .)
  { IF (NotFinalComma()) "," 
    Attribute<out attr>        (. 
                                  attr.Scope = scope; 
                                  _File.GlobalAttributes.Add(attr);
                               .)
        } [ "," ]
  "]"
.

// ------------------------------------------------------------------------------------
// Declaration of a namespace member.
// A member of a namespace can be a subnamespace or a type.
// +parent: Parent namespace of the type declaration. If this parameter is null, 
//   the type belongs to the file and not to the specified namespace.
// +file: file that defines the namespace.
// ------------------------------------------------------------------------------------
NamespaceMemberDeclaration<NamespaceFragment parent, ProjectFile file>  
=
  "namespace"    (. Token startToken = t; .)
  ident          (. StringBuilder sb = new StringBuilder(t.val); .)
  { 
    "." ident    (. sb.Append("."); sb.Append(t.val); .)
  }              (. NamespaceFragment ns = new NamespaceFragment(startToken, sb.ToString(), parent, file); .)
  "{" 
      { IF (IsExternAliasDirective()) ExternAliasDirective<ns> } 
      { UsingDirective<ns> } 
      { NamespaceMemberDeclaration<ns, _File> } 
  "}" [ ";" ]
  |                                              (. 
                                                    Modifiers m = new Modifiers(this); 
                                                    TypeDeclaration td;
                                                    AttributeCollection attrs = new AttributeCollection();
                                                 .)  
      { Attributes<attrs> } 
      ModifierList<m> 
      TypeDeclaration<attrs, m, out td>          (.
                                                    if (td != null)
                                                    {
                                                      td.AssignAttributes(attrs);
                                                      if (parent == null) 
                                                        _File.AddTypeDeclaration(td);
                                                      else 
                                                        parent.AddTypeDeclaration(td);
                                                    }
                                                 .)
.

// ------------------------------------------------------------------------------------
// Type declaration within a file or a namespace.
// +modifiers: Set of modifiers belongign to the type.
// +td: resulting type declaration.
// ------------------------------------------------------------------------------------
TypeDeclaration<AttributeCollection attrs, Modifiers m, out TypeDeclaration td>            
=                                                    (. td = null; .)
  (                                                             
                                                     (. bool isPartial = false; .)
    [ 
      "partial"                                      (. isPartial = true; .)
    ]
    ( 
      ClassDeclaration<m, isPartial, out td> |                                                           
      StructDeclaration<m, isPartial, out td> |                                                           
      InterfaceDeclaration<m, isPartial, out td>                                                           
    )                                                          
    | EnumDeclaration<m, out td> 
    | DelegateDeclaration<m, out td>
  )                                                  (. 
                                                        if (td != null)
                                                        {
                                                          td.SetModifiers(m.Value); 
                                                          td.AssignAttributes(attrs);
                                                        }
                                                     .)                               
.

// ------------------------------------------------------------------------------------
// Class declaration in the file or within a namespace.
// +modifiers: Set of modifiers belonging to the type.
// +partial: flag indicating if this is a partial type definition or not.
// +td: resulting type declaration.
// ------------------------------------------------------------------------------------
ClassDeclaration<Modifiers m, bool isPartial, out TypeDeclaration td>
=
  "class"                                            (. 
                                                        m.Check(Modifier.classes); 
                                                        ClassDeclaration cd = new ClassDeclaration(t, this);
                                                        cd.IsPartial = isPartial;
                                                        td = cd;
                                                     .)
  ident                                              (. cd.Name = t.val; .)
  [ TypeParameterList<cd> ] 
  [ ClassBase<cd> ]
  {                                                  (. TypeParameterConstraint constraint; .)
    TypeParameterConstraintsClause<out constraint>   (. td.AddTypeParameterConstraint(constraint); .)
  } ClassBody<td> 
  [ ";" ]                                                       
.

// ------------------------------------------------------------------------------------
// Base type declaration of a class.
// +cd: Class declaration that has the base types defined here.
// ------------------------------------------------------------------------------------
ClassBase<ClassDeclaration cd>                                  
=
  ":"                        (. TypeReference typeRef; .)
  ClassType<out typeRef>     (. cd.BaseTypes.Add(typeRef); .)
  
  { ","                                                         
    TypeName<out typeRef>    (. cd.BaseTypes.Add(typeRef); .)
  }
.

// ------------------------------------------------------------------------------------
// Body declaration of a class.
// +td: Class declaration that has the body defined here.
// ------------------------------------------------------------------------------------
ClassBody<TypeDeclaration td>
=                                     (. AttributeCollection attrs = new AttributeCollection(); .)
  "{" { { Attributes<attrs> }         (. Modifiers m = new Modifiers(this); .)                          
        ModifierList<m>
        ClassMemberDeclaration<attrs, m, td>
      }
  "}"
.

// ------------------------------------------------------------------------------------
// Structure declaration within a file a namespace.
// +modifiers: Set of modifiers belonging to the type.
// +partial: flag indicating if this is a partial type definition or not.
// +td: resulting type declaration.
// ------------------------------------------------------------------------------------
StructDeclaration<Modifiers m, bool isPartial, out TypeDeclaration td>
=
  "struct"                                         (. 
                                                      m.Check(Modifier.nonClassTypes); 
                                                      StructDeclaration sd = new StructDeclaration(t, this);
                                                      td = sd;
                                                      sd.IsPartial = isPartial;
                                                      TypeReference typeRef;
                                                   .)
  ident                                            (. sd.Name = t.val; .)
  [ TypeParameterList<sd> ]
  [ ":"                                                     
  TypeName<out typeRef>                            (. sd.BaseTypes.Add(typeRef); .)
  { "," 
    TypeName<out typeRef>                          (. sd.BaseTypes.Add(typeRef); .)
  } ]
  {                                                (. TypeParameterConstraint constraint; .)
    TypeParameterConstraintsClause<out constraint> (. td.AddTypeParameterConstraint(constraint); .)
  } StructBody<td>
  [ ";" ]                                                       
.

// ------------------------------------------------------------------------------------
// Body declaration of a structure.
// +td: Structure declaration that has the body defined here.
// ------------------------------------------------------------------------------------
StructBody<TypeDeclaration td>
=                                    (. AttributeCollection attrs = new AttributeCollection(); .)
  "{" { { Attributes<attrs> }        (. Modifiers m = new Modifiers(this); .)                             
        ModifierList<m>
        StructMemberDeclaration<attrs, m, td>
      }
  "}"   
.

// ------------------------------------------------------------------------------------
// Enumerated type declaration within a file or a namespace
// ------------------------------------------------------------------------------------
EnumDeclaration<Modifiers m, out TypeDeclaration td>
=
  "enum"             (. 
                        m.Check(Modifier.nonClassTypes); 
                        EnumDeclaration ed = new EnumDeclaration(t, this);
                        td = ed;
                     .)
  ident              (. ed.Name = t.val; .)
  [ ":" 
    IntegralType     (. 
                        TypeReference tr = new TypeReference(t);
                        tr.Name = t.val; 
                        ed.BaseTypes.Add(tr);
                     .)
  ] 
  EnumBody<ed> 
  [ ";" ]                                                       
.

// ------------------------------------------------------------------------------------
// Body declaration of an enumerated type.
// +ed: Enumeration declaration that has the body defined here.
// ------------------------------------------------------------------------------------
EnumBody<EnumDeclaration ed>
=
  "{" [ 
    EnumMemberDeclaration<ed> 
    {IF (NotFinalComma())  "," EnumMemberDeclaration<ed>} 
    [ "," ] ] 
  "}"
.

// ------------------------------------------------------------------------------------
// Enumeration value declaration.
// +ed: Enumeration declaration that has the member values defined here.
// ------------------------------------------------------------------------------------
EnumMemberDeclaration<EnumDeclaration ed>  
=                            (. AttributeCollection attrs = new AttributeCollection(); .)
  { Attributes<attrs> } 
  ident                      (. 
                                 EnumValueDeclaration ev = new EnumValueDeclaration(t); 
                                 ev.Name = t.val;
                                 Expression expr;
                             .)
  [ 
    "=" Expression<out expr> (. ev.ValueExpression = expr; .)
  ]     
                             (.
                                ev.AssignAttributes(attrs);
                                ed.Values.Add(ev);
                             .)
.

// ------------------------------------------------------------------------------------
// Delegate type declaration within a file a namespace.
// +modifiers: Set of modifiers belonging to the type.
// +td: resulting type declaration.
// ------------------------------------------------------------------------------------
DelegateDeclaration<Modifiers m, out TypeDeclaration td>
=
  "delegate"                                       (. 
                                                      m.Check(Modifier.nonClassTypes); 
                                                      DelegateDeclaration dd = new DelegateDeclaration(t, this);
                                                      td = dd;
                                                      dd.SetModifiers(m.Value);
                                                      TypeReference returnType;
                                                   .)
  Type<out returnType, true>                       (. dd.ReturnType = returnType; .)
  ident                                            (. dd.Name = t.val; .)
  [ TypeParameterList<dd> ]
  "(" [ FormalParameterList<dd.FormalParameters> ] ")"
  {                                                (. TypeParameterConstraint constraint; .)
    TypeParameterConstraintsClause<out constraint> (. td.AddTypeParameterConstraint(constraint); .)
  } 
  ";"                                                         
.

// ------------------------------------------------------------------------------------
// Declaration of a class member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
ClassMemberDeclaration<AttributeCollection attrs, Modifiers m, TypeDeclaration td>
=
  StructMemberDeclaration<attrs, m, td>
  | "~" ident   (. 
                   DestructorDeclaration dd = new DestructorDeclaration(t);
                   dd.Name = t.val;
                   dd.SetModifiers(m.Value);
                   dd.AssignAttributes(attrs);
                .)
  "(" ")" 
  ( 
  Block<dd> | ";" 
  )             (. td.Members.Add(dd); .)
.

// ------------------------------------------------------------------------------------
// Declaration of a structure member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
StructMemberDeclaration<AttributeCollection attrs, Modifiers m, TypeDeclaration td>        
                                              (. TypeReference typeRef; .)
=                                             
  (                                                                          
    ConstMemberDeclaration<attrs, m, td> 
    | EventDeclaration<attrs, m, td> 
    | IF (la.kind == _ident && Peek(1).kind == _lpar)                         
        ConstructorDeclaration<attrs, m, td> 
    | Type<out typeRef, true>
    ( 
      OperatorDeclaration<attrs, m, typeRef, td>
      | // --- Field declaration
        IF (IsFieldDecl()) FieldMemberDeclarators<attrs, m, td, typeRef, false, Modifier.fields> ";"
      |                                          (. TypeReference memberRef; .)
        MemberName<out memberRef>
        ( 
          PropertyDeclaration<attrs, m, typeRef, memberRef, td>
          | "." IndexerDeclaration<attrs, m, typeRef, memberRef, td>
          | MethodDeclaration<attrs, m, typeRef, memberRef, td, true>
        )
      | IndexerDeclaration<attrs, m, typeRef, null, td>
    )
  | CastOperatorDeclaration<attrs, m, td>
  |                                              (. TypeDeclaration nestedType; .)
    TypeDeclaration<attrs, m, out nestedType>    (. nestedType.DeclaringType = td; .)
  )
.

// ------------------------------------------------------------------------------------
// Declaration of a "const" member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
ConstMemberDeclaration<AttributeCollection attrs, Modifiers m, TypeDeclaration td>
=                                    (. m.Check(Modifier.constants); .)
  "const"                            (. TypeReference typeRef; .)
  Type<out typeRef, false>          
  SingleConstMember<attrs, m, td, typeRef>
  { "," SingleConstMember<attrs, m, td, typeRef> } ";"
.

// ------------------------------------------------------------------------------------
// Declaration of a single "const" member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// +typeRef: Type of the constant.
// ------------------------------------------------------------------------------------
SingleConstMember<AttributeCollection attrs, Modifiers m, TypeDeclaration td, 
  TypeReference typeRef>
=                            (.  .)
  ident                      (. 
                                ConstDeclaration cd = new ConstDeclaration(t); 
                                cd.AssignAttributes(attrs);
                                cd.SetModifiers(m.Value);
                                cd.ResultingType = typeRef;
                                cd.Name = t.val;
                             .)
  "="                        (. td.Members.Add(cd); .)
                             (. Expression expr; .)
  Expression<out expr>       (. cd.Expression = expr; .)
.

// ------------------------------------------------------------------------------------
// Declaration of a event member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
EventDeclaration<AttributeCollection attrs, Modifiers m, TypeDeclaration td>
= (. TypeReference typeRef; .)
  "event" Type<out typeRef, false>
  ( IF (IsFieldDecl()) 
    FieldMemberDeclarators<attrs, m, td, typeRef, true, Modifier.propEvntMeths> ";"
  |                              (. TypeReference memberRef; .)
    TypeName<out memberRef> 
    "{"                          (. EventPropertyDeclaration ep = new EventPropertyDeclaration(t);  .)   
                                 (. ep.ResultingType = typeRef; .) 
                                 (. ep.ExplicitName = memberRef; .)
                                 (. td.Members.Add(ep); .)
    EventAccessorDeclarations<ep>
    "}"
  )
.

// ------------------------------------------------------------------------------------
// Declaration of a constructor member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
ConstructorDeclaration<AttributeCollection attrs, Modifiers m, TypeDeclaration td>
= (. m.Check(Modifier.constructors | Modifier.staticConstr); .)
    ident                   (. 
                               ConstructorDeclaration cd = new ConstructorDeclaration(t);
                               cd.Name = t.val;
                               cd.SetModifiers(m.Value);
                               cd.AssignAttributes(attrs);
                            .)
    "(" 
    [                                    
      FormalParameterList<cd.FormalParameters>
    ] 
    ")" 
    [                                        
      ":" ( "base"          (. cd.HasBase = true; .)
      | "this"              (. cd.HasThis = true; .)
      ) "("
    [ Argument<null> { "," Argument<null> } ] ")"
    ] ( Block<cd> | ";" )
                            (. td.Members.Add(cd); .)
.

// ------------------------------------------------------------------------------------
// Declaration of a property member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +typeRef: type of the property
// +memberRef: member name reference.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
PropertyDeclaration<AttributeCollection attrs, Modifiers m, TypeReference typeRef, 
  TypeReference memberRef, TypeDeclaration td>
=                 (. 
                     m.Check(Modifier.propEvntMeths);
                     if (typeRef.Kind == TypeKind.@void) { Error("property type must not be void"); }
                     PropertyDeclaration pd = new PropertyDeclaration(t);
                     pd.SetModifiers(m.Value);
                     pd.AssignAttributes(attrs);
                     pd.ExplicitName = memberRef;
                     pd.ResultingType = typeRef;
                  .)
  "{" 
     AccessorDeclarations<pd> 
  "}" (. td.Members.Add(pd); .)
.

// ------------------------------------------------------------------------------------
// Declaration of an indexer member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +typeRef: type of the property
// +memberRef: member name reference.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
IndexerDeclaration<AttributeCollection attrs, Modifiers m, TypeReference typeRef, 
  TypeReference memberRef, TypeDeclaration td>
=                 (. 
                     m.Check(Modifier.indexers);
                     if (typeRef.Kind == TypeKind.@void) { Error("indexer type must not be void"); }
                     IndexerDeclaration ind = new IndexerDeclaration(t);
                     ind.SetModifiers(m.Value);
                     ind.AssignAttributes(attrs);
                     if (memberRef != null) 
                     {
                       ind.ExplicitName = memberRef;
                       ind.Name = memberRef.FullName;
                     }
                     else
                     {
                       ind.Name = "";
                     }
                     ind.ResultingType = typeRef;
                  .)
  "this" "[" FormalParameterList<ind.FormalParameters> "]" 
  "{" 
      AccessorDeclarations<ind> 
  "}"             (. td.Members.Add(ind); .)
.

// ------------------------------------------------------------------------------------
// Declaration of a method member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +typeRef: type of the property
// +memberRef: member name reference.
// +td: Type declaration the member belongs to.
// +allowBody: indicates if method body is allowd or not.
// ------------------------------------------------------------------------------------
MethodDeclaration<AttributeCollection attrs, Modifiers m, TypeReference typeRef, 
  TypeReference memberRef, TypeDeclaration td, bool allowBody>
=                                                   (. 
                                                       m.Check(Modifier.propEvntMeths);
                                                       MethodDeclaration md = new MethodDeclaration(t);
                                                       md.SetModifiers(m.Value);
                                                       md.AssignAttributes(attrs);
                                                       md.ExplicitName = memberRef;
                                                       md.ResultingType = typeRef;
                                                    .)
  [ TypeParameterList<md> ]
  "(" [ 
    FormalParameterList<md.FormalParameters>
  ] ")"
  {                                                 (. TypeParameterConstraint constraint; .)
    TypeParameterConstraintsClause<out constraint>  (. md.AddTypeParameterConstraint(constraint); .)
  } 
  ( 
    Block<md>                                       (. 
                                                       if (!allowBody || m.Has(Modifier.@abstract)) { Error("Body declaration is not allowed here!"); } 
                                                       md.HasBody = true;
                                                    .)
    | ";"                                           (. md.HasBody = false; .)
  )                                                 (. td.Members.Add(md); .)
.

// ------------------------------------------------------------------------------------
// Declaration of a cast operator.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
CastOperatorDeclaration<AttributeCollection attrs, Modifiers m, TypeDeclaration td>
=                                       (. 
                                           m.Check(Modifier.operators);
                                           m.CheckMust(Modifier.operatorsMust);
                                           CastOperatorDeclaration cod = new CastOperatorDeclaration(t);
                                           cod.SetModifiers(m.Value);
                                           cod.AssignAttributes(attrs);
                                           TypeReference typeRef;
                                        .)
    ( 
      "implicit"                        
      | "explicit"                      (. cod.IsExplicit = true; .)
    ) "operator"                        
    Type<out typeRef, false>            (. 
                                           if (typeRef.Kind == TypeKind.@void) { Error("cast type must not be void"); } 
                                           cod.ResultingType = typeRef;
                                           cod.Name = typeRef.RightmostName;
                                        .)
    "("                                 (. FormalParameter fp = new FormalParameter(t);.)
      Type<out typeRef, false>          (. fp.Type = typeRef; .)
      ident                             (. fp.Name = t.val; .)
    ")"                                 (. cod.FormalParameters.Add(fp); .)
    ( Block<cod> | ";" )                (. td.Members.Add(cod); .)
.

// ------------------------------------------------------------------------------------
// Declaration of an operator overload member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +typeRef: resulting type reference.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
OperatorDeclaration<AttributeCollection attrs, Modifiers m, TypeReference typeRef, 
  TypeDeclaration td>
=                                  (. 
                                      m.Check(Modifier.operators);
                                      m.CheckMust(Modifier.operatorsMust);
                                      if (typeRef.Kind == TypeKind.@void) { Error("operator not allowed on void"); } 
                                      OperatorDeclaration od = new OperatorDeclaration(t);
                                      od.SetModifiers(m.Value);
                                      od.AssignAttributes(attrs);
                                      od.ResultingType = typeRef;
                                      Operator op;
                                   .)
  "operator" 
  OverloadableOp<out op>           (. od.Operator = op; .)
  "("                              (. 
                                      od.Name = op.ToString(); 
                                      FormalParameter fp = new FormalParameter(t);
                                      TypeReference parType;
                                         .)
  Type<out parType, false>         (. fp.Type = parType; .)
  ident                            (. 
                                      fp.Name = t.val; 
                                      od.FormalParameters.Add(fp);
                                   .)
  ( ","                            (. fp = new FormalParameter(t); .)
    Type<out parType, false>       (. fp.Type = parType; .)
    ident                          (. 
                                      fp.Name = t.val; 
                                      od.FormalParameters.Add(fp);
                                   .)                                         
                                   (. if ((op & Operator.binary) == 0) Error("too many operands for unary operator"); .)
  |                                (. if ((op & Operator.unary) == 0) Error("too few operands for binary operator"); .)
  ) ")"
  ( Block<od> | ";" )              (. td.Members.Add(od); .)
.

// ------------------------------------------------------------------------------------
// Declaration of an interface.
// +modifiers: Set of modifiers belonging to the member.
// +isPartial: indicates partial modifier.
// +td: Type declaration the member belongs to.
// ------------------------------------------------------------------------------------
InterfaceDeclaration<Modifiers m, bool isPartial, out TypeDeclaration td>
=
  "interface"       (. 
                       m.Check(Modifier.nonClassTypes); 
                       InterfaceDeclaration ifd = new InterfaceDeclaration(t, this);
                       td = ifd;
                       ifd.IsPartial = isPartial;
                    .)
  ident                                               (. ifd.Name = t.val; .)
  [ TypeParameterList<ifd> ]
  [ InterfaceBase<ifd> ]
  {                                                   (. TypeParameterConstraint constraint; .)
    TypeParameterConstraintsClause<out constraint>    (. td.AddTypeParameterConstraint(constraint); .)
  }
  "{" { InterfaceMemberDeclaration<ifd> } "}" 
  [ ";" ]                                                       
.

// ------------------------------------------------------------------------------------
// Base type declaration of an interface.
// +ifd: Interface declaration that has the base types defined here.
// ------------------------------------------------------------------------------------
InterfaceBase<InterfaceDeclaration ifd> 
=
  ":"                        (. TypeReference typeRef; .)
  TypeName<out typeRef>      (. ifd.BaseTypes.Add(typeRef); .)
  
  { ","                                                         
    TypeName<out typeRef>    (. ifd.BaseTypes.Add(typeRef); .)
  }
.

// ------------------------------------------------------------------------------------
// Declaration of an interface member.
// +idf: declaration representing the interface type.
// ------------------------------------------------------------------------------------
InterfaceMemberDeclaration<InterfaceDeclaration ifd>
                               (. 
                                  Modifiers m = new Modifiers(this);
                                  TypeReference typeRef;
                                  AttributeCollection attrs = new AttributeCollection();
                               .)
=                              (. FormalParameterCollection pars = new FormalParameterCollection(); .)
  { Attributes<attrs> } 
  [ "new" ]
  ( Type<out typeRef, true>
    (                          
      ident                   (.
                                 TypeReference memberRef = new TypeReference(t); 
                                 memberRef.Name = t.val;
                              .)
      ( 
        MethodDeclaration<attrs, m, typeRef, memberRef, ifd, false>        
      | // --- Interface property
        (. PropertyDeclaration prop = new PropertyDeclaration(t); .)
        (. ifd.Members.Add(prop); .)
        (. prop.ResultingType = typeRef; .)
        (. prop.ExplicitName = memberRef; .)
        (. prop.AssignAttributes(attrs); .)
        (. prop.SetModifiers(m.Value); .)
        "{" InterfaceAccessors<prop> "}"
      )
    | (. 
         m.Check(Modifier.indexers);
         if (typeRef.Kind == TypeKind.@void) { Error("indexer type must not be void"); }
         IndexerDeclaration ind = new IndexerDeclaration(t);
         ind.SetModifiers(m.Value);
         ind.AssignAttributes(attrs);
         ind.Name = "";
         ind.ResultingType = typeRef;
      .)
      "this" "[" FormalParameterList<ind.FormalParameters> "]" 
      "{" InterfaceAccessors<ind> "}"
    )
  | InterfaceEventDeclaration<attrs, m, ifd>
  ) 
.

// ------------------------------------------------------------------------------------
// Declaration of an interface event member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +idf: declaration representing the interface type.
// ------------------------------------------------------------------------------------
InterfaceEventDeclaration<AttributeCollection attrs, Modifiers m, InterfaceDeclaration ifd>
          (. TypeReference typeRef; .)
=
  "event" Type<out typeRef, false> 
  ident (. 
           FieldDeclaration fd = new FieldDeclaration(t); 
           fd.SetModifiers(m.Value);
           fd.AssignAttributes(attrs);
           fd.ResultingType = typeRef;
           fd.Name = t.val;
           fd.IsEvent = true;
        .)
  ";"   (. ifd.Members.Add(fd); .)
.

// ------------------------------------------------------------------------------------
// Declares a local variable within a block.
// +block: Block the variable is declared within.
// ------------------------------------------------------------------------------------
LocalVariableDeclaration<IBlockOwner block> (. TypeReference typeRef; .)
=
  Type<out typeRef, false> 
  LocalVariableDeclarator<block, typeRef>
  { "," LocalVariableDeclarator<block, typeRef> }
.

// ------------------------------------------------------------------------------------
// Declares a local variable within a block with the specified type.
// +block: Block the variable is declared within.
// +ypeRef: Type of the variable to declare.
// ------------------------------------------------------------------------------------
LocalVariableDeclarator<IBlockOwner block, TypeReference typeRef>
= 
  ident (. LocalVariableDeclaration loc = new LocalVariableDeclaration(t); .)
        (. loc.Name = t.val; .)
        (. loc.ResultingType = typeRef; .)
        (. if (block != null) block.Statements.Add(loc); .)       
  [
    "=" 
    (   (. Initializer init; .)
      VariableInitializer<out init> (. loc.Initializer = init; .)
      | "stackalloc" 
        (. StackAllocInitializer saIn = new StackAllocInitializer(t); .)
        (. loc.Initializer = saIn; .)
        (. TypeReference tr; .)
      Type<out tr, false> 
        (. saIn.Type = tr; .)
        (. Expression expr; .)
      "[" 
        Expression<out expr> 
        (. saIn.Expression = expr; .)
      "]" 
    )
  ]
. 

// ------------------------------------------------------------------------------------
// Creates an initializer.
// +init: Initializer created.
// ------------------------------------------------------------------------------------
VariableInitializer<out Initializer init> (. Expression expr; init = null; .)
= 
  Expression<out expr>  (. SimpleInitializer sin = new SimpleInitializer(t); .)
                        (. sin.Expression = expr; .)
                        (. init = sin; .)
  |                     (. ArrayInitializer arrInit; .)
    ArrayInitializer<out arrInit> (. init = arrInit;.)
.

// ------------------------------------------------------------------------------------
// Creates an array initializer.
// +init: Initializer created.
// ------------------------------------------------------------------------------------
ArrayInitializer<out ArrayInitializer init> (. init = new ArrayInitializer(t); .)
= (. Initializer arrayInit = null; .)
  "{" [ 
  VariableInitializer<out arrayInit> (. init.Initializers.Add(arrayInit); .)
  {IF (NotFinalComma()) ","
  VariableInitializer<out arrayInit> (. init.Initializers.Add(arrayInit); .)
  } [ "," ] ] "}"
.

// ------------------------------------------------------------------------------------
// Declaration of a formal parameter list
// +pars List holding the formal parameter declarations.
// ------------------------------------------------------------------------------------
FormalParameterList<FormalParameterCollection pars>                                                  
=                                      (. 
                                          TypeReference typeRef = null; 
                                          AttributeCollection attrs = new AttributeCollection();
                                       .)
  { Attributes<attrs> }                (. 
                                          FormalParameter fp = new FormalParameter(t); 
                                          fp.AssignAttributes(attrs);
                                       .)
  (                                    
    [ 
      "ref"                            (. fp.Kind = FormalParameterKind.Ref; .) 
      | "out"                          (. fp.Kind = FormalParameterKind.Out; .) 
    ] Type<out typeRef, false>         (. fp.Type = typeRef; .)
    ident                              (. 
                                          fp.Name = t.val; 
                                          fp.Type = typeRef;
                                          pars.Add(fp);
                                       .)
    [ "," FormalParameterList<pars> ]
  | "params"                           (. fp.HasParams = true; .)
    Type<out typeRef, false>           (. if (typeRef.Kind != TypeKind.array) { Error("params argument must be an array"); } .)
    ident                              (. fp.Name = t.val; .)
                                       (. fp.Type = typeRef; .)
                                       (. pars.Add(fp); .)
  )
.

Argument<ArgumentList argList> 
              (. Argument arg = new Argument(t); .)
= 
  [           
    "ref"     (. arg.Kind = FormalParameterKind.Ref; .)
    | "out"   (. arg.Kind = FormalParameterKind.Out; .)
  ]           (. Expression expr; .)
  Expression<out expr>
              (. if (argList != null) argList.Add(arg); .)
.

// ------------------------------------------------------------------------------------
// Declaration of a property accessors.
// +prop: property holding the accessor.
// ------------------------------------------------------------------------------------
AccessorDeclarations<PropertyDeclaration prop>                                    
       (. 
          AttributeCollection attrs = new AttributeCollection();
          AccessorDeclaration accessor = null;
       .)
= { Attributes<attrs> }               (. Modifiers am = new Modifiers(this); .)
  ModifierList<am>                    (. am.Check(Modifier.accessorsPossib1, Modifier.accessorsPossib2); .)
  ( IF ("get".Equals(la.val)) ident   (. accessor = prop.Getter = new AccessorDeclaration(t); .)
  | IF ("set".Equals(la.val)) ident   (. accessor = prop.Getter = new AccessorDeclaration(t); .)
  | ident                             (. Error("set or get expected"); .)
  ) 
  (
    Block<accessor>                   (. accessor.HasBody = true; .)
  | ";"                               (. accessor.HasBody = false; .)
  )                                   (. 
                                         accessor.SetModifiers(am.Value); 
                                         accessor.AssignAttributes(attrs);
                                      .)
  [                                   (. attrs = new AttributeCollection(); .)                               
    { Attributes<attrs> }             (. am = new Modifiers(this); .)
    ModifierList<am>                  (. am.Check(Modifier.accessorsPossib1, Modifier.accessorsPossib2); .)
    ( IF ("get".Equals(la.val)) ident (. 
                                         if (prop.HasGetter) Error("get already declared");  
                                         accessor = prop.Getter = new AccessorDeclaration(t);
                                      .)
    | IF ("set".Equals(la.val)) ident (. 
                                         if (prop.HasSetter) Error("set already declared");  
                                         accessor = prop.Setter = new AccessorDeclaration(t);
                                      .)
    | ident                           (. Error("set or get expected"); .)
    ) 
    (
      Block<accessor>                 (. accessor.HasBody = true; .)
    | ";"                             (. accessor.HasBody = false; .)
    )                                 (. 
                                         accessor.SetModifiers(am.Value); 
                                         accessor.AssignAttributes(attrs);
                                      .)
  ]
.

// ------------------------------------------------------------------------------------
// Declaration of an event property accessors.
// +prop: event property holding the accessor.
// ------------------------------------------------------------------------------------
EventAccessorDeclarations<EventPropertyDeclaration prop>                                                 
       (. 
          AttributeCollection attrs = new AttributeCollection();
          AccessorDeclaration accessor = null;
       .)
= { Attributes<attrs> }
  ( IF ("add".Equals(la.val)) ident       (. accessor = prop.Adder = new AccessorDeclaration(t); .)
  | IF ("remove".Equals(la.val)) ident    (. accessor = prop.Remover = new AccessorDeclaration(t); .)
  | ident                                 (. Error("add or remove expected"); .)
  ) 
  Block<accessor>                         (. 
                                             accessor.HasBody = true;
                                             accessor.AssignAttributes(attrs); 
                                          .)
  [                                       (. attrs = new AttributeCollection(); .)                               
    { Attributes<attrs> }    
    ( IF ("add".Equals(la.val)) ident     (. 
                                             if (prop.HasAdder) Error("add already declared");  
                                             accessor = prop.Adder = new AccessorDeclaration(t);
                                          .)
    | IF ("remove".Equals(la.val)) ident  (. 
                                             if (prop.HasRemover) Error("set already declared");  
                                             accessor = prop.Remover = new AccessorDeclaration(t);
                                          .)
    | ident                               (. Error("add or remove expected"); .)
    ) 
    Block<accessor>                       (. 
                                             accessor.HasBody = true;
                                             accessor.AssignAttributes(attrs); 
                                          .)
  ]
.

// ------------------------------------------------------------------------------------
// Declaration of an interface accessors.
// +prop: event property holding the accessor.
// ------------------------------------------------------------------------------------
InterfaceAccessors<PropertyDeclaration prop>
       (. 
          AttributeCollection attrs = new AttributeCollection();
          AccessorDeclaration accessor = null;
       .)
= { Attributes<attrs> }
  ( IF ("get".Equals(la.val)) ident     (. accessor = prop.Getter = new AccessorDeclaration(t); .)
  | IF ("set".Equals(la.val)) ident     (. accessor = prop.Setter = new AccessorDeclaration(t); .)
  | ident                               (. Error("set or get expected"); .)
  ) ";"                                 (. accessor.AssignAttributes(attrs); .)
  [                                     (. attrs = new AttributeCollection(); .)                               
    { Attributes<attrs> }    
    ( IF ("get".Equals(la.val)) ident   (. 
                                         if (prop.HasGetter) Error("get already declared");  
                                         accessor = prop.Getter = new AccessorDeclaration(t);
                                        .)
    | IF ("set".Equals(la.val)) ident   (. 
                                         if (prop.HasSetter) Error("set already declared");  
                                         accessor = prop.Setter = new AccessorDeclaration(t);
                                        .)
    | ident                             (. Error("set or get expected"); .)
    ) ";"                               (. accessor.AssignAttributes(attrs); .)
  ]
.

// ------------------------------------------------------------------------------------
// Declaration of attributes.
// +attrs: List holding the attribute declarations.
// ------------------------------------------------------------------------------------
Attributes<AttributeCollection attrs>
=                                                            (. string scope = ""; .)
  "[" [ IF (IsAttrTargSpec()) 
  ( ident | Keyword )                                        (. scope = t.val; .)
  ":" ]                                                      (. AttributeDeclaration attr; .)
  Attribute<out attr>                                        (. 
                                                                attr.Scope = scope;
                                                                attrs.Add(attr);
                                                             .)
  { 
    IF (la.kind == _comma && Peek(1).kind != _rbrack) "," 
    Attribute<out attr>                                      (. 
                                                                attr.Scope = scope;
                                                                attrs.Add(attr);
                                                             .)
  } [ "," ] "]"
.

// ------------------------------------------------------------------------------------
// Declarations tokens that function as keywords.
// ------------------------------------------------------------------------------------
Keyword
=
  "abstract" | "as" | "base" | "bool" | "break" | "byte" | "case" | "catch"
  | "char" | "checked" | "class" | "const" | "continue" | "decimal" | "default"
  | "delegate" | "do" | "double" | "else" | "enum" | "event" | "explicit"
  | "extern" | "false" | "finally" | "fixed" | "float" | "for" | "foreach"
  | "goto" | "if" | "implicit" | "in" | "int" | "interface" | "internal" | "is"
  | "lock" | "long" | "namespace" | "new" | "null" | "object" | "operator"
  | "out" | "override" | "params" | "private" | "protected" | "public"
  | "readonly" | "ref" | "return" | "sbyte" | "sealed" | "short" | "sizeof"
  | "stackalloc" | "static" | "string" | "struct" | "switch" | "this" | "throw"
  | "true" | "try" | "typeof" | "uint" | "ulong" | "unchecked" | "unsafe"
  | "ushort" | "using" | "virtual" | "void" | "volatile" | "while"
.

// ------------------------------------------------------------------------------------
// Declaration of an attribute.
// +attr: Attribute declaration.
// ------------------------------------------------------------------------------------
Attribute<out AttributeDeclaration attr> (. TypeReference typeRef; .)
=  
  TypeName<out typeRef>                  (. 
                                            attr = new AttributeDeclaration(t); 
                                            attr.TypeReference = typeRef;
                                         .)
  [ AttributeArguments<attr> ] 
.

// ------------------------------------------------------------------------------------
// Declares the list of attribute arguments.
// +attr: Attribute declaration.
// ------------------------------------------------------------------------------------
AttributeArguments<AttributeDeclaration attr> 
                                     (. AttributeArgument arg; .)
=                                    (. bool nameFound = false; .)
  "(" 
    [                                (. arg = new AttributeArgument(t); .)
      [ IF (IsAssignment())          
        ident                        (. arg.Name = t.val; .)
        "="                          (. nameFound = true; .)
      ]                              (. Expression expr; .)
      Expression<out expr>           (. arg.Expression = expr; .)
                                     (. attr.Arguments.Add(arg); .)
      { ","                          (. arg = new AttributeArgument(t); .)
        ( IF (IsAssignment())  
          ident                      (. arg.Name = t.val; .)
          "="                        (. nameFound = true; .)
          |                          (. if (nameFound) Error("no positional argument after named arguments"); .)
        ) Expression<out expr>       (. arg.Expression = expr; .)
                                     (. attr.Arguments.Add(arg); .)
      }
    ]
  ")"
.

// ------------------------------------------------------------------------------------
// Modifiers that can be assigned to types and members.
// +m: List of modifier flags.
// ------------------------------------------------------------------------------------
ModifierList<Modifiers m>
=
{
  "new"                            (. m.Add(Modifier.@new); .)
  | "public"                       (. m.Add(Modifier.@public); .)
  | "protected"                    (. m.Add(Modifier.@protected); .)
  | "internal"                     (. m.Add(Modifier.@internal); .)
  | "private"                      (. m.Add(Modifier.@private); .)
  | "unsafe"                       (. m.Add(Modifier.@unsafe); .)
  | "static"                       (. m.Add(Modifier.@static); .)
  | "readonly"                     (. m.Add(Modifier.@readonly); .)
  | "volatile"                     (. m.Add(Modifier.@volatile); .)
  | "virtual"                      (. m.Add(Modifier.@virtual); .)
  | "sealed"                       (. m.Add(Modifier.@sealed); .)
  | "override"                     (. m.Add(Modifier.@override); .)
  | "abstract"                     (. m.Add(Modifier.@abstract); .)
  | "extern"                       (. m.Add(Modifier.@extern); .)
}
.

// ------------------------------------------------------------------------------------
// Reference for a type
// +typeRef: type reference
// +voidAllowed: indicates if "void" is an acceptable type or not.
// ------------------------------------------------------------------------------------
Type<out TypeReference typeRef, bool voidAllowed>    
=                                                    (. typeRef = new TypeReference(t); .)
  ( PrimitiveType                                    (. 
                                                        typeRef = new TypeReference(t); 
                                                        typeRef.Name = t.val;
                                                     .)
  | ClassType<out typeRef>                                               
  | "void"                                           (. 
                                                        typeRef = new TypeReference(t); 
                                                        typeRef.Name = t.val;
                                                        typeRef.Kind = TypeKind.@void; 
                                                     .)
  )
  [ "?"                                              (. if (typeRef.Kind == TypeKind.@void) { Error("Unexpected token ?, void must not be nullable."); } .)
  ]
  PointerOrArray<ref typeRef>                        (. if (typeRef.Kind == TypeKind.@void && !voidAllowed) { Error("type expected, void found, maybe you mean void*"); } .)
.

// ------------------------------------------------------------------------------------
// Sets the appropriate flags of a type reference if the declaration shows it is
// a pointer or array.
// +typeRef: type reference.
// ------------------------------------------------------------------------------------
PointerOrArray<ref TypeReference typeRef>
=
  { IF (IsPointerOrDims())
    ( "*"                                                       (. typeRef.Kind = TypeKind.pointer; .)
    | "[" { "," } "]"                                           (. typeRef.Kind = TypeKind.array; .)
    )
  }
.

// ------------------------------------------------------------------------------------
// Types that are taken into account as primitive types.
// ------------------------------------------------------------------------------------
PrimitiveType
=
  IntegralType | "float" | "double" | "decimal" | "bool"
.

// ------------------------------------------------------------------------------------
// Types that are taken into account as integral types.
// ------------------------------------------------------------------------------------
IntegralType
=
  "sbyte" | "byte" | "short" | "ushort" | "int" | "uint" | "long" | "ulong" | "char"
.

// ------------------------------------------------------------------------------------
// Types that are taken into account as class types.
// +typeRef: resulting type reference.
// ------------------------------------------------------------------------------------
ClassType<out TypeReference typeRef>   (. typeRef = new TypeReference(t); .)
=                                                               
  TypeName<out typeRef> |               
  "object"                             (. typeRef.Name = t.val; .)
  | "string"                           (. typeRef.Name = t.val; .)
.

// ------------------------------------------------------------------------------------
// Declaration of a compound member name
// +typeRef: An instance to a member reference
// ------------------------------------------------------------------------------------
MemberName<out TypeReference typeRef>                                              
= 
  ident                                  (. 
                                            typeRef = new TypeReference(t);
                                            typeRef.Name = t.val; 
                                            TypeReference nextType = typeRef;
                                         .)
  [ 
    "::"                                 (. typeRef.IsGlobal = true; .)
    ident                                (. 
                                            typeRef.SubType = new TypeReference(t);
                                            typeRef.SubType.Name = t.val; 
                                            nextType = typeRef.SubType;
                                         .)
  ]
  [ 
    IF (la.kind == _lt && IsPartOfMemberName()) 
      TypeArgumentList<typeRef.Arguments> 
  ]
  { IF (la.kind == _dot && Peek(1).kind == _ident)
      "." ident                          (. 
                                            nextType.SubType = new TypeReference(t);
                                            nextType.SubType.Name = t.val;
                                            nextType = nextType.SubType;
                                         .)
    [ 
      IF (la.kind == _lt && IsPartOfMemberName()) 
        TypeArgumentList<typeRef.Arguments>
    ]
  }
.

// ------------------------------------------------------------------------------------
// Declaration of a compound type name
// +typeRef: An instance to a member reference
// ------------------------------------------------------------------------------------
TypeName<out TypeReference typeRef>                             
=                                                               
  ident                                  (. 
                                            typeRef = new TypeReference(t);
                                            typeRef.Name = t.val; 
                                            TypeReference nextType = typeRef;
                                         .)
  [ 
    "::"                                 (. typeRef.IsGlobal = true; .)
    ident                                (. 
                                            typeRef.SubType = new TypeReference(t);
                                            typeRef.SubType.Name = t.val; 
                                            nextType = typeRef.SubType;
                                         .)
  ]                                                
  [ TypeArgumentList<typeRef.Arguments> ]                                    
  {
    "." ident                            (. 
                                            nextType.SubType = new TypeReference(t);
                                            nextType.SubType.Name = t.val;
                                         .)
    [ TypeArgumentList<typeRef.Arguments> ]        (. nextType = nextType.SubType; .)
  }
.

// ------------------------------------------------------------------------------------
// Defines a statement.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
Statement<IBlockOwner block>
= 
  IF (la.kind == _ident && Peek(1).kind == _colon) ident ":" Statement<block>
  | ConstStatement<block>
  | IF (IsLocalVarDecl()) LocalVariableDeclaration<block> ";"
  | EmbeddedStatement<block>
.

// ------------------------------------------------------------------------------------
// Defines statements that can be nested in other statements.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
EmbeddedStatement<IBlockOwner block> 
=   
    // --- Block nested into a statement
    Block<block>
  | EmptyStatement<block>
  | CheckedBlock<block>
  | UncheckedBlock<block>
  | UnsafeBlock<block>
  | StatementExpression<block> ";"
  | IfStatement<block>
  | SwitchStatement<block>
  | WhileStatement<block>
  | DoWhileStatement<block>
  | ForStatement<block>
  | ForEachStatement<block>
  | BreakStatement<block>
  | ContinueStatement<block>
  | GotoStatement<block>
  | ReturnStatement<block>
  | ThrowStatement<block>
  | TryFinallyBlock<block>
  | LockStatement<block>
  | UsingStatement<block>
  | "yield" ( YieldReturnStatement<block> | YieldBreakStatement<block> ) ";"
  | FixedStatement<block>
.

// ------------------------------------------------------------------------------------
// Defines a block of statements.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
Block<IBlockOwner block>
=
  "{" { Statement<block> } "}"
.


// ------------------------------------------------------------------------------------
// Defines a switch statement.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
SwitchStatement<IBlockOwner block>
=
  "switch"                (. SwitchStatement sws = new SwitchStatement(t); .)
  "("                     (. Expression expr; .)
  Expression<out expr>    (. sws.Expression = expr; .)
  ")" "{" 
  { 
    SwitchSection<sws> 
  } 
  "}"
.

// ------------------------------------------------------------------------------------
// Defines a constant statement.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
ConstStatement<IBlockOwner block>
=
  "const"                (. TypeReference typeRef; .)
                         (. ConstStatement cs = new ConstStatement(t); .)
  Type<out typeRef, false> 
  ident                  (. cs.Name = t.val; .)
  "="                    (. Expression expr; .)
  Expression<out expr>   (. cs.Expression = expr; .)
                         (. if (block != null) block.Add(cs); .)
  { ","                  (. cs = new ConstStatement(t); .)
    ident                (. cs.Name = t.val; .)
    "=" 
    Expression<out expr> (. cs.Expression = expr; .)
                         (. if (block != null) block.Add(cs); .)
  } ";".

// ------------------------------------------------------------------------------------
// Defines an empty statement (";").
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
EmptyStatement<IBlockOwner block>
=
  ";" (. if (block != null) block.Add(new EmptyStatement(t)); .)
.

// ------------------------------------------------------------------------------------
// Defines a "checked" block
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
CheckedBlock<IBlockOwner block>
=
  (
    IF (la.kind == _checked && Peek(1).kind == _lbrace) 
      "checked" (. 
                   CheckedBlock cb = new CheckedBlock(t);
                   if (block != null) block.Add(cb);
                .)
    Block<cb>
  )
.

// ------------------------------------------------------------------------------------
// Defines an "unchecked" block
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
UncheckedBlock<IBlockOwner block>
=
  (
    IF (la.kind == _unchecked && Peek(1).kind == _lbrace) 
    "unchecked" (. 
                   UncheckedBlock ucb = new UncheckedBlock(t);
                   if (block != null) block.Add(ucb);
                .)
    Block<ucb>

  )
.

// ------------------------------------------------------------------------------------
// Defines an "unsafe" block
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
UnsafeBlock<IBlockOwner block>
=
  "unsafe" (. 
              UnsafeBlock usb = new UnsafeBlock(t);
              if (block != null) block.Add(usb);
           .)
  Block<usb>
.

// ------------------------------------------------------------------------------------
// Defines an "if" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
IfStatement<IBlockOwner block>
=   
  "if"                   (. IfStatement ifs = new IfStatement(t); .)
  "("                    (. if (block != null) block.Add(ifs); .)
                         (. Expression expr; .)
    Expression<out expr> (. ifs.Condition = expr; .)
  ")"                    (. ifs.CreateThenBlock(t); .)
  EmbeddedStatement<ifs.ThenStatements> 
  [ "else"               (. ifs.CreateElseBlock(t); .)
    EmbeddedStatement<ifs.ElseStatements> 
  ]
.

// ------------------------------------------------------------------------------------
// Defines a "while" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
WhileStatement<IBlockOwner block>
= 
  "while"                 (. WhileStatement whs = new WhileStatement(t); .)
  "("                     (. if (block != null) block.Add(whs); .)
                          (. Expression expr; .)
    Expression<out expr>  (. whs.Condition = expr; .)
  ")" 
  EmbeddedStatement<whs>
.    

// ------------------------------------------------------------------------------------
// Defines a "do...while" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
DoWhileStatement<IBlockOwner block>
=   
  "do"                      (. DoWhileStatement whs = new DoWhileStatement(t); .)
    EmbeddedStatement<whs>  (. if (block != null) block.Add(whs); .)
  "while" 
  "("                       (. Expression expr; .)
    Expression<out expr>    (. whs.Condition = expr; .)
  ")" ";"                   
.    

// ------------------------------------------------------------------------------------
// Defines a "for" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
ForStatement<IBlockOwner block>
= 
  "for"                       (. ForStatement fs = new ForStatement(t); .)
  "("                         (. if (block != null) block.Add(fs); .)
    [                         (. fs.CreateInitializerBlock(t); .)
      ForInitializer<fs>
    ] ";" 
    [                         (. Expression expr; .)
      Expression<out expr>    (. fs.Condition = expr; .)
    ] ";" 
    [ 
      ForIterator<fs>         (. fs.CreateIteratorBlock(t); .)
    ] 
  ")"
  EmbeddedStatement<fs>
.    

// ------------------------------------------------------------------------------------
// Defines a "foreach" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
ForEachStatement<IBlockOwner block>
=
  "foreach"                   (. ForEachStatement fes = new ForEachStatement(t); .)
  "("                         (. if (block != null) block.Add(fes); .)
                              (. TypeReference typeRef; .)
    Type<out typeRef, false>  (. fes.ItemType = typeRef; .)
    ident                     (. fes.Name = t.val; .)
    "in"                      (. Expression expr; .)
    Expression<out expr>      (. fes.Expression = expr; .)
  ")"
  EmbeddedStatement<fes>
.    

// ------------------------------------------------------------------------------------
// Defines a "break" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
BreakStatement<IBlockOwner block>
=
  "break" ";" (. if (block != null) block.Add(new BreakStatement(t)); .)
.    

// ------------------------------------------------------------------------------------
// Defines a "goto" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
GotoStatement<IBlockOwner block>
=
  "goto"                  (. GotoStatement gs = new GotoStatement(t); .)
                          (. if (block != null) block.Add(gs); .)
  ( 
    ident                 (. gs.Name = t.val; .)
  | 
    "case"                (. Expression expr; .)
    Expression<out expr>  (. gs.LabelExpression = expr; .)
  | 
    "default"             (. gs.Name = t.val; .)
  ) ";"
.

// ------------------------------------------------------------------------------------
// Defines a "continue" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
ContinueStatement<IBlockOwner block>
=
  "continue" ";" (. if (block != null) block.Add(new ContinueStatement(t)); .)
.    

// ------------------------------------------------------------------------------------
// Defines a "try...catch...finally" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
TryFinallyBlock<IBlockOwner block>
=
  "try"         (. 
                   TryStatement ts = new TryStatement(t); 
                   ts.CreateTryBlock(t);
                   if (block != null) block.Add(ts);
                .)
  Block<ts.TryBlock> 
  ( 
    CatchClauses<ts>
    [ 
      "finally" (. ts.CreateFinallyBlock(t); .) 
      Block<ts.FinallyBlock> 
    ] 
  | "finally" (. ts.CreateFinallyBlock(t); .) 
    Block<ts.FinallyBlock> 
  )
.    

// ------------------------------------------------------------------------------------
// Defines a "lock" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
LockStatement<IBlockOwner block>
=   
  "lock"                  (. LockStatement ls = new LockStatement(t); .)
                          (. if (block != null) block.Add(ls); .)
  "("                     (. Expression expr; .)
    Expression<out expr>  (. ls.Expression = expr; .)
  ")" 
  EmbeddedStatement<ls>
.    

// ------------------------------------------------------------------------------------
// Defines a "using" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
UsingStatement<IBlockOwner block>
=
  "using" (. 
              UsingStatement us = new UsingStatement(t);
              if (block != null) block.Add(us);
           .)
  "(" 
  (
    IF (IsLocalVarDecl())       (. us.CreateResourceDeclarations(t); .)
    LocalVariableDeclaration<us.ResourceDeclarations>  
  |                             (. Expression expr; .)
    Expression<out expr>        (. us.ResourceExpression = expr; .)
  ) 
  ")" 
  EmbeddedStatement<us>
.    

// ------------------------------------------------------------------------------------
// Defines a "return" statement.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
ReturnStatement<IBlockOwner block>
=
  "return"                 (. ReturnStatement yrs = new ReturnStatement(t); .)
  [                        (. Expression expr; .)
  Expression<out expr>     (. yrs.Expression = expr; .)
  ]
  ";"                      (. if (block != null) block.Add(yrs); .)
                           
.

// ------------------------------------------------------------------------------------
// Defines a "throw" statement.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
ThrowStatement<IBlockOwner block>
=
  "throw"                 (. ThrowStatement ts = new ThrowStatement(t); .)
  [                       (. Expression expr; .)
    Expression<out expr>  (. ts.Expression = expr; .)
  ] ";"                   (. if (block != null) block.Add(ts); .)
.

// ------------------------------------------------------------------------------------
// Defines a "yield return" statement.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
YieldReturnStatement<IBlockOwner block>
=
  "return"                 (. Expression expr; .)
  Expression<out expr>     (. YieldReturnStatement yrs = new YieldReturnStatement(t); .)
                           (. yrs.Expression = expr; .)
                           (. if (block != null) block.Add(yrs); .)
.

// ------------------------------------------------------------------------------------
// Defines a "yield break" statement.
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
YieldBreakStatement<IBlockOwner block>
=
  "break" (. if (block != null) block.Add(new YieldBreakStatement(t)); .)
.

// ------------------------------------------------------------------------------------
// Defines a "fixed" statement
// +block: Block holding the statements within.
// ------------------------------------------------------------------------------------
FixedStatement<IBlockOwner block>
= 
  "fixed"                     (. FixedStatement fs = new FixedStatement(t); .)
                              (. if (block != null) block.Add(fs); .)
  "("                         (. TypeReference typeRef; .)
          
    Type<out typeRef, false>          
                              (. if (typeRef.Kind != TypeKind.pointer) Error("can only fix pointer types"); .)
                              (. ValueAssignmentStatement vas = new ValueAssignmentStatement(t); .)
    ident                     (. vas.Name = t.val; .)
    "="                       (. Expression expr; .)
    Expression<out expr>      (. vas.Expression = expr; .)
                              (. fs.Assignments.Add(vas); .)
    { 
      ","                     (. vas = new ValueAssignmentStatement(t); .)
      ident                   (. vas.Name = t.val; .)
      "=" 
      Expression<out expr>    (. vas.Expression = expr; .)
                              (. fs.Assignments.Add(vas); .)
    }
  ")" EmbeddedStatement<fs>
.    

// ------------------------------------------------------------------------------------
// Defines a statement expression
// +operateor: Assignement operator 
// ------------------------------------------------------------------------------------
StatementExpression<IBlockOwner block>  (. bool isAssignment = assnStartOp[la.kind] || IsTypeCast(); .)
=                                       (. Expression expr = null; .)
  Unary<out expr>                       (. ExpressionStatement es = new ExpressionStatement(t); .)
                                        (. es.Expression = expr; .)
  ( (. AssignmentOperator asgn; .)
    AssignmentOperator<out asgn>        (. es.Expression = asgn; .)
                                        (. asgn.LeftOperand = expr; .)
                                        (. Expression rightExpr; .)
    Expression<out rightExpr>           (. asgn.RightOperand = rightExpr; .)
  | (. if (isAssignment) Error("error in assignment."); .)
  )                                     (. if (block != null) block.Add(es); .)
.

// ------------------------------------------------------------------------------------
// Defines assignment operators.
// +operateor: Assignement operator 
// ------------------------------------------------------------------------------------
AssignmentOperator<out AssignmentOperator op> (. op = null; .)
=
    "="     (. op = new AssignmentOperator(t); .)
  | "+="    (. op = new PlusAssignmentOperator(t); .)
  | "-="    (. op = new MinusAssignmentOperator(t); .)
  | "*="    (. op = new MultiplyAssignmentOperator(t); .)
  | "/="    (. op = new DivideAssignmentOperator(t); .)
  | "%="    (. op = new ModuloAssignmentOperator(t); .)
  | "&="    (. op = new AndAssignmentOperator(t); .)
  | "|="    (. op = new OrAssignmentOperator(t); .)
  | "^="    (. op = new XorAssignmentOperator(t); .)
  | "<<="   (. op = new LeftShiftAssignmentOperator(t); .)
  | ">"     (. int pos = t.pos; .)
    ">="    (. if (pos+1 < t.pos) Error("no whitespace allowed in right shift assignment"); .)
            (. op = new RightShiftAssignmentOperator(t); .)
.

// ------------------------------------------------------------------------------------
// Represents a section of a switch statement.
// +expr: Label expression
// ------------------------------------------------------------------------------------
SwitchSection<SwitchStatement sws>
=                         (. 
                             SwitchSection section = sws.CreateSwitchSection(t);
                             Expression expr;
                          .)
  SwitchLabel<out expr>   (. 
                            if (expr == null) section.IsDefault = true; 
                             else section.Labels.Add(expr);
                          .)
  { 
    IF (la.kind == _case || (la.kind == _default && Peek(1).kind == _colon)) 
    SwitchLabel<out expr> (. 
                           if (expr == null) section.IsDefault = true; 
                           else section.Labels.Add(expr);
                          .)
  }
  Statement<section> 
  { 
    IF (IsNoSwitchLabelOrRBrace()) 
    Statement<section> 
  }
.

// ------------------------------------------------------------------------------------
// Represents a label of a switch statement.
// +expr: Label expression
// ------------------------------------------------------------------------------------
SwitchLabel<out Expression expr> (. expr = null; .)
= 
  "case" Expression<out expr> ":"
  | "default" ":"                 
.

// ------------------------------------------------------------------------------------
// Represents the initializer of a for statement.
// +fs: For statement owning the initializator.
// ------------------------------------------------------------------------------------
ForInitializer<ForStatement fs>
=
  IF (IsLocalVarDecl()) LocalVariableDeclaration<fs.InitializerBlock>
  | StatementExpression<fs.InitializerBlock> { "," StatementExpression<fs.InitializerBlock> }
.

// ------------------------------------------------------------------------------------
// Represents the iterator of a for statement.
// +fs: For statement owning the iterator.
// ------------------------------------------------------------------------------------
ForIterator<ForStatement fs>
=
  StatementExpression<fs.IteratorBlock> { "," StatementExpression<fs.IteratorBlock> }
.

// ------------------------------------------------------------------------------------
// Represents catch clauses in a try..catch..finally statement.
// +try: Statement owning the catch clauses.
// ------------------------------------------------------------------------------------
CatchClauses<TryStatement tryStm>
=                                                     
  "catch"                   (. CatchClause cc = tryStm.CreateCatchClause(t); .)      
  (                         
    Block<cc>
  | 
    "("                     (. TypeReference typeRef; .)
    ClassType<out typeRef>  (. cc.ExceptionType = typeRef; .)
    [ 
      ident                 (. cc.Name = t.val; .)
    ] 
    ")" Block<cc> 
    [ CatchClauses<tryStm> ]
  )
.

// ------------------------------------------------------------------------------------
// Retrieves an expression.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
Expression<out Expression expr>   (. expr = null; .)
=                                 (. Expression leftExpr; .)
  Unary<out leftExpr>
  ( IF (assgnOps[la.kind] || (la.kind == _gt && Peek(1).kind == _gteq))
                                  (. AssignmentOperator asgn; .)
    AssignmentOperator<out asgn>  (. Expression rightExpr; .)
    Expression<out rightExpr>     (. asgn.RightOperand = rightExpr; .)
                                  (. asgn.LeftOperand = leftExpr; .)
                                  (. expr = asgn; .)
  | (. BinaryOperator simpleExpr; .)
    NullCoalescingExpr<out simpleExpr> 
                                  (. 
                                     if (simpleExpr == null) 
                                     {
                                       expr = leftExpr;
                                     }
                                     else
                                     {
                                       simpleExpr.LeftMostNonNull.LeftOperand = leftExpr;
                                       expr = simpleExpr;
                                     }
                                  .)
    [                             (. ConditionalOperator condExpr = new ConditionalOperator(t); .)
                                  (. condExpr.Condition = simpleExpr; .)
                                  (. expr = condExpr; .)    
      "?"                         (. Expression trueExpr; .)
      Expression<out trueExpr>    (. condExpr.TrueExpression = trueExpr; .)
      ":"                         (. Expression falseExpr; .)
      Expression<out falseExpr>   (. condExpr.FalseExpression = falseExpr; .)
    ]
  )
.

// ------------------------------------------------------------------------------------
// Defines a null coalescing operator.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
NullCoalescingExpr<out BinaryOperator expr> (. expr = null; .)
=                     
  OrExpr<out expr>    
  { 
    "??"                  (. BinaryOperator oper = new NullCoalescingOperator(t); .)
                          (. oper.LeftOperand = expr; .)
                          (. Expression unExpr; .)
    Unary<out unExpr>     (. BinaryOperator rightExpr; .)
    OrExpr<out rightExpr> (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines a logical or operator.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
OrExpr<out BinaryOperator expr> (. expr = null; .)
= 
  AndExpr<out expr>    
  { 
    "||"                  (. BinaryOperator oper = new OrOperator(t); .)
                          (. oper.LeftOperand = expr; .)
                          (. Expression unExpr; .)
    Unary<out unExpr>     (. BinaryOperator rightExpr; .)
    AndExpr<out rightExpr> (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines a logical and operator.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
AndExpr<out BinaryOperator expr> (. expr = null; .)
= 
  BitOrExpr<out expr>    
  { 
    "&&"                  (. BinaryOperator oper = new AndOperator(t); .)
                          (. oper.LeftOperand = expr; .)
                          (. Expression unExpr; .)
    Unary<out unExpr>     (. BinaryOperator rightExpr; .)
    BitOrExpr<out rightExpr> (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines a bitwise or operator.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
BitOrExpr<out BinaryOperator expr> (. expr = null; .)
= 
  BitXorExpr<out expr>    
  { 
    "|"                   (. BinaryOperator oper = new BitwiseOrOperator(t); .)
                          (. oper.LeftOperand = expr; .)
                          (. Expression unExpr; .)
    Unary<out unExpr>     (. BinaryOperator rightExpr; .)
    BitXorExpr<out rightExpr> (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines a bitwise xor operator.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
BitXorExpr<out BinaryOperator expr> (. expr = null; .)
= 
  BitAndExpr<out expr>    
  { 
    "^"                   (. BinaryOperator oper = new BitwiseXorOperator(t); .)
                          (. oper.LeftOperand = expr; .)
                          (. Expression unExpr; .)
    Unary<out unExpr>     (. BinaryOperator rightExpr; .)
    BitAndExpr<out rightExpr> (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines a bitwise and operator.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
BitAndExpr<out BinaryOperator expr> (. expr = null; .)
= 
  EqlExpr<out expr>    
  { 
    "&"                   (. BinaryOperator oper = new BitwiseAndOperator(t); .)
                          (. oper.LeftOperand = expr; .)
                          (. Expression unExpr; .)
    Unary<out unExpr>     (. BinaryOperator rightExpr; .)
    EqlExpr<out rightExpr> (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines an "==" or "!=" operator.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
EqlExpr<out BinaryOperator expr> (. expr = null; .)
= 
  RelExpr<out expr>       (. BinaryOperator oper; .)
  {           
    (                     
      "!="                (. oper = new EqualOperator(t); .)
      | "=="              (. oper = new NotEqualOperator(t); .)
    )                     (. oper.LeftOperand = expr; .)
                          (. Expression unExpr; .)
    Unary<out unExpr>     (. BinaryOperator rightExpr; .) 
    RelExpr<out rightExpr> (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines relational and typecheck operators.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
RelExpr<out BinaryOperator expr> (. expr = null; .)
= 
  ShiftExpr<out expr>     (. BinaryOperator oper = null; .)
  { 
    (
      "<"                 (. oper = new LessThanOperator(t); .)
      | ">"               (. oper = new GreaterThanOperator(t); .)
      | "<="              (. oper = new LessThanOrEqualOperator(t); .)
      | ">="              (. oper = new GreaterThanOrEqualOperator(t); .)
    )                     (. oper.LeftOperand = expr; .)
                          (. Expression unExpr; .)
    Unary<out unExpr>     (. BinaryOperator rightExpr; .) 
    ShiftExpr<out rightExpr>             
                          (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                          .)
    | 
      (
        "is"              (. oper = new IsOperator(t); .)
        | "as"            (. oper = new IsOperator(t); .)
      )                   (. oper.LeftOperand = expr; .)
                          (. TypeReference typeRef; .)
      Type<out typeRef, false>
                          (. oper.RightOperand = new TypeOperator(t, typeRef); .)
                          (. expr = oper; .)
  }
.

// ------------------------------------------------------------------------------------
// Defines shift operators.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
ShiftExpr<out BinaryOperator expr> (. expr = null; .)
= 
  AddExpr<out expr>       (. BinaryOperator oper = null; .)
  { IF (IsShift())
    (
      "<<"                (. oper = new LeftShiftOperator(t); .)
      | ">" ">"           (. oper = new RightShiftOperator(t); .)
    )                     (. oper.LeftOperand = expr; .)
                          (. Expression unExpr; .)
    Unary<out unExpr>     (. BinaryOperator rightExpr; .) 
    AddExpr<out rightExpr>
                          (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines addition operators.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
AddExpr<out BinaryOperator expr> (. expr = null; .)
= 
  MulExpr<out expr>       (. BinaryOperator oper = null; .)
  {
    ( 
      "+"                 (. oper = new AddOperator(t); .)
      | "-"               (. oper = new SubtractOperator(t); .)
    )                     (. oper.LeftOperand = expr; .)
                          (. Expression unExpr; .)
    Unary<out unExpr>     (. BinaryOperator rightExpr; .) 
    MulExpr<out rightExpr>
                          (. 
                             if (rightExpr == null) 
                             {
                               oper.RightOperand = unExpr;
                             }
                             else
                             {
                               oper.RightOperand = rightExpr;
                               rightExpr.LeftOperand = unExpr;
                             }
                             expr = oper;
                          .)
  }
.

// ------------------------------------------------------------------------------------
// Defines multiplication operators.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
MulExpr<out BinaryOperator expr> 
                          (. 
                             expr = null;
                             BinaryOperator oper = null; 
                          .)
=                          
  {
    (
      "*"                 (. oper = new MultiplyOperator(t); .)
      | "/"               (. oper = new DivideOperator(t); .)
      | "%"               (. oper = new ModuloOperator(t); .)
    )                     (. oper.LeftOperand = expr; .)
                          (. Expression unExpr; .)
    Unary<out unExpr>     (. oper.RightOperand = unExpr; .)
                          (. expr = oper; .)
  }
                          
.

// ------------------------------------------------------------------------------------
// Retrieves an unary expression.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
Unary<out Expression expr>    
              (. 
                 UnaryOperator unOp = null;
                 expr = null;
              .)
=
  (
    IF (unaryHead[la.kind] || IsTypeCast())
    ( 
      "+"     (. unOp = new UnaryPlusOperator(t); .)
      | "-"   (. unOp = new UnaryMinusOperator(t); .)
      | "!"   (. unOp = new NotOperator(t); .)
      | "~"   (. unOp = new BitwiseNotOperator(t); .)
      | "++"  (. unOp = new PreIncrementOperator(t); .)
      | "--"  (. unOp = new PreDecrementOperator(t); .)
      | "*"   (. unOp = new PointerOperator(t); .)
      | "&"   (. unOp = new ReferenceOperator(t); .)
      | "("   (. TypeReference typeRef; .)
        Type<out typeRef, false> 
        ")"   (. TypeCastOperator tcOp = new TypeCastOperator(t); .)
              (. tcOp.Type = typeRef; .)
              (. unOp = tcOp; .)
              
    )
  )
              (. Expression unaryExpr; .)
  Unary<out unaryExpr>
              (. 
                 if (unOp == null) expr = unaryExpr;
                 else
                 {
                   unOp.Operand = unaryExpr;
                   expr = unOp;
                 }
              .)
  | Primary<out expr>
.

// ------------------------------------------------------------------------------------
// Retrieves a primary expression.
// +expr: expression retrieved.
// ------------------------------------------------------------------------------------
Primary<out Expression expr>  (. TypeReference type = new TypeReference(t); 
                                 Expression innerExpr = null;
                                 expr = null;
                              .)
=
  ( 
    Literal<out innerExpr>             
  | "(" Expression<out innerExpr> ")"  (. if (innerExpr != null) innerExpr.BracketsUsed = true; .)
  | PrimitiveNamedLiteral<out innerExpr>
  | NamedLiteral<out innerExpr>
  | "this" (. innerExpr = new ThisLiteral(t); .)
  | "base" ( BaseNamedLiteral<out expr> | BaseIndexerOperator<out expr> )  
  | NewOperator<out innerExpr>
  | TypeOfOperator<out innerExpr>
  | CheckedOperator<out innerExpr>
  | UncheckedOperator<out innerExpr>
  | DefaultOperator<out innerExpr>
  | AnonymousDelegate<out innerExpr>
  | SizeOfOperator<out innerExpr>
  )

  (. Expression curExpr = innerExpr; .)

  { 
      "++"  (. curExpr = new PostIncrementOperator(t, innerExpr); .) 
    | "--"  (. curExpr = new PostDecrementOperator(t, innerExpr); .) 
    | "->"  (. NamedLiteral nl; .)
      SimpleNamedLiteral<out nl>
            (. curExpr = new CTypeMemberAccessOperator(t, innerExpr, nl); .)
    | "."   (. NamedLiteral nl; .)
      SimpleNamedLiteral<out nl>
            (. curExpr = new MemberAccessOperator(t, innerExpr, nl); .)
    | "("   (. ArgumentListOperator alop = new ArgumentListOperator(t, innerExpr); .)
        [ Argument<alop.Arguments> { "," Argument<alop.Arguments> } ] 
      ")"   (. curExpr = alop; .)
    |       (. ArrayIndexerOperator aiop = new ArrayIndexerOperator(t, innerExpr); .)                                                                         
      ArrayIndexer<aiop> 
            (. curExpr = aiop; .)
  }
  
  (. expr = curExpr; .)
.

// ------------------------------------------------------------------------------------
// Declaration of a literal expression.
// +value: Literal expression value.
// ------------------------------------------------------------------------------------
Literal<out Expression value>
  (. value = null; .)
= 
  intCon        (. value = IntegerConstant.Create(t); .)
  | realCon     (. value = RealConstant.Create(t); .)
  | charCon     (. value = new CharLiteral(t); .)
  | stringCon   (. value = new StringLiteral(t); .)
  | "true"      (. value = new TrueLiteral(t); .)
  | "false"     (. value = new FalseLiteral(t); .)
  | "null"      (. value = new NullLiteral(t); .)
.

// ------------------------------------------------------------------------------------
// Declaration of a primitive named literal expression.
// +expr: Literal expression value.
// ------------------------------------------------------------------------------------
PrimitiveNamedLiteral<out Expression expr>  (. expr = null; .)
= 
  (   "bool"  
    | "byte"   
    | "char" 
    | "decimal" 
    | "double"
    | "float" 
    | "int"    
    | "long" 
    | "object"  
    | "sbyte"
    | "short" 
    | "string" 
    | "uint" 
    | "ulong"   
    | "ushort"
  )             (. PrimitiveNamedLiteral pml = new PrimitiveNamedLiteral(t); .)
                (. expr = pml; .)
                (. pml.Type = new TypeReference(t); .)
  "." 
  ident         (. pml.Name = t.val; .)
  [ 
    IF (IsGeneric()) TypeArgumentList<pml.TypeArguments> 
  ]
.

// ------------------------------------------------------------------------------------
// Declaration of a named literal expression.
// +expr: Literal expression value.
// ------------------------------------------------------------------------------------
NamedLiteral<out Expression expr>  (. expr = null; .)
= 
  ident        (. NamedLiteral nl = new NamedLiteral(t); .)
               (. expr = nl; .)
               (. nl.Name = t.val; .)
  [ "::"       (. nl.IsGlobal = true; .)
    ident      (. nl.Name = t.val; .)
  ] 
  [ IF (IsGeneric()) TypeArgumentList<nl.TypeArguments> ]
.

// ------------------------------------------------------------------------------------
// Declaration of a simple named literal expression.
// +expr: Named literal expression value.
// ------------------------------------------------------------------------------------
SimpleNamedLiteral<out NamedLiteral expr> 
= 
  ident        (. expr = new NamedLiteral(t); .)
  [ IF (IsGeneric()) TypeArgumentList<expr.TypeArguments> ]
.

// ------------------------------------------------------------------------------------
// Declaration of a named literal expression.
// +expr: Literal expression value.
// ------------------------------------------------------------------------------------
BaseNamedLiteral<out Expression expr>  (. expr = null; .)
= 
  "."       
  ident    (. BaseNamedLiteral bnl = new BaseNamedLiteral(t); .)
           (. bnl.Name = t.val; .)
           (. expr = bnl; .)
   [ IF (IsGeneric()) TypeArgumentList<bnl.TypeArguments> ]
.

// ------------------------------------------------------------------------------------
// Declaration of a base indexer operator expression.
// +expr: Expression value.
// ------------------------------------------------------------------------------------
BaseIndexerOperator<out Expression expr>
= 
  "["                             (. BaseIndexerOperator bio = new BaseIndexerOperator(t); .)
                                  (. expr = bio; .)
                                  (. Expression indexExpr; .)
  Expression<out indexExpr>       (. bio.Indexes.Add(indexExpr); .) 
    { "," 
      Expression<out indexExpr>   (. bio.Indexes.Add(indexExpr); .) 
    } 
  "]"
.

// ------------------------------------------------------------------------------------
// Declaration of a typeof operator.
// +expr: Expression value.
// ------------------------------------------------------------------------------------
TypeOfOperator<out Expression expr>
= 
  "typeof"                   (. TypeOfOperator top = new TypeOfOperator(t); .)
  "("                        (. expr = top; .)
                             (. TypeReference typeRef; .)
    Type<out typeRef, true>  (. top.Type = typeRef; .)
  ")"
.

// ------------------------------------------------------------------------------------
// Declaration of a sizeof operator.
// +expr: Expression value.
// ------------------------------------------------------------------------------------
SizeOfOperator<out Expression expr>
= 
  "sizeof"                   (. SizeOfOperator sop = new SizeOfOperator(t); .)
  "("                        (. expr = sop; .)
                             (. TypeReference typeRef; .)
    Type<out typeRef, true>  (. sop.Type = typeRef; .)
  ")"
.

// ------------------------------------------------------------------------------------
// Declaration of a checked operator.
// +expr: Expression value.
// ------------------------------------------------------------------------------------
CheckedOperator<out Expression expr>
= 
  "checked"                     (. CheckedOperator cop = new CheckedOperator(t); .)
  "("                           (. expr = cop; .)
                                (. Expression innerExpr; .)
    Expression<out innerExpr>   (. cop.Operand = innerExpr; .)
  ")"
.

// ------------------------------------------------------------------------------------
// Declaration of an unchecked operator.
// +expr: Expression value.
// ------------------------------------------------------------------------------------
UncheckedOperator<out Expression expr>
= 
  "unchecked"                   (. UncheckedOperator uop = new UncheckedOperator(t); .)
  "("                           (. expr = uop; .)
                                (. Expression innerExpr; .)
    Expression<out innerExpr>   (. uop.Operand = innerExpr; .)
  ")"
.

// ------------------------------------------------------------------------------------
// Declaration of a default operator.
// +expr: Expression value.
// ------------------------------------------------------------------------------------
DefaultOperator<out Expression expr>
= 
  "default"                 (. DefaultOperator dop = new DefaultOperator(t); .)
  "("                       (. expr = dop; .)
                            (. Expression innerExpr; .)
    Primary<out innerExpr>  (. dop.Operand = innerExpr; .)
  ")"
.

// ------------------------------------------------------------------------------------
// Declaration of a "new" operator.
// +expr: Expression value.
// ------------------------------------------------------------------------------------
NewOperator<out Expression expr>  (. ArrayInitializer arrayInit; .)
= 
  "new"                           (. NewOperator nop = new NewOperator(t); .)
                                  (. expr = nop; .)
                                  (. TypeReference typeRef; .)
  Type<out typeRef, false>        (. nop.Type = typeRef; .)
  (
    // --- Simple constructor call
    "(" 
    [ 
      Argument<nop.Arguments> 
      { "," Argument<nop.Arguments> } 
    ] 
    ")"
  | // --- New array creation
    "["                           (. Expression dimExpr; .)
    Expression<out dimExpr>       (. nop.Dimensions.Add(dimExpr); .)
    { 
      "," 
      Expression<out dimExpr>     (. nop.Dimensions.Add(dimExpr); .)
    } 
    "]" 
    { IF (IsDims()) 
      "["                         (. nop.RunningDimensions = 1; .)
       { 
          ","                     (. nop.RunningDimensions++; .)
       } 
      "]" 
    }
    [                             
      ArrayInitializer<out arrayInit> (. nop.Initializer = arrayInit; .)
    ] 
  | // --- Array initialization
    ArrayInitializer<out arrayInit>  (. nop.Initializer = arrayInit; .)
  )
.

// ------------------------------------------------------------------------------------
// Declaration of a "new" operator.
// +expr: Expression value.
// ------------------------------------------------------------------------------------
AnonymousDelegate<out Expression expr>  
= 
  "delegate"            (. AnonymousDelegateOperator adop = new AnonymousDelegateOperator(t); .)
  [                     (. FormalParameter param; .)
    "(" 
    [ 
      AnonymousMethodParameter<out param>     (. adop.FormalParameters.Add(param); .)
      { 
        "," 
        AnonymousMethodParameter<out param>   (. adop.FormalParameters.Add(param); .)
      } 
    ] 
    ")" 
  ] 
  Block<adop>           (. expr = adop; .)
.

// ------------------------------------------------------------------------------------
// Declaration of an anonymous method parameter.
// +param: Parameter definition.
// ------------------------------------------------------------------------------------
AnonymousMethodParameter<out FormalParameter param> (. param = new FormalParameter(t); .)
=
  [                             
    "ref"                       (. param.Kind = FormalParameterKind.Ref; .) 
    | "out"                     (. param.Kind = FormalParameterKind.Out; .) 
  ]                             (. TypeReference typeRef; .)
  Type<out typeRef, false>      (. param.Type = typeRef; .)
  ident                         (. param.Name = t.val; .)
.

// ------------------------------------------------------------------------------------
// Declaration of a "new" operator.
// +expr: Expression value.
// ------------------------------------------------------------------------------------
ArrayIndexer<ArrayIndexerOperator indexer>  
= 
  "["                         (. Expression expr; .)
  Expression<out expr>        (. indexer.Indexers.Add(expr); .)
  { 
    "," 
    Expression<out expr>      (. indexer.Indexers.Add(expr); .)
  } 
  "]"
.

// ------------------------------------------------------------------------------------
// Declaration of a field member variable.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// +typeRef: Type of the constant.
// +isEvent: Flags, if the field is an event field or not.
// ------------------------------------------------------------------------------------
FieldMemberDeclarators<AttributeCollection attrs, Modifiers m, TypeDeclaration td, 
  TypeReference typeRef, bool isEvent, Modifier toCheck>
=            (. 
                m.Check(toCheck);
                if (typeRef.Kind == TypeKind.@void) { Error("field type must not be void"); } 
             .)
  SingleFieldMember<attrs, m, td, typeRef, isEvent>
  { "," SingleFieldMember<attrs, m, td, typeRef, isEvent> }
.

// ------------------------------------------------------------------------------------
// Declaration of a single field member.
// +attrs: attributes of the declaration
// +modifiers: Set of modifiers belonging to the member.
// +td: Type declaration the member belongs to.
// +typeRef: Type of the constant.
// +isEvent: Flags, if the field is an event field or not.
// ------------------------------------------------------------------------------------
SingleFieldMember<AttributeCollection attrs, Modifiers m, TypeDeclaration td, 
  TypeReference typeRef, bool isEvent>
= 
  ident                      (. 
                                FieldDeclaration fd = new FieldDeclaration(t); 
                                fd.SetModifiers(m.Value);
                                fd.AssignAttributes(attrs);
                                fd.ResultingType = typeRef;
                                fd.Name = t.val;
                                fd.IsEvent = isEvent;
                             .)
  [ "="                      (. Initializer init; .)
    VariableInitializer<out init> (. fd.Initializer = init; .) 
  ]                          (. td.Members.Add(fd); .) 
.

// ------------------------------------------------------------------------------------
// Defines the operators that can be overloaded.
// +op: overloaddable operator.
// ------------------------------------------------------------------------------------
OverloadableOp<out Operator op> (. op = Operator.plus; .)
=                          
    "+"                                     
  | "-"                         (. op = Operator.minus; .)
  | "!"                         (. op = Operator.not; .)
  | "~"                         (. op = Operator.tilde; .)
  | "++"                        (. op = Operator.inc; .)
  | "--"                        (. op = Operator.dec; .)
  | "true"                      (. op = Operator.@true; .)
  | "false"                     (. op = Operator.@false; .)
  | "*"                         (. op = Operator.times; .)
  | "/"                         (. op = Operator.div; .)
  | "%"                         (. op = Operator.mod; .)
  | "&"                         (. op = Operator.and; .)
  | "|"                         (. op = Operator.or; .)
  | "^"                         (. op = Operator.xor; .)
  | "<<"                        (. op = Operator.lshift; .)
  | "=="                        (. op = Operator.eq; .)
  | "!="                        (. op = Operator.neq; .)
  | ">"                         (. op = Operator.gt; .)
        [                       (. if (la.pos > t.pos+1) Error("no whitespace allowed in right shift operator"); .)
          ">"                   (. op = Operator.rshift; .)
        ]
  | "<"                         (. op = Operator.lt; .)
  | ">="                        (. op = Operator.gte; .)
  | "<="                        (. op = Operator.lte; .)
.

// ------------------------------------------------------------------------------------
// Type parameter declarations for generic types.
// +td: Type parameter owner.
// ------------------------------------------------------------------------------------
TypeParameterList<ITypeParameterOwner td>
=                            
  "<"                        (. TypeParameter tp; .)
  TypeParameter<out tp>      (. td.AddTypeParameter(tp); .)
  { "," 
    TypeParameter<out tp>    (. td.AddTypeParameter(tp); .)
  } ">"
.

// ------------------------------------------------------------------------------------
// Declaration of a type parameter.
// +tp: Type parameter defined here.
// ------------------------------------------------------------------------------------
TypeParameter<out TypeParameter tp>
=                                   (. AttributeCollection attrs = new AttributeCollection(); .)
  { Attributes<attrs> } 
  ident                             (. 
                                       tp = new TypeParameter(t);
                                       tp.Name = t.val;
                                       tp.AssignAttributes(attrs);
                                    .)
.

// ------------------------------------------------------------------------------------
// Declaration of a type argument list.
// +typeRef: Type that has the argument list defined here.
// ------------------------------------------------------------------------------------
TypeArgumentList<TypeReferenceCollection args>  (. TypeReference paramType; .)
=
  /*
     We are a bit sloppy here and allow the type arguments to be "empty"
     everywhere. This results in unbound-type-names. In fact this is only
     allowed in typeof statements, see ECMA-334: 14.5.11 and 25.5.
  */
  "<" 
  [ 
    Type<out paramType, false>           (. args.Add(paramType); .) 
  ] { "," 
  [ 
    Type<out paramType, false>           (. args.Add(paramType); .) 
  ] } ">"
.

// ------------------------------------------------------------------------------------
// Declaration of a type parameter constraint belonging to a type, a method or a 
// delegate.
// +constraint: Declaration of the constraint
// ------------------------------------------------------------------------------------
TypeParameterConstraintsClause<out TypeParameterConstraint constraint>         
=
  ident                            (. if (t.val != "where") 
                                        Error("type parameter constraints clause must start with: where");
                                   .)
  ident                            (. 
                                      constraint = new TypeParameterConstraint(t); 
                                      constraint.Name = t.val;
                                   .)
  ":"                              (. 
                                      TypeReference typeRef; 
                                      constraint.ParameterType = ParameterConstraintType.Type;
                                   .)
  ( 
    ( 
      (
        "class"                    (. constraint.ParameterType = ParameterConstraintType.Class; .)
        | "struct"                 (. constraint.ParameterType = ParameterConstraintType.Struct; .)
      )                            (.
                                      typeRef = new TypeReference(t);
                                      typeRef.Name = t.val;
                                   .)
      | TypeName<out typeRef>                                   
    )
                                   (. constraint.Constraints.Add(typeRef); .) 
    { 
      IF (la.kind == _comma && Peek(1).kind != _new) "," 
      TypeName<out typeRef>        (. constraint.Constraints.Add(typeRef); .) 
    } 
    [ 
      "," "new" "(" ")"            (. constraint.HasNew = true; .)
    ]
  | 
  "new" "(" ")"                    (. constraint.HasNew = true; .)
  )
.

END CS2.

