/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.

This file has been modified by Novák István to customize it to the
C# syntax as used by the LINQ over CSharp project.
----------------------------------------------------------------------*/
-->begin
using System;

-->namespace

// ==================================================================================
/// <summary>
/// This class implements the C# syntax parser functionality.
/// </summary>
// ==================================================================================
public class CSharpSyntaxParser 
{
  #region These constants represent the grammar elements of the C# syntax.
  
-->constants
  #endregion

  #region These constants are used within the parser independently of C# syntax.

  /// <summary>Represents the "true" value in the token set table.</summary>
  const bool T = true;

  /// <summary>Represents the "false" value in the token set table.</summary>
  const bool x = false;
	
  /// <summary>
  /// Represents the minimum distance (measured by tokens) between two error points 
  /// that are taken into account as separate errors.
  /// </summary>
  const int MinimumDistanceOfSeparateErrors = 2;

  #endregion

  #region Fields used by the parser

  /// <summary>Scanner used by the parser to obtain tokens.</summary>
  private Scanner _Scanner;

  /// <summary>Represents the last recognized token.</summary>
  private Token t;
  
  /// <summary>Represents the lookahead token.</summary>
  private Token la;

  /// <summary>Represents the current distance from the last error.</summary>
  private int errDist = MinimumDistanceOfSeparateErrors;

  public const int ppIfKind = _ppIf;
  public const int ppElifKind = _ppElif;
  public const int ppElseKind = _ppElse;
  public const int ppEndifKind = _ppEndif;
  public const int EOFKind = _EOF;

  #endregion

-->declarations

    #region Project Model extension fields

    private CompilationUnit _CompilationUnit;
    private SourceFile _File;
    private LanguageElement _CurrentElement;
    private CommentInfo _OrphanComment;
    private PragmaHandler _PragmaHandler;
    private CommentHandler _CommentHandler;

    #endregion 
    
    #region Lifecycle methods
    
    // --------------------------------------------------------------------------------
    /// <summary>
    /// Creates a new instance of this parser using the specified scanner, compilation
    /// uint and file.
    /// </summary>
    /// <param name="scanner">The scanner used to scan tokens.</param>
    /// <param name="unit">Compilation unit using this parser instance.</param>
    /// <param name="file">File used by this parser instance.</param>
    // --------------------------------------------------------------------------------
  	public CSharpSyntaxParser(Scanner scanner, CompilationUnit unit, SourceFile file) 
  	{
	  	_Scanner = scanner;
		  _CompilationUnit = unit;
		  _File = file;
      _PragmaHandler = new PragmaHandler(this);
      _CommentHandler = new CommentHandler(this);
  	}
  	
    #endregion
    
    #region Public properties
    
    // --------------------------------------------------------------------------------
    /// <summary>
    /// Gets or sets the instance representing the compilation unit being parsed
    /// </summary>
    // --------------------------------------------------------------------------------
    public CompilationUnit CompilationUnit
    {
      get { return _CompilationUnit; }
      set { _CompilationUnit = value; }
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Gets or sets the instance representing the file being parsed
    /// </summary>
    // --------------------------------------------------------------------------------
    public SourceFile File
    {
      get { return _File; }
      set { _File = value; }
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Gets or sets the languauge element that is currently processed.
    /// </summary>
    // --------------------------------------------------------------------------------
    public LanguageElement CurrentElement
    {
      get { return _CurrentElement; }
      set
      {
        _CurrentElement = value;
        if (_OrphanComment != null && _OrphanComment.Token.pos < _CurrentElement.Token.pos)
        {
          // --- The orphan comment can be added to this language element.
          _CurrentElement.Comment = _OrphanComment;
          _OrphanComment = null;
        }
      }
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Gets or sets the last comment that is not assigned to any language element.
    /// </summary>
    // --------------------------------------------------------------------------------
    public CommentInfo OrphanComment
    {
      get { return _OrphanComment; }
      set { _OrphanComment = value; }
    } 
    
    // --------------------------------------------------------------------------------
    /// <summary>
    /// Gets the scanner used by this parser.
    /// </summary>
    // --------------------------------------------------------------------------------
    public Scanner Scanner
    {
      get { return _Scanner; }
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Gets the pragma handler used by this parser.
    /// </summary>
    // --------------------------------------------------------------------------------
    internal PragmaHandler PragmaHandler
    {
      get { return _PragmaHandler; }
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Gets the comment handler used by this parser.
    /// </summary>
    // --------------------------------------------------------------------------------
    internal CommentHandler CommentHandler
    {
      get { return _CommentHandler; }
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Gets the lookahead token.
    /// </summary>
    // --------------------------------------------------------------------------------
    public Token Lookahead
    {
      get { return la; }
    }

    #endregion

	  #region Methods referenced when CoCo generates the parser code
	  
    // --------------------------------------------------------------------------------
    /// <summary>
    /// Gets the next token from the input stream.
    /// </summary>
    /// <remarks>
    /// <para>
    /// This method handles all the pragmas (like #region, #if, #endif, etc.) and 
    /// positions to the next token accordingly. Sets the private member "t" to the 
    /// current token, and member "la" to the next token.
    /// </para>
    /// <para>
    /// Line and block comments are handled by the scanner and not the parser.
    /// </para>
    /// </remarks>
    // --------------------------------------------------------------------------------
	  void Get () 
  	{
	  	for (;;) 
	  	{
        t = la;
        la = _Scanner.Scan();
        if (la.kind <= maxT) { ++errDist; break; }
-->pragmas
			  la = t;
      }
    }
	
    // --------------------------------------------------------------------------------
    /// <summary>
    /// Expects the next token to be as defined by tokenKind.
    /// </summary>
    /// <param name="tokenKind">Expected kind of token.</param>
    /// <remarks>
    /// If the token does not match with the kind specified, raises a syntax error.
    /// </remarks>
    // --------------------------------------------------------------------------------
    void Expect(int tokenKind)
    {
      if (la.kind == tokenKind) Get();
      else
      {
        SynErr(tokenKind);
      }
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Checks if the lookahead token can be a start for the specified tokenKind.
    /// </summary>
    /// <param name="tokenKind">Kind of token to examine.</param>
    /// <returns>
    /// True, if the lookahead token can be a strat for tokenKind; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool StartOf(int tokenKind)
    {
      return _StartupSet[tokenKind, la.kind];
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Expects the next token to be as defined by tokenKind. If the expected token is
    /// not found, steps forward in the input stream the find the token with type
    /// of "follow".
    /// </summary>
    /// <param name="tokenKind">Expected kind of token.</param>
    /// <param name="follow">Kind of week token to follow the parsing from.</param>
    /// <remarks>
    /// If the token does not match with the kind specified, raises a syntax error.
    /// </remarks>
    // --------------------------------------------------------------------------------
    void ExpectWeak(int tokenKind, int follow)
    {
      if (la.kind == tokenKind) Get();
      else
      {
        SynErr(tokenKind);
        while (!StartOf(follow)) Get();
      }
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Searches for a week separator.
    /// </summary>
    /// <param name="tokenKind"></param>
    /// <param name="syFol"></param>
    /// <param name="repFol"></param>
    /// <returns></returns>
    // --------------------------------------------------------------------------------
    bool WeakSeparator(int tokenKind, int syFol, int repFol)
    {
      bool[] s = new bool[maxT + 1];
      if (la.kind == tokenKind) { Get(); return true; }
      else if (StartOf(repFol)) return false;
      else
      {
        for (int i = 0; i <= maxT; i++)
        {
          s[i] = _StartupSet[syFol, i] || _StartupSet[repFol, i] || _StartupSet[0, i];
        }
        SynErr(tokenKind);
        while (!s[la.kind]) Get();
        return StartOf(syFol);
      }
    }
	
	  #endregion
	  
    #region Error handling

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Creates a new error instance.
    /// </summary>
    /// <param name="code">Error code.</param>
    /// <param name="errorPoint">Token describing the error position.</param>
    /// <param name="description">Detailed error description.</param>
    // --------------------------------------------------------------------------------
    public void Error(string code, Token errorPoint, string description)
    {
      _CompilationUnit.ErrorHandler.Error(code, errorPoint, description, null);
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Creates a new error instance.
    /// </summary>
    /// <param name="code">Error code.</param>
    /// <param name="errorPoint">Token describing the error position.</param>
    /// <param name="description">Detailed error description.</param>
    /// <param name="parameters">Error parameters.</param>
    // --------------------------------------------------------------------------------
    public void Error(string code, Token errorPoint, string description,
      params object[] parameters)
    {
      _CompilationUnit.ErrorHandler.Error(code, errorPoint, description, parameters);
    }

    #endregion

    #region Token sets

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Creates a BitArray with the specified values set.
    /// </summary>
    /// <param name="values">Values to set in the BitArray</param>
    /// <returns></returns>
    // --------------------------------------------------------------------------------
    static BitArray NewSet(params int[] values)
    {
      BitArray a = new BitArray(maxT);
      foreach (int item in values) a[item] = true;
      return a;
    }

    /// <summary>Tokens representing unary operators</summary>
    private static BitArray unaryOp =
      NewSet(_plus, _minus, _not, _tilde, _inc, _dec, _true, _false);

    /// <summary>Tokens representing type shortcuts</summary>
    private static BitArray typeKW =
      NewSet(_char, _bool, _object, _string, _sbyte, _byte, _short,
             _ushort, _int, _uint, _long, _ulong, _float, _double, _decimal);

    /// <summary>
    /// Tokens representing unary header tokens
    /// </summary>
    private static BitArray
      unaryHead = NewSet(_plus, _minus, _not, _tilde, _times, _inc, _dec, _and);

    /// <summary>
    /// Tokens representing assignment start tokens
    /// </summary>
    private static BitArray
      assnStartOp = NewSet(_plus, _minus, _not, _tilde, _times);

    /// <summary>Tokens that can follow a cast operation</summary>
    private static BitArray
      castFollower = NewSet(_tilde, _not, _lpar, _ident,
                            /* literals */
                            _intCon, _realCon, _charCon, _stringCon,
                            /* any keyword expect as and is */
                            _abstract, _base, _bool, _break, _byte, _case, _catch,
                            _char, _checked, _class, _const, _continue, _decimal, _default,
                            _delegate, _do, _double, _else, _enum, _event, _explicit,
                            _extern, _false, _finally, _fixed, _float, _for, _foreach,
                            _goto, _if, _implicit, _in, _int, _interface, _internal,
                            _lock, _long, _namespace, _new, _null, _object, _operator,
                            _out, _override, _params, _private, _protected, _public,
                            _readonly, _ref, _return, _sbyte, _sealed, _short, _sizeof,
                            _stackalloc, _static, _string, _struct, _switch, _this, _throw,
                            _true, _try, _typeof, _uint, _ulong, _unchecked, _unsafe,
                            _ushort, _usingKW, _virtual, _void, _volatile, _while
        );

    /// <summary>Tokens that can follow argument lists</summary>
    private static BitArray
      typArgLstFol = NewSet(_lpar, _rpar, _rbrack, _colon, _scolon, _comma, _dot,
                            _question, _eq, _neq);

    /// <summary>Reserved C# keywords</summary>
    private static BitArray
      keyword = NewSet(_abstract, _as, _base, _bool, _break, _byte, _case, _catch,
                       _char, _checked, _class, _const, _continue, _decimal, _default,
                       _delegate, _do, _double, _else, _enum, _event, _explicit,
                       _extern, _false, _finally, _fixed, _float, _for, _foreach,
                       _goto, _if, _implicit, _in, _int, _interface, _internal,
                       _is, _lock, _long, _namespace, _new, _null, _object, _operator,
                       _out, _override, _params, _private, _protected, _public,
                       _readonly, _ref, _return, _sbyte, _sealed, _short, _sizeof,
                       _stackalloc, _static, _string, _struct, _switch, _this, _throw,
                       _true, _try, _typeof, _uint, _ulong, _unchecked, _unsafe,
                       _ushort, _usingKW, _virtual, _void, _volatile, _while);

    /// <summary>Assignment operators</summary>
    private static BitArray
      assgnOps = NewSet(_assgn, _plusassgn, _minusassgn, _timesassgn, _divassgn,
                     _modassgn, _andassgn, _orassgn, _xorassgn, _lshassgn);
                 // rshassgn: ">" ">="  no whitespace allowed

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Return the n-th token after the current lookahead token. 
    /// </summary>
    /// <param name="n">Number of tokens to skip.</param>
    /// <returns>n-th token after the current lookahead token.</returns>
    // --------------------------------------------------------------------------------
    Token Peek(int n)
    {
      _Scanner.ResetPeek();
      Token x = la;
      while (n > 0) { x = _Scanner.Peek(); n--; }
      return x;
    }

    #endregion
    
    #region Resolvers
    
    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the next token are: ident "="
    /// </summary>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsAssignment()
    {
      return la.kind == _ident && Peek(1).kind == _assgn;
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the next token is not a final comma in a list.
    /// </summary>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool NotFinalComma()
    {
      int peek = Peek(1).kind;
      return la.kind == _comma && peek != _rbrace && peek != _rbrack;
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Checks whether the next sequence of tokens is a qualident and returns the 
    /// qualident string.
    /// </summary>
    /// <param name="pt">Peek token</param>
    /// <param name="qualident">Qualident string</param>
    /// <returns>
    /// True, if the lookahead indicates a qualident; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsQualident(ref Token pt, out string qualident)
    {
      qualident = "";
      if (pt.kind == _ident)
      {
        qualident = pt.val;
        pt = _Scanner.Peek();
        while (pt.kind == _dot)
        {
          pt = _Scanner.Peek();
          if (pt.kind != _ident) return false;
          qualident += "." + pt.val;
          pt = _Scanner.Peek();
        }
        return true;
      }
      else return false;
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the current type represents a generic type.
    /// </summary>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsGeneric()
    {
      _Scanner.ResetPeek();
      Token pt = la;
      if (!IsTypeArgumentList(ref pt))
      {
        return false;
      }
      return typArgLstFol[pt.kind];
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the next tokens represent a type argument list.
    /// </summary>
    /// <param name="pt">Token following the type argument list.</param>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsTypeArgumentList(ref Token pt)
    {
      if (pt.kind == _lt)
      {
        pt = _Scanner.Peek();
        while (true)
        {
          if (!IsType(ref pt))
          {
            return false;
          }
          if (pt.kind == _gt)
          {
            // list recognized
            pt = _Scanner.Peek();
            break;
          }
          else if (pt.kind == _comma)
          {
            // another argument
            pt = _Scanner.Peek();
          }
          else
          {
            // error in type argument list
            return false;
          }
        }
      }
      else
      {
        return false;
      }
      return true;
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the next tokens represent a type.
    /// </summary>
    /// <param name="pt">Token following the type.</param>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsType(ref Token pt)
    {
      String dummyId;

      if (typeKW[pt.kind])
      {
        pt = _Scanner.Peek();
      }
      else if (pt.kind == _void)
      {
        pt = _Scanner.Peek();
        if (pt.kind != _times)
        {
          return false;
        }
        pt = _Scanner.Peek();
      }
      else if (pt.kind == _ident)
      {
        pt = _Scanner.Peek();
        if (pt.kind == _dblcolon || pt.kind == _dot)
        {
          // either namespace alias qualifier "::" or first
          // part of the qualident
          pt = _Scanner.Peek();
          if (!IsQualident(ref pt, out dummyId))
          {
            return false;
          }
        }
        if (pt.kind == _lt && !IsTypeArgumentList(ref pt))
        {
          return false;
        }
      }
      else
      {
        return false;
      }
      if (pt.kind == _question)
      {
        pt = _Scanner.Peek();
      }
      return SkipPointerOrDims(ref pt);
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the next tokens represent a local variable 
    /// declaration: Type ident.
    /// </summary>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    /// <remarks>
    /// Type can be void*
    /// </remarks>
    // --------------------------------------------------------------------------------
    bool IsLocalVarDecl()
    {
      Token pt = la;
      _Scanner.ResetPeek();
      return IsType(ref pt) && pt.kind == _ident;
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the next tokens represent dimensions:
    /// "[" ("," | "]")
    /// </summary>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsDims()
    {
      int peek = Peek(1).kind;
      return la.kind == _lbrack && (peek == _comma || peek == _rbrack);
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the next tokens represent pointer or dimensions:
    /// "*" | "[" ("," | "]")
    /// </summary>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsPointerOrDims()
    {
      return la.kind == _times || IsDims();
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to skip pointer or dimension tokens.
    /// </summary>
    /// <param name="pt">The current token after skip.</param>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool SkipPointerOrDims(ref Token pt)
    {
      for (; ; )
      {
        if (pt.kind == _lbrack)
        {
          do pt = _Scanner.Peek();
          while (pt.kind == _comma);
          if (pt.kind != _rbrack) return false;
        }
        else if (pt.kind != _times) break;
        pt = _Scanner.Peek();
      }
      return true;
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if there is an attribute target specifier:
    /// (ident | keyword) ":"
    /// </summary>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsAttrTargSpec()
    {
      return (la.kind == _ident || keyword[la.kind]) && Peek(1).kind == _colon;
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the next tokens represent a field declaration:
    /// ident ("," | "=" | ";")
    /// </summary>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsFieldDecl()
    {
      int peek = Peek(1).kind;
      return la.kind == _ident &&
             (peek == _comma || peek == _assgn || peek == _scolon);
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the next tokens represent a type cast.
    /// </summary>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsTypeCast()
    {
      if (la.kind != _lpar) { return false; }
      if (IsSimpleTypeCast()) { return true; }
      return GuessTypeCast();
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the next tokens represent a type cast keyword:
    /// "(" typeKW ")"
    /// </summary>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsSimpleTypeCast()
    {
      // assert: la.kind == _lpar
      _Scanner.ResetPeek();
      Token pt1 = _Scanner.Peek();
      Token pt2 = _Scanner.Peek();
      return typeKW[pt1.kind] &&
              (pt2.kind == _rpar ||
              (pt2.kind == _question && _Scanner.Peek().kind == _rpar));
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the next tokens represent a type cast by guess:
    /// "(" Type ")" castFollower
    /// </summary>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool GuessTypeCast()
    {
      // assert: la.kind == _lpar
      _Scanner.ResetPeek();
      Token pt = _Scanner.Peek();
      if (!IsType(ref pt))
      {
        return false;
      }
      if (pt.kind != _rpar)
      {
        return false;
      }
      pt = _Scanner.Peek();
      return castFollower[pt.kind];
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the next tokens represent a global assembly target:
    /// "[" "assembly"
    /// </summary>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsGlobalAttrTarget()
    {
      Token pt = Peek(1);
      return la.kind == _lbrack && pt.kind == _ident && ("assembly".Equals(pt.val) || "module".Equals(pt.val));
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the next tokens represent an extern directive:
    /// "extern"
    /// </summary>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsExternAliasDirective()
    {
      return la.kind == _extern;
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the next tokens no switch case or right backet.
    /// </summary>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsNoSwitchLabelOrRBrace()
    {
      return (la.kind != _case && la.kind != _default && la.kind != _rbrace) ||
             (la.kind == _default && Peek(1).kind != _colon);
    }

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Lookahead method to check if the next token defines a shift operator.
    /// </summary>
    /// <returns>
    /// True, if lookahed resulted with the expected result; otherwise, false.
    /// </returns>
    // --------------------------------------------------------------------------------
    bool IsShift()
    {
      Token pt = Peek(1);
      return (la.kind == _ltlt) ||
             (la.kind == _gt &&
               pt.kind == _gt &&
               (la.pos + la.val.Length == pt.pos)
             );
    }

    // true: TypeArgumentList followed by anything but "("
    bool IsPartOfMemberName()
    {
      _Scanner.ResetPeek();
      Token pt = la;
      if (!IsTypeArgumentList(ref pt))
      {
        return false;
      }
      return pt.kind != _lpar;
    }

	  #endregion
	  
    #region Common methods used from outside

    // --------------------------------------------------------------------------------
    /// <summary>
    /// Checks if the pragma is the first token in the current line.
    /// </summary>
    /// <param name="symbol">Token representing the pragma.</param>
    /// <returns>True, if the pragma is the first token; otherwise, false.</returns>
    // --------------------------------------------------------------------------------
    public bool CheckTokenIsFirstInLine(Token symbol)
    {
      int oldPos = _Scanner.Buffer.Pos;
      bool wsOnly = true;
      for (int i = symbol.col - 1; i >= 1; i--)
      {
        _Scanner.Buffer.Pos = symbol.pos - i;
        int ch = _Scanner.Buffer.Peek();
        wsOnly &= (ch == ' ' || (ch >= 9 && ch <= 13));
      }
      _Scanner.Buffer.Pos = oldPos;
      return wsOnly;
    }

    #endregion

	  #region Parser methods generated by CoCo
	  
-->productions
    #endregion
    
    // --------------------------------------------------------------------------------
    /// <summary>
    /// Starts parsing and parses the whole input accordingly to the specified language
    /// (C#) syntax.
    /// </summary>
    /// <remarks>
    /// Source should be parsed fully: the file must be ended when parsing is ready.
    /// </remarks>
    // --------------------------------------------------------------------------------
    public void Parse()
    {
		  la = new Token();
		  la.val = "";		
		  Get();
-->parseRoot
      Expect(0);
      if (_PragmaHandler.OpenRegionCount > 0)
      {
        _CompilationUnit.ErrorHandler.Error("CS1038", la, "#endregion directive expected.");
      }
  	}
	
    // --------------------------------------------------------------------------------
    /// <summary>This array represent the matrix of startup tokens.</summary>
    /// <remarks>
    /// In the cell of this matrix there is an "x" representing false and 
    /// "T" representing true. A cells contains true, if the token kind represented by
    /// the column (second dimension) can be directly followed by the token kind
    /// represented by the row (first dimension).
    /// </remarks>
    // --------------------------------------------------------------------------------
	  private bool[,] _StartupSet = 
    {
-->initialization
	  };

	  #region Syntax error handling
	  
  	void SynErr (int n) 
  	{
		  if (errDist >= MinimumDistanceOfSeparateErrors)
  		{
    		string s;
		    switch (n) 
		    {
-->errors
  			  default: s = "error " + n; break;
	  	  }
        _CompilationUnit.ErrorHandler.Error("SYNERR", la, s, null);
	  	}
		  errDist = 0;
	  }

	  #endregion
}

public class FatalError: Exception {
	public FatalError(string m): base(m) {}
}

$$$